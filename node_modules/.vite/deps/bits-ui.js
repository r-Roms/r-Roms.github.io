import {
  esm_default
} from "./chunk-BR27A7DJ.js";
import {
  $11d87f3f76e88657$export$b4a036af3fc0b032,
  $14e0f24ef4ac5c92$export$2061056d06d7cdf7,
  $14e0f24ef4ac5c92$export$629b0a497aa65267,
  $14e0f24ef4ac5c92$export$a18c89cbd24170ff,
  $14e0f24ef4ac5c92$export$a2258d9c4118825c,
  $14e0f24ef4ac5c92$export$a5a3b454ada2268e,
  $14e0f24ef4ac5c92$export$aa8b41735afcabd2,
  $14e0f24ef4ac5c92$export$ea39ec197993aef0,
  $35ea8db9cb2ccb90$export$680ea196effce5f,
  $35ea8db9cb2ccb90$export$99faa760c7908e4f,
  $35ea8db9cb2ccb90$export$ca871e8dbb80966f,
  $35ea8db9cb2ccb90$export$d3b7288e7994edea,
  $fae977aafc393c5c$export$588937bcd60ade55,
  $fae977aafc393c5c$export$6b862160d295c8e,
  $fae977aafc393c5c$export$fd7893f06e92a6a4,
  $fb18d541ea1ad717$export$ad991b66133851cf
} from "./chunk-HH4IKM3L.js";
import {
  arrow,
  autoUpdate,
  computePosition,
  flip,
  hide,
  limitShift,
  offset,
  shift,
  size
} from "./chunk-ZHHKMDQI.js";
import {
  focusable,
  isFocusable,
  isTabbable,
  tabbable
} from "./chunk-33AJ44NO.js";
import "./chunk-ELKJSBLM.js";
import {
  SvelteMap
} from "./chunk-52VBG4KC.js";
import "./chunk-SA256WBI.js";
import "./chunk-7RQDXF5S.js";
import "./chunk-7TDO7NEC.js";
import {
  add_locations,
  append_styles,
  assign,
  attribute_effect,
  bind_this,
  bind_value,
  check_target,
  cleanup_styles,
  component,
  createAttachmentKey,
  create_ownership_validator,
  each,
  element,
  hmr,
  if_block,
  init,
  key,
  legacy_api,
  log_if_contains_state,
  onMount,
  prop,
  remove_input_defaults,
  rest_props,
  set_attribute,
  set_selected,
  set_style,
  snippet,
  spread_props,
  validate_binding,
  validate_dynamic_element_tag,
  validate_each_keys,
  validate_snippet_args,
  validate_void_dynamic_element,
  wrap_snippet
} from "./chunk-3TYTMPY3.js";
import {
  clsx
} from "./chunk-U7P2NEEE.js";
import {
  append,
  comment,
  from_html,
  from_svg,
  mount,
  props_id,
  set_text,
  text,
  unmount
} from "./chunk-VYXNJCXA.js";
import {
  FILENAME,
  HMR,
  add_svelte_meta,
  child,
  createSubscriber,
  effect_root,
  first_child,
  get,
  getAllContexts,
  getContext,
  hasContext,
  next,
  noop,
  on,
  pop,
  proxy,
  push,
  replay_events,
  reset,
  set,
  setContext,
  sibling,
  snapshot,
  state,
  strict_equals,
  tag,
  tag_proxy,
  template_effect,
  tick,
  track_reactivity_loss,
  untrack,
  user_derived,
  user_effect,
  user_pre_effect
} from "./chunk-YGPPJ7RW.js";
import "./chunk-55K7ITRW.js";
import {
  true_default
} from "./chunk-HNWPC2PS.js";
import "./chunk-K63UQA3V.js";
import {
  __export
} from "./chunk-G3PMV62Z.js";

// node_modules/bits-ui/dist/bits/accordion/exports.js
var exports_exports = {};
__export(exports_exports, {
  Content: () => accordion_content_default,
  Header: () => accordion_header_default,
  Item: () => accordion_item_default,
  Root: () => accordion_default,
  Trigger: () => accordion_trigger_default
});

// node_modules/svelte-toolbelt/dist/utils/is.js
function isFunction(value) {
  return typeof value === "function";
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
var CLASS_VALUE_PRIMITIVE_TYPES = ["string", "number", "bigint", "boolean"];
function isClassValue(value) {
  if (value === null || value === void 0)
    return true;
  if (CLASS_VALUE_PRIMITIVE_TYPES.includes(typeof value))
    return true;
  if (Array.isArray(value))
    return value.every((item) => isClassValue(item));
  if (typeof value === "object") {
    if (Object.getPrototypeOf(value) !== Object.prototype)
      return false;
    return true;
  }
  return false;
}

// node_modules/svelte-toolbelt/dist/box/box.svelte.js
var BoxSymbol = Symbol("box");
var isWritableSymbol = Symbol("is-writable");
function isBox(value) {
  return isObject(value) && BoxSymbol in value;
}
function isWritableBox(value) {
  return box.isBox(value) && isWritableSymbol in value;
}
function box(initialValue) {
  let current = tag(state(proxy(initialValue)), "current");
  return {
    [BoxSymbol]: true,
    [isWritableSymbol]: true,
    get current() {
      return get(current);
    },
    set current(v) {
      set(current, v, true);
    }
  };
}
function boxWith(getter, setter) {
  const derived = tag(user_derived(getter), "derived");
  if (setter) {
    return {
      [BoxSymbol]: true,
      [isWritableSymbol]: true,
      get current() {
        return get(derived);
      },
      set current(v) {
        setter(v);
      }
    };
  }
  return {
    [BoxSymbol]: true,
    get current() {
      return getter();
    }
  };
}
function boxFrom(value) {
  if (box.isBox(value)) return value;
  if (isFunction(value)) return box.with(value);
  return box(value);
}
function boxFlatten(boxes) {
  return Object.entries(boxes).reduce(
    (acc, [key2, b]) => {
      if (!box.isBox(b)) {
        return Object.assign(acc, { [key2]: b });
      }
      if (box.isWritableBox(b)) {
        Object.defineProperty(acc, key2, {
          get() {
            return b.current;
          },
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          set(v) {
            b.current = v;
          }
        });
      } else {
        Object.defineProperty(acc, key2, {
          get() {
            return b.current;
          }
        });
      }
      return acc;
    },
    {}
  );
}
function toReadonlyBox(b) {
  if (!box.isWritableBox(b)) return b;
  return {
    [BoxSymbol]: true,
    get current() {
      return b.current;
    }
  };
}
box.from = boxFrom;
box.with = boxWith;
box.flatten = boxFlatten;
box.readonly = toReadonlyBox;
box.isBox = isBox;
box.isWritableBox = isWritableBox;

// node_modules/svelte-toolbelt/dist/utils/compose-handlers.js
function composeHandlers(...handlers) {
  return function(e) {
    for (const handler of handlers) {
      if (!handler)
        continue;
      if (e.defaultPrevented)
        return;
      if (typeof handler === "function") {
        handler.call(this, e);
      } else {
        handler.current?.call(this, e);
      }
    }
  };
}

// node_modules/svelte-toolbelt/dist/utils/strings.js
var NUMBER_CHAR_RE = /\d/;
var STR_SPLITTERS = ["-", "_", "/", "."];
function isUppercase(char = "") {
  if (NUMBER_CHAR_RE.test(char))
    return void 0;
  return char !== char.toLowerCase();
}
function splitByCase(str) {
  const parts = [];
  let buff = "";
  let previousUpper;
  let previousSplitter;
  for (const char of str) {
    const isSplitter = STR_SPLITTERS.includes(char);
    if (isSplitter === true) {
      parts.push(buff);
      buff = "";
      previousUpper = void 0;
      continue;
    }
    const isUpper = isUppercase(char);
    if (previousSplitter === false) {
      if (previousUpper === false && isUpper === true) {
        parts.push(buff);
        buff = char;
        previousUpper = isUpper;
        continue;
      }
      if (previousUpper === true && isUpper === false && buff.length > 1) {
        const lastChar = buff.at(-1);
        parts.push(buff.slice(0, Math.max(0, buff.length - 1)));
        buff = lastChar + char;
        previousUpper = isUpper;
        continue;
      }
    }
    buff += char;
    previousUpper = isUpper;
    previousSplitter = isSplitter;
  }
  parts.push(buff);
  return parts;
}
function pascalCase(str) {
  if (!str)
    return "";
  return splitByCase(str).map((p2) => upperFirst(p2)).join("");
}
function camelCase(str) {
  return lowerFirst(pascalCase(str || ""));
}
function upperFirst(str) {
  return str ? str[0].toUpperCase() + str.slice(1) : "";
}
function lowerFirst(str) {
  return str ? str[0].toLowerCase() + str.slice(1) : "";
}

// node_modules/svelte-toolbelt/dist/utils/css-to-style-obj.js
function cssToStyleObj(css) {
  if (!css)
    return {};
  const styleObj = {};
  function iterator(name, value) {
    if (name.startsWith("-moz-") || name.startsWith("-webkit-") || name.startsWith("-ms-") || name.startsWith("-o-")) {
      styleObj[pascalCase(name)] = value;
      return;
    }
    if (name.startsWith("--")) {
      styleObj[name] = value;
      return;
    }
    styleObj[camelCase(name)] = value;
  }
  esm_default(css, iterator);
  return styleObj;
}

// node_modules/svelte-toolbelt/dist/utils/execute-callbacks.js
function executeCallbacks(...callbacks) {
  return (...args) => {
    for (const callback of callbacks) {
      if (typeof callback === "function") {
        callback(...args);
      }
    }
  };
}

// node_modules/svelte-toolbelt/dist/utils/style-to-css.js
function createParser(matcher, replacer) {
  const regex = RegExp(matcher, "g");
  return (str) => {
    if (typeof str !== "string") {
      throw new TypeError(`expected an argument of type string, but got ${typeof str}`);
    }
    if (!str.match(regex))
      return str;
    return str.replace(regex, replacer);
  };
}
var camelToKebab = createParser(/[A-Z]/, (match) => `-${match.toLowerCase()}`);
function styleToCSS(styleObj) {
  if (!styleObj || typeof styleObj !== "object" || Array.isArray(styleObj)) {
    throw new TypeError(`expected an argument of type object, but got ${typeof styleObj}`);
  }
  return Object.keys(styleObj).map((property) => `${camelToKebab(property)}: ${styleObj[property]};`).join("\n");
}

// node_modules/svelte-toolbelt/dist/utils/style.js
function styleToString(style = {}) {
  return styleToCSS(style).replace("\n", " ");
}
var srOnlyStyles = {
  position: "absolute",
  width: "1px",
  height: "1px",
  padding: "0",
  margin: "-1px",
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  borderWidth: "0",
  transform: "translateX(-100%)"
};
var srOnlyStylesString = styleToString(srOnlyStyles);

// node_modules/svelte-toolbelt/dist/utils/event-list.js
var EVENT_LIST = [
  "onabort",
  "onanimationcancel",
  "onanimationend",
  "onanimationiteration",
  "onanimationstart",
  "onauxclick",
  "onbeforeinput",
  "onbeforetoggle",
  "onblur",
  "oncancel",
  "oncanplay",
  "oncanplaythrough",
  "onchange",
  "onclick",
  "onclose",
  "oncompositionend",
  "oncompositionstart",
  "oncompositionupdate",
  "oncontextlost",
  "oncontextmenu",
  "oncontextrestored",
  "oncopy",
  "oncuechange",
  "oncut",
  "ondblclick",
  "ondrag",
  "ondragend",
  "ondragenter",
  "ondragleave",
  "ondragover",
  "ondragstart",
  "ondrop",
  "ondurationchange",
  "onemptied",
  "onended",
  "onerror",
  "onfocus",
  "onfocusin",
  "onfocusout",
  "onformdata",
  "ongotpointercapture",
  "oninput",
  "oninvalid",
  "onkeydown",
  "onkeypress",
  "onkeyup",
  "onload",
  "onloadeddata",
  "onloadedmetadata",
  "onloadstart",
  "onlostpointercapture",
  "onmousedown",
  "onmouseenter",
  "onmouseleave",
  "onmousemove",
  "onmouseout",
  "onmouseover",
  "onmouseup",
  "onpaste",
  "onpause",
  "onplay",
  "onplaying",
  "onpointercancel",
  "onpointerdown",
  "onpointerenter",
  "onpointerleave",
  "onpointermove",
  "onpointerout",
  "onpointerover",
  "onpointerup",
  "onprogress",
  "onratechange",
  "onreset",
  "onresize",
  "onscroll",
  "onscrollend",
  "onsecuritypolicyviolation",
  "onseeked",
  "onseeking",
  "onselect",
  "onselectionchange",
  "onselectstart",
  "onslotchange",
  "onstalled",
  "onsubmit",
  "onsuspend",
  "ontimeupdate",
  "ontoggle",
  "ontouchcancel",
  "ontouchend",
  "ontouchmove",
  "ontouchstart",
  "ontransitioncancel",
  "ontransitionend",
  "ontransitionrun",
  "ontransitionstart",
  "onvolumechange",
  "onwaiting",
  "onwebkitanimationend",
  "onwebkitanimationiteration",
  "onwebkitanimationstart",
  "onwebkittransitionend",
  "onwheel"
];
var EVENT_LIST_SET = new Set(EVENT_LIST);

// node_modules/svelte-toolbelt/dist/utils/merge-props.js
function isEventHandler(key2) {
  return EVENT_LIST_SET.has(key2);
}
function mergeProps(...args) {
  const result = { ...args[0] };
  for (let i = 1; i < args.length; i++) {
    const props = args[i];
    if (!props)
      continue;
    for (const key2 of Object.keys(props)) {
      const a2 = result[key2];
      const b = props[key2];
      const aIsFunction = typeof a2 === "function";
      const bIsFunction = typeof b === "function";
      if (aIsFunction && typeof bIsFunction && isEventHandler(key2)) {
        const aHandler = a2;
        const bHandler = b;
        result[key2] = composeHandlers(aHandler, bHandler);
      } else if (aIsFunction && bIsFunction) {
        result[key2] = executeCallbacks(a2, b);
      } else if (key2 === "class") {
        const aIsClassValue = isClassValue(a2);
        const bIsClassValue = isClassValue(b);
        if (aIsClassValue && bIsClassValue) {
          result[key2] = clsx(a2, b);
        } else if (aIsClassValue) {
          result[key2] = clsx(a2);
        } else if (bIsClassValue) {
          result[key2] = clsx(b);
        }
      } else if (key2 === "style") {
        const aIsObject = typeof a2 === "object";
        const bIsObject = typeof b === "object";
        const aIsString = typeof a2 === "string";
        const bIsString = typeof b === "string";
        if (aIsObject && bIsObject) {
          result[key2] = { ...a2, ...b };
        } else if (aIsObject && bIsString) {
          const parsedStyle = cssToStyleObj(b);
          result[key2] = { ...a2, ...parsedStyle };
        } else if (aIsString && bIsObject) {
          const parsedStyle = cssToStyleObj(a2);
          result[key2] = { ...parsedStyle, ...b };
        } else if (aIsString && bIsString) {
          const parsedStyleA = cssToStyleObj(a2);
          const parsedStyleB = cssToStyleObj(b);
          result[key2] = { ...parsedStyleA, ...parsedStyleB };
        } else if (aIsObject) {
          result[key2] = a2;
        } else if (bIsObject) {
          result[key2] = b;
        } else if (aIsString) {
          result[key2] = a2;
        } else if (bIsString) {
          result[key2] = b;
        }
      } else {
        result[key2] = b !== void 0 ? b : a2;
      }
    }
    for (const key2 of Object.getOwnPropertySymbols(props)) {
      const a2 = result[key2];
      const b = props[key2];
      result[key2] = b !== void 0 ? b : a2;
    }
  }
  if (typeof result.style === "object") {
    result.style = styleToString(result.style).replaceAll("\n", " ");
  }
  if (result.hidden !== true) {
    result.hidden = void 0;
    delete result.hidden;
  }
  if (result.disabled !== true) {
    result.disabled = void 0;
    delete result.disabled;
  }
  return result;
}

// node_modules/runed/dist/internal/configurable-globals.js
var defaultWindow = true_default && typeof window !== "undefined" ? window : void 0;
var defaultDocument = true_default && typeof window !== "undefined" ? window.document : void 0;
var defaultNavigator = true_default && typeof window !== "undefined" ? window.navigator : void 0;
var defaultLocation = true_default && typeof window !== "undefined" ? window.location : void 0;

// node_modules/runed/dist/internal/utils/dom.js
function getActiveElement(document2) {
  let activeElement2 = document2.activeElement;
  while (activeElement2?.shadowRoot) {
    const node = activeElement2.shadowRoot.activeElement;
    if (node === activeElement2)
      break;
    else
      activeElement2 = node;
  }
  return activeElement2;
}

// node_modules/runed/dist/utilities/active-element/active-element.svelte.js
var ActiveElement = class {
  #document;
  #subscribe;
  constructor(options = {}) {
    const { window: window2 = defaultWindow, document: document2 = window2?.document } = options;
    if (strict_equals(window2, void 0)) return;
    this.#document = document2;
    this.#subscribe = createSubscriber((update) => {
      const cleanupFocusIn = on(window2, "focusin", update);
      const cleanupFocusOut = on(window2, "focusout", update);
      return () => {
        cleanupFocusIn();
        cleanupFocusOut();
      };
    });
  }
  get current() {
    this.#subscribe?.();
    if (!this.#document) return null;
    return getActiveElement(this.#document);
  }
};
var activeElement = new ActiveElement();

// node_modules/runed/dist/internal/utils/is.js
function isFunction2(value) {
  return typeof value === "function";
}

// node_modules/runed/dist/utilities/extract/extract.svelte.js
function extract(value, defaultValue) {
  if (isFunction2(value)) {
    const getter = value;
    const gotten = getter();
    if (strict_equals(gotten, void 0)) return defaultValue;
    return gotten;
  }
  if (strict_equals(value, void 0)) return defaultValue;
  return value;
}

// node_modules/runed/dist/utilities/context/context.js
var Context = class {
  #name;
  #key;
  /**
   * @param name The name of the context.
   * This is used for generating the context key and error messages.
   */
  constructor(name) {
    this.#name = name;
    this.#key = Symbol(name);
  }
  /**
   * The key used to get and set the context.
   *
   * It is not recommended to use this value directly.
   * Instead, use the methods provided by this class.
   */
  get key() {
    return this.#key;
  }
  /**
   * Checks whether this has been set in the context of a parent component.
   *
   * Must be called during component initialisation.
   */
  exists() {
    return hasContext(this.#key);
  }
  /**
   * Retrieves the context that belongs to the closest parent component.
   *
   * Must be called during component initialisation.
   *
   * @throws An error if the context does not exist.
   */
  get() {
    const context = getContext(this.#key);
    if (context === void 0) {
      throw new Error(`Context "${this.#name}" not found`);
    }
    return context;
  }
  /**
   * Retrieves the context that belongs to the closest parent component,
   * or the given fallback value if the context does not exist.
   *
   * Must be called during component initialisation.
   */
  getOr(fallback) {
    const context = getContext(this.#key);
    if (context === void 0) {
      return fallback;
    }
    return context;
  }
  /**
   * Associates the given value with the current component and returns it.
   *
   * Must be called during component initialisation.
   */
  set(context) {
    return setContext(this.#key, context);
  }
};

// node_modules/runed/dist/utilities/use-debounce/use-debounce.svelte.js
function useDebounce(callback, wait) {
  let context = tag(state(null), "context");
  const wait$ = tag(user_derived(() => extract(wait, 250)), "wait$");
  function debounced(...args) {
    if (get(context)) {
      if (get(context).timeout) {
        clearTimeout(get(context).timeout);
      }
    } else {
      let resolve;
      let reject;
      const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      set(context, { timeout: null, runner: null, promise, resolve, reject }, true);
    }
    get(context).runner = async () => {
      if (!get(context)) return;
      const ctx = get(context);
      set(context, null);
      try {
        ctx.resolve((await track_reactivity_loss(callback.apply(this, args)))());
      } catch (error) {
        ctx.reject(error);
      }
    };
    get(context).timeout = setTimeout(get(context).runner, get(wait$));
    return get(context).promise;
  }
  debounced.cancel = async () => {
    if (!get(context) || strict_equals(get(context).timeout, null)) {
      (await track_reactivity_loss(new Promise((resolve) => setTimeout(resolve, 0))))();
      if (!get(context) || strict_equals(get(context).timeout, null)) return;
    }
    clearTimeout(get(context).timeout);
    get(context).reject("Cancelled");
    set(context, null);
  };
  debounced.runScheduledNow = async () => {
    if (!get(context) || !get(context).timeout) {
      (await track_reactivity_loss(new Promise((resolve) => setTimeout(resolve, 0))))();
      if (!get(context) || !get(context).timeout) return;
    }
    clearTimeout(get(context).timeout);
    get(context).timeout = null;
    (await track_reactivity_loss(get(context).runner?.()))();
  };
  Object.defineProperty(debounced, "pending", {
    enumerable: true,
    get() {
      return !!get(context)?.timeout;
    }
  });
  return debounced;
}

// node_modules/runed/dist/utilities/watch/watch.svelte.js
function runEffect(flush, effect) {
  switch (flush) {
    case "post":
      user_effect(effect);
      break;
    case "pre":
      user_pre_effect(effect);
      break;
  }
}
function runWatcher(sources, flush, effect, options = {}) {
  const { lazy = false } = options;
  let active = !lazy;
  let previousValues = Array.isArray(sources) ? [] : void 0;
  runEffect(flush, () => {
    const values = Array.isArray(sources) ? sources.map((source) => source()) : sources();
    if (!active) {
      active = true;
      previousValues = values;
      return;
    }
    const cleanup = untrack(() => effect(values, previousValues));
    previousValues = values;
    return cleanup;
  });
}
function runWatcherOnce(sources, flush, effect) {
  const cleanupRoot = effect_root(() => {
    let stop = false;
    runWatcher(
      sources,
      flush,
      (values, previousValues) => {
        if (stop) {
          cleanupRoot();
          return;
        }
        const cleanup = effect(values, previousValues);
        stop = true;
        return cleanup;
      },
      // Running the effect immediately just once makes no sense at all.
      // That's just `onMount` with extra steps.
      { lazy: true }
    );
  });
  user_effect(() => {
    return cleanupRoot;
  });
}
function watch(sources, effect, options) {
  runWatcher(sources, "post", effect, options);
}
function watchPre(sources, effect, options) {
  runWatcher(sources, "pre", effect, options);
}
watch.pre = watchPre;
function watchOnce(source, effect) {
  runWatcherOnce(source, "post", effect);
}
function watchOncePre(source, effect) {
  runWatcherOnce(source, "pre", effect);
}
watchOnce.pre = watchOncePre;

// node_modules/runed/dist/internal/utils/get.js
function get2(value) {
  if (isFunction2(value)) {
    return value();
  }
  return value;
}

// node_modules/runed/dist/utilities/element-size/element-size.svelte.js
var ElementSize = class {
  // no need to use `$state` here since we are using createSubscriber
  #size = { width: 0, height: 0 };
  #observed = false;
  #options;
  #node;
  #window;
  // we use a derived here to extract the width so that if the width doesn't change we don't get a state update
  // which we would get if we would just use a getter since the version of the subscriber will be changing
  #width = tag(
    user_derived(() => {
      get(this.#subscribe)?.();
      return this.getSize().width;
    }),
    "ElementSize.#width"
  );
  // we use a derived here to extract the height so that if the height doesn't change we don't get a state update
  // which we would get if we would just use a getter since the version of the subscriber will be changing
  #height = tag(
    user_derived(() => {
      get(this.#subscribe)?.();
      return this.getSize().height;
    }),
    "ElementSize.#height"
  );
  // we need to use a derived here because the class will be created before the node is bound to the ref
  #subscribe = tag(
    user_derived(() => {
      const node$ = get2(this.#node);
      if (!node$) return;
      return createSubscriber((update) => {
        if (!this.#window) return;
        const observer = new this.#window.ResizeObserver((entries) => {
          this.#observed = true;
          for (const entry of entries) {
            const boxSize = strict_equals(this.#options.box, "content-box") ? entry.contentBoxSize : entry.borderBoxSize;
            const boxSizeArr = Array.isArray(boxSize) ? boxSize : [boxSize];
            this.#size.width = boxSizeArr.reduce((acc, size2) => Math.max(acc, size2.inlineSize), 0);
            this.#size.height = boxSizeArr.reduce((acc, size2) => Math.max(acc, size2.blockSize), 0);
          }
          update();
        });
        observer.observe(node$);
        return () => {
          this.#observed = false;
          observer.disconnect();
        };
      });
    }),
    "ElementSize.#subscribe"
  );
  constructor(node, options = { box: "border-box" }) {
    this.#window = options.window ?? defaultWindow;
    this.#options = options;
    this.#node = node;
    this.#size = { width: 0, height: 0 };
  }
  calculateSize() {
    const element2 = get2(this.#node);
    if (!element2 || !this.#window) {
      return;
    }
    const offsetWidth = element2.offsetWidth;
    const offsetHeight = element2.offsetHeight;
    if (strict_equals(this.#options.box, "border-box")) {
      return { width: offsetWidth, height: offsetHeight };
    }
    const style = this.#window.getComputedStyle(element2);
    const paddingWidth = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
    const paddingHeight = parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
    const borderWidth = parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth);
    const borderHeight = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
    const contentWidth = offsetWidth - paddingWidth - borderWidth;
    const contentHeight = offsetHeight - paddingHeight - borderHeight;
    return { width: contentWidth, height: contentHeight };
  }
  getSize() {
    return this.#observed ? this.#size : this.calculateSize() ?? this.#size;
  }
  get current() {
    get(this.#subscribe)?.();
    return this.getSize();
  }
  get width() {
    return get(this.#width);
  }
  get height() {
    return get(this.#height);
  }
};

// node_modules/runed/dist/utilities/is-mounted/is-mounted.svelte.js
var IsMounted = class {
  #isMounted = tag(state(false), "IsMounted.#isMounted");
  constructor() {
    user_effect(() => {
      untrack(() => set(this.#isMounted, true));
      return () => {
        set(this.#isMounted, false);
      };
    });
  }
  get current() {
    return get(this.#isMounted);
  }
};

// node_modules/runed/dist/utilities/previous/previous.svelte.js
var Previous = class {
  #previous = tag(state(void 0), "Previous.#previous");
  constructor(getter, initialValue) {
    if (strict_equals(initialValue, void 0, false)) set(this.#previous, initialValue, true);
    watch(() => getter(), (_, v) => {
      set(this.#previous, v, true);
    });
  }
  get current() {
    return get(this.#previous);
  }
};

// node_modules/runed/dist/utilities/resource/resource.svelte.js
function debounce(fn, delay) {
  let timeoutId;
  let lastResolve = null;
  return (...args) => {
    return new Promise((resolve) => {
      if (lastResolve) {
        lastResolve(void 0);
      }
      lastResolve = resolve;
      clearTimeout(timeoutId);
      timeoutId = setTimeout(
        async () => {
          const result = (await track_reactivity_loss(fn(...args)))();
          if (lastResolve) {
            lastResolve(result);
            lastResolve = null;
          }
        },
        delay
      );
    });
  };
}
function throttle(fn, delay) {
  let lastRun = 0;
  let lastPromise = null;
  return (...args) => {
    const now = Date.now();
    if (lastRun && now - lastRun < delay) {
      return lastPromise ?? Promise.resolve(void 0);
    }
    lastRun = now;
    lastPromise = fn(...args);
    return lastPromise;
  };
}
function runResource(source, fetcher, options = {}, effectFn) {
  const {
    lazy = false,
    once = false,
    initialValue,
    debounce: debounceTime,
    throttle: throttleTime
  } = options;
  let current = tag(state(proxy(initialValue)), "current");
  let loading = tag(state(false), "loading");
  let error = tag(state(void 0), "error");
  let cleanupFns = tag(state(proxy([])), "cleanupFns");
  const runCleanup = () => {
    get(cleanupFns).forEach((fn) => fn());
    set(cleanupFns, [], true);
  };
  const onCleanup = (fn) => {
    set(cleanupFns, [...get(cleanupFns), fn], true);
  };
  const baseFetcher = async (value, previousValue, refetching = false) => {
    try {
      set(loading, true);
      set(error, void 0);
      runCleanup();
      const controller = new AbortController();
      onCleanup(() => controller.abort());
      const result = (await track_reactivity_loss(fetcher(value, previousValue, {
        data: get(current),
        refetching,
        onCleanup,
        signal: controller.signal
      })))();
      set(current, result, true);
      return result;
    } catch (e) {
      if (!(e instanceof DOMException && strict_equals(e.name, "AbortError"))) {
        set(error, e, true);
      }
      return void 0;
    } finally {
      set(loading, false);
    }
  };
  const runFetcher = debounceTime ? debounce(baseFetcher, debounceTime) : throttleTime ? throttle(baseFetcher, throttleTime) : baseFetcher;
  const sources = Array.isArray(source) ? source : [source];
  let prevValues;
  effectFn(
    (values, previousValues) => {
      if (once && prevValues) {
        return;
      }
      prevValues = values;
      runFetcher(Array.isArray(source) ? values : values[0], Array.isArray(source) ? previousValues : previousValues?.[0]);
    },
    { lazy }
  );
  return {
    get current() {
      return get(current);
    },
    get loading() {
      return get(loading);
    },
    get error() {
      return get(error);
    },
    mutate: (value) => {
      set(current, value, true);
    },
    refetch: (info) => {
      const values = sources.map((s) => s());
      return runFetcher(Array.isArray(source) ? values : values[0], Array.isArray(source) ? values : values[0], info ?? true);
    }
  };
}
function resource(source, fetcher, options) {
  return runResource(source, fetcher, options, (fn, options2) => {
    const sources = Array.isArray(source) ? source : [source];
    const getters = () => sources.map((s) => s());
    watch(
      getters,
      (values, previousValues) => {
        fn(values, previousValues ?? []);
      },
      options2
    );
  });
}
function resourcePre(source, fetcher, options) {
  return runResource(source, fetcher, options, (fn, options2) => {
    const sources = Array.isArray(source) ? source : [source];
    const getter = () => sources.map((s) => s());
    watch.pre(
      getter,
      (values, previousValues) => {
        fn(values, previousValues ?? []);
      },
      options2
    );
  });
}
resource.pre = resourcePre;

// node_modules/svelte-toolbelt/dist/utils/on-destroy-effect.svelte.js
function onDestroyEffect(fn) {
  user_effect(() => {
    return () => {
      fn();
    };
  });
}

// node_modules/svelte-toolbelt/dist/utils/after-sleep.js
function afterSleep(ms, cb) {
  return setTimeout(cb, ms);
}

// node_modules/svelte-toolbelt/dist/utils/after-tick.js
function afterTick(fn) {
  tick().then(fn);
}

// node_modules/svelte-toolbelt/dist/utils/on-mount-effect.svelte.js
function onMountEffect(fn) {
  user_effect(() => {
    const cleanup = untrack(() => fn());
    return cleanup;
  });
}

// node_modules/svelte-toolbelt/dist/utils/dom.js
var ELEMENT_NODE = 1;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;
function isHTMLElement(node) {
  return isObject(node) && node.nodeType === ELEMENT_NODE && typeof node.nodeName === "string";
}
function isDocument(node) {
  return isObject(node) && node.nodeType === DOCUMENT_NODE;
}
function isWindow(node) {
  return isObject(node) && node.constructor?.name === "VisualViewport";
}
function isNode(node) {
  return isObject(node) && node.nodeType !== void 0;
}
function isShadowRoot(node) {
  return isNode(node) && node.nodeType === DOCUMENT_FRAGMENT_NODE && "host" in node;
}
function contains(parent, child2) {
  if (!parent || !child2)
    return false;
  if (!isHTMLElement(parent) || !isHTMLElement(child2))
    return false;
  const rootNode = child2.getRootNode?.();
  if (parent === child2)
    return true;
  if (parent.contains(child2))
    return true;
  if (rootNode && isShadowRoot(rootNode)) {
    let next3 = child2;
    while (next3) {
      if (parent === next3)
        return true;
      next3 = next3.parentNode || next3.host;
    }
  }
  return false;
}
function getDocument(node) {
  if (isDocument(node))
    return node;
  if (isWindow(node))
    return node.document;
  return node?.ownerDocument ?? document;
}
function getWindow(node) {
  if (isShadowRoot(node))
    return getWindow(node.host);
  if (isDocument(node))
    return node.defaultView ?? window;
  if (isHTMLElement(node))
    return node.ownerDocument?.defaultView ?? window;
  return window;
}
function getActiveElement2(rootNode) {
  let activeElement2 = rootNode.activeElement;
  while (activeElement2?.shadowRoot) {
    const el = activeElement2.shadowRoot.activeElement;
    if (el === activeElement2)
      break;
    else
      activeElement2 = el;
  }
  return activeElement2;
}

// node_modules/svelte-toolbelt/dist/utils/dom-context.svelte.js
var DOMContext = class {
  element;
  #root = tag(
    user_derived(() => {
      if (!this.element.current) return document;
      const rootNode = this.element.current.getRootNode() ?? document;
      return rootNode;
    }),
    "DOMContext.root"
  );
  get root() {
    return get(this.#root);
  }
  set root(value) {
    set(this.#root, value);
  }
  constructor(element2) {
    if (strict_equals(typeof element2, "function")) {
      this.element = box.with(element2);
    } else {
      this.element = element2;
    }
  }
  getDocument = () => {
    return getDocument(this.root);
  };
  getWindow = () => {
    return this.getDocument().defaultView ?? window;
  };
  getActiveElement = () => {
    return getActiveElement2(this.root);
  };
  isActiveElement = (node) => {
    return strict_equals(node, this.getActiveElement());
  };
  getElementById(id) {
    return this.root.getElementById(id);
  }
  querySelector = (selector) => {
    if (!this.root) return null;
    return this.root.querySelector(selector);
  };
  querySelectorAll = (selector) => {
    if (!this.root) return [];
    return this.root.querySelectorAll(selector);
  };
  setTimeout = (callback, delay) => {
    return this.getWindow().setTimeout(callback, delay);
  };
  clearTimeout = (timeoutId) => {
    return this.getWindow().clearTimeout(timeoutId);
  };
};

// node_modules/svelte-toolbelt/dist/utils/attach-ref.js
function attachRef(ref, onChange) {
  return {
    [createAttachmentKey()]: (node) => {
      if (box.isBox(ref)) {
        ref.current = node;
        untrack(() => onChange?.(node));
        return () => {
          if ("isConnected" in node && node.isConnected)
            return;
          ref.current = null;
          onChange?.(null);
        };
      }
      ref(node);
      untrack(() => onChange?.(node));
      return () => {
        if ("isConnected" in node && node.isConnected)
          return;
        ref(null);
        onChange?.(null);
      };
    }
  };
}

// node_modules/bits-ui/dist/internal/attrs.js
function getDataOpenClosed(condition) {
  return condition ? "open" : "closed";
}
function getDataChecked(condition) {
  return condition ? "checked" : "unchecked";
}
function getAriaDisabled(condition) {
  return condition ? "true" : "false";
}
function getAriaReadonly(condition) {
  return condition ? "true" : "false";
}
function getAriaExpanded(condition) {
  return condition ? "true" : "false";
}
function getDataDisabled(condition) {
  return condition ? "" : void 0;
}
function getAriaRequired(condition) {
  return condition ? "true" : "false";
}
function getAriaSelected(condition) {
  return condition ? "true" : "false";
}
function getAriaChecked(checked, indeterminate) {
  if (indeterminate) {
    return "mixed";
  }
  return checked ? "true" : "false";
}
function getAriaOrientation(orientation) {
  return orientation;
}
function getAriaHidden(condition) {
  return condition ? "true" : void 0;
}
function getAriaInvalid(condition) {
  return condition ? "true" : void 0;
}
function getDataOrientation(orientation) {
  return orientation;
}
function getDataInvalid(condition) {
  return condition ? "" : void 0;
}
function getDataRequired(condition) {
  return condition ? "" : void 0;
}
function getDataReadonly(condition) {
  return condition ? "" : void 0;
}
function getDataSelected(condition) {
  return condition ? "" : void 0;
}
function getDataUnavailable(condition) {
  return condition ? "" : void 0;
}
function getHidden(condition) {
  return condition ? true : void 0;
}
function getDisabled(condition) {
  return condition ? true : void 0;
}
function getAriaPressed(condition) {
  return condition ? "true" : "false";
}
function getRequired(condition) {
  return condition ? true : void 0;
}
var BitsAttrs = class {
  #variant;
  #prefix;
  attrs;
  constructor(config) {
    this.#variant = config.getVariant ? config.getVariant() : null;
    this.#prefix = this.#variant ? `data-${this.#variant}-` : `data-${config.component}-`;
    this.getAttr = this.getAttr.bind(this);
    this.selector = this.selector.bind(this);
    this.attrs = Object.fromEntries(config.parts.map((part) => [part, this.getAttr(part)]));
  }
  getAttr(part, variantOverride) {
    if (variantOverride)
      return `data-${variantOverride}-${part}`;
    return `${this.#prefix}${part}`;
  }
  selector(part, variantOverride) {
    return `[${this.getAttr(part, variantOverride)}]`;
  }
};
function createBitsAttrs(config) {
  const bitsAttrs = new BitsAttrs(config);
  return {
    ...bitsAttrs.attrs,
    selector: bitsAttrs.selector,
    getAttr: bitsAttrs.getAttr
  };
}

// node_modules/bits-ui/dist/internal/kbd-constants.js
var kbd_constants_exports = {};
__export(kbd_constants_exports, {
  A: () => A,
  ALT: () => ALT,
  ARROW_DOWN: () => ARROW_DOWN,
  ARROW_LEFT: () => ARROW_LEFT,
  ARROW_RIGHT: () => ARROW_RIGHT,
  ARROW_UP: () => ARROW_UP,
  ASTERISK: () => ASTERISK,
  BACKSPACE: () => BACKSPACE,
  CAPS_LOCK: () => CAPS_LOCK,
  CONTROL: () => CONTROL,
  CTRL: () => CTRL,
  DELETE: () => DELETE,
  END: () => END,
  ENTER: () => ENTER,
  ESCAPE: () => ESCAPE,
  F1: () => F1,
  F10: () => F10,
  F11: () => F11,
  F12: () => F12,
  F2: () => F2,
  F3: () => F3,
  F4: () => F4,
  F5: () => F5,
  F6: () => F6,
  F7: () => F7,
  F8: () => F8,
  F9: () => F9,
  HOME: () => HOME,
  META: () => META,
  P: () => P,
  PAGE_DOWN: () => PAGE_DOWN,
  PAGE_UP: () => PAGE_UP,
  SHIFT: () => SHIFT,
  SPACE: () => SPACE,
  TAB: () => TAB,
  a: () => a,
  h: () => h,
  j: () => j,
  k: () => k,
  l: () => l,
  n: () => n,
  p: () => p
});
var ALT = "Alt";
var ARROW_DOWN = "ArrowDown";
var ARROW_LEFT = "ArrowLeft";
var ARROW_RIGHT = "ArrowRight";
var ARROW_UP = "ArrowUp";
var BACKSPACE = "Backspace";
var CAPS_LOCK = "CapsLock";
var CONTROL = "Control";
var DELETE = "Delete";
var END = "End";
var ENTER = "Enter";
var ESCAPE = "Escape";
var F1 = "F1";
var F10 = "F10";
var F11 = "F11";
var F12 = "F12";
var F2 = "F2";
var F3 = "F3";
var F4 = "F4";
var F5 = "F5";
var F6 = "F6";
var F7 = "F7";
var F8 = "F8";
var F9 = "F9";
var HOME = "Home";
var META = "Meta";
var PAGE_DOWN = "PageDown";
var PAGE_UP = "PageUp";
var SHIFT = "Shift";
var SPACE = " ";
var TAB = "Tab";
var CTRL = "Control";
var ASTERISK = "*";
var a = "a";
var P = "P";
var A = "A";
var p = "p";
var n = "n";
var j = "j";
var k = "k";
var h = "h";
var l = "l";

// node_modules/bits-ui/dist/internal/locale.js
function getElemDirection(elem) {
  const style = window.getComputedStyle(elem);
  const direction = style.getPropertyValue("direction");
  return direction;
}

// node_modules/bits-ui/dist/internal/get-directional-keys.js
var FIRST_KEYS = [kbd_constants_exports.ARROW_DOWN, kbd_constants_exports.PAGE_UP, kbd_constants_exports.HOME];
var LAST_KEYS = [kbd_constants_exports.ARROW_UP, kbd_constants_exports.PAGE_DOWN, kbd_constants_exports.END];
var FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
var SELECTION_KEYS = [kbd_constants_exports.SPACE, kbd_constants_exports.ENTER];
function getNextKey(dir = "ltr", orientation = "horizontal") {
  return {
    horizontal: dir === "rtl" ? kbd_constants_exports.ARROW_LEFT : kbd_constants_exports.ARROW_RIGHT,
    vertical: kbd_constants_exports.ARROW_DOWN
  }[orientation];
}
function getPrevKey(dir = "ltr", orientation = "horizontal") {
  return {
    horizontal: dir === "rtl" ? kbd_constants_exports.ARROW_RIGHT : kbd_constants_exports.ARROW_LEFT,
    vertical: kbd_constants_exports.ARROW_UP
  }[orientation];
}
function getDirectionalKeys(dir = "ltr", orientation = "horizontal") {
  if (!["ltr", "rtl"].includes(dir))
    dir = "ltr";
  if (!["horizontal", "vertical"].includes(orientation))
    orientation = "horizontal";
  return {
    nextKey: getNextKey(dir, orientation),
    prevKey: getPrevKey(dir, orientation)
  };
}

// node_modules/bits-ui/dist/internal/roving-focus-group.js
var RovingFocusGroup = class {
  #opts;
  #currentTabStopId = box(null);
  constructor(opts) {
    this.#opts = opts;
  }
  getCandidateNodes() {
    if (!true_default || !this.#opts.rootNode.current)
      return [];
    if (this.#opts.candidateSelector) {
      const candidates = Array.from(this.#opts.rootNode.current.querySelectorAll(this.#opts.candidateSelector));
      return candidates;
    } else if (this.#opts.candidateAttr) {
      const candidates = Array.from(this.#opts.rootNode.current.querySelectorAll(`[${this.#opts.candidateAttr}]:not([data-disabled])`));
      return candidates;
    }
    return [];
  }
  focusFirstCandidate() {
    const items = this.getCandidateNodes();
    if (!items.length)
      return;
    items[0]?.focus();
  }
  handleKeydown(node, e, both = false) {
    const rootNode = this.#opts.rootNode.current;
    if (!rootNode || !node)
      return;
    const items = this.getCandidateNodes();
    if (!items.length)
      return;
    const currentIndex = items.indexOf(node);
    const dir = getElemDirection(rootNode);
    const { nextKey, prevKey } = getDirectionalKeys(dir, this.#opts.orientation.current);
    const loop = this.#opts.loop.current;
    const keyToIndex = {
      [nextKey]: currentIndex + 1,
      [prevKey]: currentIndex - 1,
      [kbd_constants_exports.HOME]: 0,
      [kbd_constants_exports.END]: items.length - 1
    };
    if (both) {
      const altNextKey = nextKey === kbd_constants_exports.ARROW_DOWN ? kbd_constants_exports.ARROW_RIGHT : kbd_constants_exports.ARROW_DOWN;
      const altPrevKey = prevKey === kbd_constants_exports.ARROW_UP ? kbd_constants_exports.ARROW_LEFT : kbd_constants_exports.ARROW_UP;
      keyToIndex[altNextKey] = currentIndex + 1;
      keyToIndex[altPrevKey] = currentIndex - 1;
    }
    let itemIndex = keyToIndex[e.key];
    if (itemIndex === void 0)
      return;
    e.preventDefault();
    if (itemIndex < 0 && loop) {
      itemIndex = items.length - 1;
    } else if (itemIndex === items.length && loop) {
      itemIndex = 0;
    }
    const itemToFocus = items[itemIndex];
    if (!itemToFocus)
      return;
    itemToFocus.focus();
    this.#currentTabStopId.current = itemToFocus.id;
    this.#opts.onCandidateFocus?.(itemToFocus);
    return itemToFocus;
  }
  getTabIndex(node) {
    const items = this.getCandidateNodes();
    const anyActive = this.#currentTabStopId.current !== null;
    if (node && !anyActive && items[0] === node) {
      this.#currentTabStopId.current = node.id;
      return 0;
    } else if (node?.id === this.#currentTabStopId.current) {
      return 0;
    }
    return -1;
  }
  setCurrentTabStopId(id) {
    this.#currentTabStopId.current = id;
  }
};

// node_modules/bits-ui/dist/bits/accordion/accordion.svelte.js
var accordionAttrs = createBitsAttrs({
  component: "accordion",
  parts: ["root", "trigger", "content", "item", "header"]
});
var AccordionRootContext = new Context("Accordion.Root");
var AccordionItemContext = new Context("Accordion.Item");
var AccordionBaseState = class {
  opts;
  rovingFocusGroup;
  attachment;
  constructor(opts) {
    this.opts = opts;
    this.rovingFocusGroup = new RovingFocusGroup({
      rootNode: this.opts.ref,
      candidateAttr: accordionAttrs.trigger,
      loop: this.opts.loop,
      orientation: this.opts.orientation
    });
    this.attachment = attachRef(this.opts.ref);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "data-orientation": getDataOrientation(this.opts.orientation.current),
      "data-disabled": getDataDisabled(this.opts.disabled.current),
      [accordionAttrs.root]: "",
      ...this.attachment
    })),
    "AccordionBaseState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var AccordionSingleState = class extends AccordionBaseState {
  opts;
  isMulti = false;
  constructor(opts) {
    super(opts);
    this.opts = opts;
    this.includesItem = this.includesItem.bind(this);
    this.toggleItem = this.toggleItem.bind(this);
  }
  includesItem(item) {
    return strict_equals(this.opts.value.current, item);
  }
  toggleItem(item) {
    this.opts.value.current = this.includesItem(item) ? "" : item;
  }
};
var AccordionMultiState = class extends AccordionBaseState {
  #value;
  isMulti = true;
  constructor(props) {
    super(props);
    this.#value = props.value;
    this.includesItem = this.includesItem.bind(this);
    this.toggleItem = this.toggleItem.bind(this);
  }
  includesItem(item) {
    return this.#value.current.includes(item);
  }
  toggleItem(item) {
    this.#value.current = this.includesItem(item) ? this.#value.current.filter((v) => strict_equals(v, item, false)) : [...this.#value.current, item];
  }
};
var AccordionRootState = class {
  static create(props) {
    const { type, ...rest } = props;
    const rootState = strict_equals(type, "single") ? new AccordionSingleState(rest) : new AccordionMultiState(rest);
    return AccordionRootContext.set(rootState);
  }
};
var AccordionItemState = class _AccordionItemState {
  static create(props) {
    return AccordionItemContext.set(new _AccordionItemState({ ...props, rootState: AccordionRootContext.get() }));
  }
  opts;
  root;
  #isActive = tag(user_derived(() => this.root.includesItem(this.opts.value.current)), "AccordionItemState.isActive");
  get isActive() {
    return get(this.#isActive);
  }
  set isActive(value) {
    set(this.#isActive, value);
  }
  #isDisabled = tag(user_derived(() => this.opts.disabled.current || this.root.opts.disabled.current), "AccordionItemState.isDisabled");
  get isDisabled() {
    return get(this.#isDisabled);
  }
  set isDisabled(value) {
    set(this.#isDisabled, value);
  }
  attachment;
  constructor(opts) {
    this.opts = opts;
    this.root = opts.rootState;
    this.updateValue = this.updateValue.bind(this);
    this.attachment = attachRef(this.opts.ref);
  }
  updateValue() {
    this.root.toggleItem(this.opts.value.current);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "data-state": getDataOpenClosed(this.isActive),
      "data-disabled": getDataDisabled(this.isDisabled),
      "data-orientation": getDataOrientation(this.root.opts.orientation.current),
      [accordionAttrs.item]: "",
      ...this.attachment
    })),
    "AccordionItemState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var AccordionTriggerState = class _AccordionTriggerState {
  opts;
  itemState;
  #root;
  #isDisabled = tag(user_derived(() => this.opts.disabled.current || this.itemState.opts.disabled.current || this.#root.opts.disabled.current), "AccordionTriggerState.#isDisabled");
  attachment;
  constructor(opts, itemState) {
    this.opts = opts;
    this.itemState = itemState;
    this.#root = itemState.root;
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
    this.attachment = attachRef(this.opts.ref);
  }
  static create(props) {
    return new _AccordionTriggerState(props, AccordionItemContext.get());
  }
  onclick(e) {
    if (get(this.#isDisabled) || strict_equals(e.button, 0, false)) {
      e.preventDefault();
      return;
    }
    this.itemState.updateValue();
  }
  onkeydown(e) {
    if (get(this.#isDisabled)) return;
    if (strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ENTER)) {
      e.preventDefault();
      this.itemState.updateValue();
      return;
    }
    this.#root.rovingFocusGroup.handleKeydown(this.opts.ref.current, e);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      disabled: get(this.#isDisabled),
      "aria-expanded": getAriaExpanded(this.itemState.isActive),
      "aria-disabled": getAriaDisabled(get(this.#isDisabled)),
      "data-disabled": getDataDisabled(get(this.#isDisabled)),
      "data-state": getDataOpenClosed(this.itemState.isActive),
      "data-orientation": getDataOrientation(this.#root.opts.orientation.current),
      [accordionAttrs.trigger]: "",
      tabindex: 0,
      onclick: this.onclick,
      onkeydown: this.onkeydown,
      ...this.attachment
    })),
    "AccordionTriggerState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var AccordionContentState = class _AccordionContentState {
  opts;
  item;
  attachment;
  #originalStyles = void 0;
  #isMountAnimationPrevented = false;
  #dimensions = tag(state(proxy({ width: 0, height: 0 })), "AccordionContentState.#dimensions");
  #open = tag(user_derived(() => this.opts.forceMount.current || this.item.isActive), "AccordionContentState.open");
  get open() {
    return get(this.#open);
  }
  set open(value) {
    set(this.#open, value);
  }
  constructor(opts, item) {
    this.opts = opts;
    this.item = item;
    this.#isMountAnimationPrevented = this.item.isActive;
    this.attachment = attachRef(this.opts.ref);
    user_effect(() => {
      const rAF = requestAnimationFrame(() => {
        this.#isMountAnimationPrevented = false;
      });
      return () => cancelAnimationFrame(rAF);
    });
    watch([() => this.open, () => this.opts.ref.current], this.#updateDimensions);
  }
  static create(props) {
    return new _AccordionContentState(props, AccordionItemContext.get());
  }
  #updateDimensions = ([_, node]) => {
    if (!node) return;
    afterTick(() => {
      const element2 = this.opts.ref.current;
      if (!element2) return;
      this.#originalStyles ??= {
        transitionDuration: element2.style.transitionDuration,
        animationName: element2.style.animationName
      };
      element2.style.transitionDuration = "0s";
      element2.style.animationName = "none";
      const rect = element2.getBoundingClientRect();
      set(this.#dimensions, { width: rect.width, height: rect.height }, true);
      if (!this.#isMountAnimationPrevented && this.#originalStyles) {
        element2.style.transitionDuration = this.#originalStyles.transitionDuration;
        element2.style.animationName = this.#originalStyles.animationName;
      }
    });
  };
  #snippetProps = tag(user_derived(() => ({ open: this.item.isActive })), "AccordionContentState.snippetProps");
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "data-state": getDataOpenClosed(this.item.isActive),
      "data-disabled": getDataDisabled(this.item.isDisabled),
      "data-orientation": getDataOrientation(this.item.root.opts.orientation.current),
      [accordionAttrs.content]: "",
      style: {
        "--bits-accordion-content-height": `${get(this.#dimensions).height}px`,
        "--bits-accordion-content-width": `${get(this.#dimensions).width}px`
      },
      ...this.attachment
    })),
    "AccordionContentState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var AccordionHeaderState = class _AccordionHeaderState {
  opts;
  item;
  attachment;
  constructor(opts, item) {
    this.opts = opts;
    this.item = item;
    this.attachment = attachRef(this.opts.ref);
  }
  static create(props) {
    return new _AccordionHeaderState(props, AccordionItemContext.get());
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "heading",
      "aria-level": this.opts.level.current,
      "data-heading-level": this.opts.level.current,
      "data-state": getDataOpenClosed(this.item.isActive),
      "data-orientation": getDataOrientation(this.item.root.opts.orientation.current),
      [accordionAttrs.header]: "",
      ...this.attachment
    })),
    "AccordionHeaderState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};

// node_modules/bits-ui/dist/internal/noop.js
function noop3() {
}

// node_modules/bits-ui/dist/internal/create-id.js
function createId(prefixOrUid, uid) {
  if (uid === void 0)
    return `bits-${prefixOrUid}`;
  return `bits-${prefixOrUid}-${uid}`;
}

// node_modules/bits-ui/dist/bits/accordion/components/accordion.svelte
Accordion[FILENAME] = "node_modules/bits-ui/dist/bits/accordion/components/accordion.svelte";
var root_2 = add_locations(from_html(`<div><!></div>`), Accordion[FILENAME], [[66, 1]]);
function Accordion($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Accordion);
  let disabled = prop($$props, "disabled", 3, false), value = prop($$props, "value", 15), ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), onValueChange = prop($$props, "onValueChange", 3, noop3), loop = prop($$props, "loop", 3, true), orientation = prop($$props, "orientation", 3, "vertical"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "disabled",
      "children",
      "child",
      "type",
      "value",
      "ref",
      "id",
      "onValueChange",
      "loop",
      "orientation"
    ],
    "restProps"
  );
  function handleDefaultValue() {
    if (strict_equals(value(), void 0, false)) return;
    value(strict_equals($$props.type, "single") ? "" : []);
  }
  handleDefaultValue();
  watch.pre(() => value(), () => {
    handleDefaultValue();
  });
  const rootState = AccordionRootState.create({
    type: $$props.type,
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    id: box.with(() => id()),
    disabled: box.with(() => disabled()),
    loop: box.with(() => loop()),
    orientation: box.with(() => orientation()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Accordion, 64, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Accordion, 67, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Accordion,
      63,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Accordion = hmr(Accordion, () => Accordion[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Accordion[HMR].source;
    set(Accordion[HMR].source, module.default[HMR].original);
  });
}
var accordion_default = Accordion;

// node_modules/bits-ui/dist/bits/accordion/components/accordion-item.svelte
Accordion_item[FILENAME] = "node_modules/bits-ui/dist/bits/accordion/components/accordion-item.svelte";
var root_22 = add_locations(from_html(`<div><!></div>`), Accordion_item[FILENAME], [[36, 1]]);
function Accordion_item($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Accordion_item);
  const defaultId = createId(uid);
  let id = prop($$props, "id", 3, defaultId), disabled = prop($$props, "disabled", 3, false), value = prop($$props, "value", 3, defaultId), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "disabled",
      "value",
      "children",
      "child",
      "ref"
    ],
    "restProps"
  );
  const itemState = AccordionItemState.create({
    value: box.with(() => value()),
    disabled: box.with(() => disabled()),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, itemState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Accordion_item, 34, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_22();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Accordion_item, 37, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Accordion_item,
      33,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Accordion_item = hmr(Accordion_item, () => Accordion_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Accordion_item[HMR].source;
    set(Accordion_item[HMR].source, module.default[HMR].original);
  });
}
var accordion_item_default = Accordion_item;

// node_modules/bits-ui/dist/bits/accordion/components/accordion-header.svelte
Accordion_header[FILENAME] = "node_modules/bits-ui/dist/bits/accordion/components/accordion-header.svelte";
var root_23 = add_locations(from_html(`<div><!></div>`), Accordion_header[FILENAME], [[33, 1]]);
function Accordion_header($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Accordion_header);
  let id = prop($$props, "id", 19, () => createId(uid)), level = prop($$props, "level", 3, 2), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "level",
      "children",
      "child",
      "ref"
    ],
    "restProps"
  );
  const headerState = AccordionHeaderState.create({
    id: box.with(() => id()),
    level: box.with(() => level()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, headerState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Accordion_header, 31, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_23();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Accordion_header, 34, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Accordion_header,
      30,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Accordion_header = hmr(Accordion_header, () => Accordion_header[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Accordion_header[HMR].source;
    set(Accordion_header[HMR].source, module.default[HMR].original);
  });
}
var accordion_header_default = Accordion_header;

// node_modules/bits-ui/dist/bits/accordion/components/accordion-trigger.svelte
Accordion_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/accordion/components/accordion-trigger.svelte";
var root_24 = add_locations(from_html(`<button><!></button>`), Accordion_trigger[FILENAME], [[33, 1]]);
function Accordion_trigger($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Accordion_trigger);
  let disabled = prop($$props, "disabled", 3, false), ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "disabled",
      "ref",
      "id",
      "children",
      "child"
    ],
    "restProps"
  );
  const triggerState = AccordionTriggerState.create({
    disabled: box.with(() => disabled()),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, triggerState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Accordion_trigger, 31, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_24();
      attribute_effect(button, () => ({ type: "button", ...get(mergedProps) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Accordion_trigger, 34, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Accordion_trigger,
      30,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Accordion_trigger = hmr(Accordion_trigger, () => Accordion_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Accordion_trigger[HMR].source;
    set(Accordion_trigger[HMR].source, module.default[HMR].original);
  });
}
var accordion_trigger_default = Accordion_trigger;

// node_modules/bits-ui/dist/internal/state-machine.js
var StateMachine = class {
  state;
  #machine;
  constructor(initialState, machine) {
    this.state = box(initialState);
    this.#machine = machine;
    this.dispatch = this.dispatch.bind(this);
  }
  #reducer(event) {
    const nextState = this.#machine[this.state.current][event];
    return nextState ?? this.state.current;
  }
  dispatch(event) {
    this.state.current = this.#reducer(event);
  }
};

// node_modules/bits-ui/dist/bits/utilities/presence-layer/presence.svelte.js
var presenceMachine = {
  mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" },
  unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" },
  unmounted: { MOUNT: "mounted" }
};
var Presence = class {
  opts;
  #prevAnimationNameState = tag(state("none"), "Presence.prevAnimationNameState");
  get prevAnimationNameState() {
    return get(this.#prevAnimationNameState);
  }
  set prevAnimationNameState(value) {
    set(this.#prevAnimationNameState, value, true);
  }
  #styles = tag(state(proxy({})), "Presence.styles");
  get styles() {
    return get(this.#styles);
  }
  set styles(value) {
    set(this.#styles, value, true);
  }
  initialStatus;
  previousPresent;
  machine;
  present;
  constructor(opts) {
    this.opts = opts;
    this.present = this.opts.open;
    this.initialStatus = opts.open.current ? "mounted" : "unmounted";
    this.previousPresent = new Previous(() => this.present.current);
    this.machine = new StateMachine(this.initialStatus, presenceMachine);
    this.handleAnimationEnd = this.handleAnimationEnd.bind(this);
    this.handleAnimationStart = this.handleAnimationStart.bind(this);
    watchPresenceChange(this);
    watchStatusChange(this);
    watchRefChange(this);
  }
  /**
   * Triggering an ANIMATION_OUT during an ANIMATION_IN will fire an `animationcancel`
   * event for ANIMATION_IN after we have entered `unmountSuspended` state. So, we
   * make sure we only trigger ANIMATION_END for the currently active animation.
   */
  handleAnimationEnd(event) {
    if (!this.opts.ref.current) return;
    const currAnimationName = getAnimationName(this.opts.ref.current);
    const isCurrentAnimation = currAnimationName.includes(event.animationName) || strict_equals(currAnimationName, "none");
    if (strict_equals(event.target, this.opts.ref.current) && isCurrentAnimation) {
      this.machine.dispatch("ANIMATION_END");
    }
  }
  handleAnimationStart(event) {
    if (!this.opts.ref.current) return;
    if (strict_equals(event.target, this.opts.ref.current)) {
      this.prevAnimationNameState = getAnimationName(this.opts.ref.current);
    }
  }
  #isPresent = tag(
    user_derived(() => {
      return ["mounted", "unmountSuspended"].includes(this.machine.state.current);
    }),
    "Presence.isPresent"
  );
  get isPresent() {
    return get(this.#isPresent);
  }
  set isPresent(value) {
    set(this.#isPresent, value);
  }
};
function watchPresenceChange(state2) {
  watch(() => state2.present.current, () => {
    if (!state2.opts.ref.current) return;
    const hasPresentChanged = strict_equals(state2.present.current, state2.previousPresent.current, false);
    if (!hasPresentChanged) return;
    const prevAnimationName = state2.prevAnimationNameState;
    const currAnimationName = getAnimationName(state2.opts.ref.current);
    if (state2.present.current) {
      state2.machine.dispatch("MOUNT");
    } else if (strict_equals(currAnimationName, "none") || strict_equals(state2.styles.display, "none")) {
      state2.machine.dispatch("UNMOUNT");
    } else {
      const isAnimating = strict_equals(prevAnimationName, currAnimationName, false);
      if (state2.previousPresent.current && isAnimating) {
        state2.machine.dispatch("ANIMATION_OUT");
      } else {
        state2.machine.dispatch("UNMOUNT");
      }
    }
  });
}
function watchStatusChange(state2) {
  watch(() => state2.machine.state.current, () => {
    if (!state2.opts.ref.current) return;
    const currAnimationName = getAnimationName(state2.opts.ref.current);
    state2.prevAnimationNameState = strict_equals(state2.machine.state.current, "mounted") ? currAnimationName : "none";
  });
}
function watchRefChange(state2) {
  watch(() => state2.opts.ref.current, () => {
    if (!state2.opts.ref.current) return;
    state2.styles = getComputedStyle(state2.opts.ref.current);
    return executeCallbacks(on(state2.opts.ref.current, "animationstart", state2.handleAnimationStart), on(state2.opts.ref.current, "animationcancel", state2.handleAnimationEnd), on(state2.opts.ref.current, "animationend", state2.handleAnimationEnd));
  });
}
function getAnimationName(node) {
  return node ? getComputedStyle(node).animationName || "none" : "none";
}

// node_modules/bits-ui/dist/bits/utilities/presence-layer/presence-layer.svelte
Presence_layer[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/presence-layer/presence-layer.svelte";
function Presence_layer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Presence_layer);
  const presenceState = new Presence({ open: box.with(() => $$props.open), ref: $$props.ref });
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.presence ?? noop, () => ({ present: presenceState.isPresent })), "render", Presence_layer, 15, 1);
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.forceMount || $$props.open || presenceState.isPresent) $$render(consequent);
      }),
      "if",
      Presence_layer,
      14,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Presence_layer = hmr(Presence_layer, () => Presence_layer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Presence_layer[HMR].source;
    set(Presence_layer[HMR].source, module.default[HMR].original);
  });
}
var presence_layer_default = Presence_layer;

// node_modules/bits-ui/dist/bits/accordion/components/accordion-content.svelte
Accordion_content[FILENAME] = "node_modules/bits-ui/dist/bits/accordion/components/accordion-content.svelte";
var root_3 = add_locations(from_html(`<div><!></div>`), Accordion_content[FILENAME], [[40, 3]]);
function Accordion_content($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Accordion_content);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "ref",
      "id",
      "forceMount",
      "children"
    ],
    "restProps"
  );
  const contentState = AccordionContentState.create({
    forceMount: box.with(() => forceMount()),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    const presence = wrap_snippet(Accordion_content, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let present = () => $$arg0?.().present;
      present();
      var fragment_1 = comment();
      const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props, { hidden: forceMount() ? void 0 : !present() })), "mergedProps");
      get(mergedProps);
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          {
            let $0 = user_derived(() => ({ props: get(mergedProps), ...contentState.snippetProps }));
            add_svelte_meta(() => snippet(node_2, () => $$props.child, () => get($0)), "render", Accordion_content, 35, 3);
          }
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var div = root_3();
          attribute_effect(div, () => ({ ...get(mergedProps) }));
          var node_3 = child(div);
          add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop), "render", Accordion_content, 41, 4);
          reset(div);
          append($$anchor3, div);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if ($$props.child) $$render(consequent);
            else $$render(alternate, false);
          }),
          "if",
          Accordion_content,
          34,
          2
        );
      }
      append($$anchor2, fragment_1);
    });
    add_svelte_meta(
      () => presence_layer_default(node, {
        forceMount: true,
        get open() {
          return contentState.open;
        },
        get ref() {
          return contentState.opts.ref;
        },
        presence,
        $$slots: { presence: true }
      }),
      "component",
      Accordion_content,
      29,
      0,
      { componentTag: "PresenceLayer" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Accordion_content = hmr(Accordion_content, () => Accordion_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Accordion_content[HMR].source;
    set(Accordion_content[HMR].source, module.default[HMR].original);
  });
}
var accordion_content_default = Accordion_content;

// node_modules/bits-ui/dist/bits/alert-dialog/exports.js
var exports_exports2 = {};
__export(exports_exports2, {
  Action: () => alert_dialog_action_default,
  Cancel: () => alert_dialog_cancel_default,
  Content: () => alert_dialog_content_default,
  Description: () => dialog_description_default,
  Overlay: () => dialog_overlay_default,
  Portal: () => portal_default,
  Root: () => alert_dialog_default,
  Title: () => dialog_title_default,
  Trigger: () => dialog_trigger_default
});

// node_modules/bits-ui/dist/internal/animations-complete.js
var AnimationsComplete = class {
  #opts;
  #currentFrame = void 0;
  #isRunning = false;
  constructor(opts) {
    this.#opts = opts;
    onDestroyEffect(() => this.#cleanup());
  }
  #cleanup() {
    if (this.#currentFrame) {
      window.cancelAnimationFrame(this.#currentFrame);
      this.#currentFrame = void 0;
    }
    this.#isRunning = false;
  }
  run(fn) {
    if (this.#isRunning)
      return;
    this.#cleanup();
    this.#isRunning = true;
    const node = this.#opts.ref.current;
    if (!node) {
      this.#isRunning = false;
      return;
    }
    if (typeof node.getAnimations !== "function") {
      this.#executeCallback(fn);
      return;
    }
    this.#currentFrame = window.requestAnimationFrame(() => {
      const animations = node.getAnimations();
      if (animations.length === 0) {
        this.#executeCallback(fn);
        return;
      }
      Promise.allSettled(animations.map((animation) => animation.finished)).then(() => {
        this.#executeCallback(fn);
      });
    });
  }
  #executeCallback(fn) {
    const execute = () => {
      fn();
      this.#isRunning = false;
    };
    if (this.#opts.afterTick) {
      afterTick(execute);
    } else {
      execute();
    }
  }
};

// node_modules/bits-ui/dist/internal/open-change-complete.js
var OpenChangeComplete = class {
  #opts;
  #enabled;
  #afterAnimations;
  constructor(opts) {
    this.#opts = opts;
    this.#enabled = opts.enabled ?? true;
    this.#afterAnimations = new AnimationsComplete({
      ref: this.#opts.ref,
      afterTick: this.#opts.open
    });
    watch([() => this.#opts.open.current], ([open]) => {
      if (!this.#enabled)
        return;
      this.#afterAnimations.run(() => {
        if (open === this.#opts.open.current) {
          this.#opts.onComplete();
        }
      });
    });
  }
};

// node_modules/bits-ui/dist/bits/dialog/dialog.svelte.js
var dialogAttrs = createBitsAttrs({
  component: "dialog",
  parts: [
    "content",
    "trigger",
    "overlay",
    "title",
    "description",
    "close",
    "cancel",
    "action"
  ]
});
var DialogRootContext = new Context("Dialog.Root | AlertDialog.Root");
var DialogRootState = class _DialogRootState {
  static create(opts) {
    return DialogRootContext.set(new _DialogRootState(opts));
  }
  opts;
  #triggerNode = tag(state(null), "DialogRootState.triggerNode");
  get triggerNode() {
    return get(this.#triggerNode);
  }
  set triggerNode(value) {
    set(this.#triggerNode, value, true);
  }
  #contentNode = tag(state(null), "DialogRootState.contentNode");
  get contentNode() {
    return get(this.#contentNode);
  }
  set contentNode(value) {
    set(this.#contentNode, value, true);
  }
  #descriptionNode = tag(state(null), "DialogRootState.descriptionNode");
  get descriptionNode() {
    return get(this.#descriptionNode);
  }
  set descriptionNode(value) {
    set(this.#descriptionNode, value, true);
  }
  #contentId = tag(state(void 0), "DialogRootState.contentId");
  get contentId() {
    return get(this.#contentId);
  }
  set contentId(value) {
    set(this.#contentId, value, true);
  }
  #titleId = tag(state(void 0), "DialogRootState.titleId");
  get titleId() {
    return get(this.#titleId);
  }
  set titleId(value) {
    set(this.#titleId, value, true);
  }
  #triggerId = tag(state(void 0), "DialogRootState.triggerId");
  get triggerId() {
    return get(this.#triggerId);
  }
  set triggerId(value) {
    set(this.#triggerId, value, true);
  }
  #descriptionId = tag(state(void 0), "DialogRootState.descriptionId");
  get descriptionId() {
    return get(this.#descriptionId);
  }
  set descriptionId(value) {
    set(this.#descriptionId, value, true);
  }
  #cancelNode = tag(state(null), "DialogRootState.cancelNode");
  get cancelNode() {
    return get(this.#cancelNode);
  }
  set cancelNode(value) {
    set(this.#cancelNode, value, true);
  }
  constructor(opts) {
    this.opts = opts;
    this.handleOpen = this.handleOpen.bind(this);
    this.handleClose = this.handleClose.bind(this);
    new OpenChangeComplete({
      ref: box.with(() => this.contentNode),
      open: this.opts.open,
      enabled: true,
      onComplete: () => {
        this.opts.onOpenChangeComplete.current(this.opts.open.current);
      }
    });
  }
  handleOpen() {
    if (this.opts.open.current) return;
    this.opts.open.current = true;
  }
  handleClose() {
    if (!this.opts.open.current) return;
    this.opts.open.current = false;
  }
  getBitsAttr = (part) => {
    return dialogAttrs.getAttr(part, this.opts.variant.current);
  };
  #sharedProps = tag(user_derived(() => ({ "data-state": getDataOpenClosed(this.opts.open.current) })), "DialogRootState.sharedProps");
  get sharedProps() {
    return get(this.#sharedProps);
  }
  set sharedProps(value) {
    set(this.#sharedProps, value);
  }
};
var DialogTriggerState = class _DialogTriggerState {
  static create(opts) {
    return new _DialogTriggerState(opts, DialogRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => {
      this.root.triggerNode = v;
      this.root.triggerId = v?.id;
    });
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  onclick(e) {
    if (this.opts.disabled.current) return;
    if (e.button > 0) return;
    this.root.handleOpen();
  }
  onkeydown(e) {
    if (this.opts.disabled.current) return;
    if (strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ENTER)) {
      e.preventDefault();
      this.root.handleOpen();
    }
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "aria-haspopup": "dialog",
      "aria-expanded": getAriaExpanded(this.root.opts.open.current),
      "aria-controls": this.root.contentId,
      [this.root.getBitsAttr("trigger")]: "",
      onkeydown: this.onkeydown,
      onclick: this.onclick,
      disabled: this.opts.disabled.current ? true : void 0,
      ...this.root.sharedProps,
      ...this.attachment
    })),
    "DialogTriggerState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var DialogCloseState = class _DialogCloseState {
  static create(opts) {
    return new _DialogCloseState(opts, DialogRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  onclick(e) {
    if (this.opts.disabled.current) return;
    if (e.button > 0) return;
    this.root.handleClose();
  }
  onkeydown(e) {
    if (this.opts.disabled.current) return;
    if (strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ENTER)) {
      e.preventDefault();
      this.root.handleClose();
    }
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      [this.root.getBitsAttr(this.opts.variant.current)]: "",
      onclick: this.onclick,
      onkeydown: this.onkeydown,
      disabled: this.opts.disabled.current ? true : void 0,
      tabindex: 0,
      ...this.root.sharedProps,
      ...this.attachment
    })),
    "DialogCloseState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var DialogActionState = class _DialogActionState {
  static create(opts) {
    return new _DialogActionState(opts, DialogRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      [this.root.getBitsAttr("action")]: "",
      ...this.root.sharedProps,
      ...this.attachment
    })),
    "DialogActionState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var DialogTitleState = class _DialogTitleState {
  static create(opts) {
    return new _DialogTitleState(opts, DialogRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.root.titleId = this.opts.id.current;
    this.attachment = attachRef(this.opts.ref);
    watch.pre(() => this.opts.id.current, (id) => {
      this.root.titleId = id;
    });
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "heading",
      "aria-level": this.opts.level.current,
      [this.root.getBitsAttr("title")]: "",
      ...this.root.sharedProps,
      ...this.attachment
    })),
    "DialogTitleState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var DialogDescriptionState = class _DialogDescriptionState {
  static create(opts) {
    return new _DialogDescriptionState(opts, DialogRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.root.descriptionId = this.opts.id.current;
    this.attachment = attachRef(this.opts.ref, (v) => {
      this.root.descriptionNode = v;
    });
    watch.pre(() => this.opts.id.current, (id) => {
      this.root.descriptionId = id;
    });
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      [this.root.getBitsAttr("description")]: "",
      ...this.root.sharedProps,
      ...this.attachment
    })),
    "DialogDescriptionState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var DialogContentState = class _DialogContentState {
  static create(opts) {
    return new _DialogContentState(opts, DialogRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => {
      this.root.contentNode = v;
      this.root.contentId = v?.id;
    });
  }
  #snippetProps = tag(user_derived(() => ({ open: this.root.opts.open.current })), "DialogContentState.snippetProps");
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: strict_equals(this.root.opts.variant.current, "alert-dialog") ? "alertdialog" : "dialog",
      "aria-modal": "true",
      "aria-describedby": this.root.descriptionId,
      "aria-labelledby": this.root.titleId,
      [this.root.getBitsAttr("content")]: "",
      style: {
        pointerEvents: "auto",
        outline: strict_equals(this.root.opts.variant.current, "alert-dialog") ? "none" : void 0
      },
      tabindex: strict_equals(this.root.opts.variant.current, "alert-dialog") ? -1 : void 0,
      ...this.root.sharedProps,
      ...this.attachment
    })),
    "DialogContentState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var DialogOverlayState = class _DialogOverlayState {
  static create(opts) {
    return new _DialogOverlayState(opts, DialogRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  #snippetProps = tag(user_derived(() => ({ open: this.root.opts.open.current })), "DialogOverlayState.snippetProps");
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      [this.root.getBitsAttr("overlay")]: "",
      style: { pointerEvents: "auto" },
      ...this.root.sharedProps,
      ...this.attachment
    })),
    "DialogOverlayState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var AlertDialogCancelState = class _AlertDialogCancelState {
  static create(opts) {
    return new _AlertDialogCancelState(opts, DialogRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.cancelNode = v);
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  onclick(e) {
    if (this.opts.disabled.current) return;
    if (e.button > 0) return;
    this.root.handleClose();
  }
  onkeydown(e) {
    if (this.opts.disabled.current) return;
    if (strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ENTER)) {
      e.preventDefault();
      this.root.handleClose();
    }
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      [this.root.getBitsAttr("cancel")]: "",
      onclick: this.onclick,
      onkeydown: this.onkeydown,
      tabindex: 0,
      ...this.root.sharedProps,
      ...this.attachment
    })),
    "AlertDialogCancelState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};

// node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog.svelte
Alert_dialog[FILENAME] = "node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog.svelte";
function Alert_dialog($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Alert_dialog);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3);
  DialogRootState.create({
    variant: box.with(() => "alert-dialog"),
    open: box.with(() => open(), (v) => {
      open(v);
      onOpenChange()(v);
    }),
    onOpenChangeComplete: box.with(() => onOpenChangeComplete())
  });
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop), "render", Alert_dialog, 27, 0);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Alert_dialog = hmr(Alert_dialog, () => Alert_dialog[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Alert_dialog[HMR].source;
    set(Alert_dialog[HMR].source, module.default[HMR].original);
  });
}
var alert_dialog_default = Alert_dialog;

// node_modules/bits-ui/dist/bits/dialog/components/dialog-title.svelte
Dialog_title[FILENAME] = "node_modules/bits-ui/dist/bits/dialog/components/dialog-title.svelte";
var root_25 = add_locations(from_html(`<div><!></div>`), Dialog_title[FILENAME], [[33, 1]]);
function Dialog_title($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Dialog_title);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), level = prop($$props, "level", 3, 2), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "children",
      "level"
    ],
    "restProps"
  );
  const titleState = DialogTitleState.create({
    id: box.with(() => id()),
    level: box.with(() => level()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, titleState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Dialog_title, 31, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_25();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Dialog_title, 34, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Dialog_title,
      30,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dialog_title = hmr(Dialog_title, () => Dialog_title[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dialog_title[HMR].source;
    set(Dialog_title[HMR].source, module.default[HMR].original);
  });
}
var dialog_title_default = Dialog_title;

// node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-action.svelte
Alert_dialog_action[FILENAME] = "node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-action.svelte";
var root_26 = add_locations(from_html(`<button><!></button>`), Alert_dialog_action[FILENAME], [[31, 1]]);
function Alert_dialog_action($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Alert_dialog_action);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref"
    ],
    "restProps"
  );
  const actionState = DialogActionState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, actionState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Alert_dialog_action, 29, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_26();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Alert_dialog_action, 32, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Alert_dialog_action,
      28,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Alert_dialog_action = hmr(Alert_dialog_action, () => Alert_dialog_action[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Alert_dialog_action[HMR].source;
    set(Alert_dialog_action[HMR].source, module.default[HMR].original);
  });
}
var alert_dialog_action_default = Alert_dialog_action;

// node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-cancel.svelte
Alert_dialog_cancel[FILENAME] = "node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-cancel.svelte";
var root_27 = add_locations(from_html(`<button><!></button>`), Alert_dialog_cancel[FILENAME], [[33, 1]]);
function Alert_dialog_cancel($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Alert_dialog_cancel);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child",
      "disabled"
    ],
    "restProps"
  );
  const cancelState = AlertDialogCancelState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => Boolean(disabled()))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, cancelState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Alert_dialog_cancel, 31, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_27();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Alert_dialog_cancel, 34, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Alert_dialog_cancel,
      30,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Alert_dialog_cancel = hmr(Alert_dialog_cancel, () => Alert_dialog_cancel[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Alert_dialog_cancel[HMR].source;
    set(Alert_dialog_cancel[HMR].source, module.default[HMR].original);
  });
}
var alert_dialog_cancel_default = Alert_dialog_cancel;

// node_modules/bits-ui/dist/bits/utilities/portal/portal-consumer.svelte
Portal_consumer[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/portal/portal-consumer.svelte";
function Portal_consumer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Portal_consumer);
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => key(node, () => $$props.children, ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop), "render", Portal_consumer, 8, 1);
      append($$anchor2, fragment_1);
    }),
    "key",
    Portal_consumer,
    7,
    0
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Portal_consumer = hmr(Portal_consumer, () => Portal_consumer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Portal_consumer[HMR].source;
    set(Portal_consumer[HMR].source, module.default[HMR].original);
  });
}
var portal_consumer_default = Portal_consumer;

// node_modules/bits-ui/dist/internal/is.js
var isBrowser = typeof document !== "undefined";
var isIOS = getIsIOS();
function getIsIOS() {
  return isBrowser && window?.navigator?.userAgent && (/iP(ad|hone|od)/.test(window.navigator.userAgent) || // The new iPad Pro Gen3 does not identify itself as iPad, but as Macintosh.
  window?.navigator?.maxTouchPoints > 2 && /iPad|Macintosh/.test(window?.navigator.userAgent));
}
function isHTMLElement2(element2) {
  return element2 instanceof HTMLElement;
}
function isElement2(element2) {
  return element2 instanceof Element;
}
function isElementOrSVGElement(element2) {
  return element2 instanceof Element || element2 instanceof SVGElement;
}
function isNumberString(value) {
  return !Number.isNaN(Number(value)) && !Number.isNaN(Number.parseFloat(value));
}
function isNull(value) {
  return value === null;
}
function isTouch(e) {
  return e.pointerType === "touch";
}
function isFocusVisible(element2) {
  return element2.matches(":focus-visible");
}
function isNotNull(value) {
  return value !== null;
}
function isSelectableInput(element2) {
  return element2 instanceof HTMLInputElement && "select" in element2;
}

// node_modules/bits-ui/dist/bits/utilities/config/bits-config.js
var BitsConfigContext = new Context("BitsConfig");
function getBitsConfig() {
  const fallback = new BitsConfigState(null, {});
  return BitsConfigContext.getOr(fallback).opts;
}
function useBitsConfig(opts) {
  return BitsConfigContext.set(new BitsConfigState(BitsConfigContext.getOr(null), opts));
}
var BitsConfigState = class {
  opts;
  constructor(parent, opts) {
    const resolveConfigOption = createConfigResolver(parent, opts);
    this.opts = {
      defaultPortalTo: resolveConfigOption((config) => config.defaultPortalTo),
      defaultLocale: resolveConfigOption((config) => config.defaultLocale)
    };
  }
};
function createConfigResolver(parent, currentOpts) {
  return (getter) => {
    const configOption = box.with(() => {
      const value = getter(currentOpts)?.current;
      if (value !== void 0)
        return value;
      if (parent === null)
        return void 0;
      return getter(parent.opts)?.current;
    });
    return configOption;
  };
}

// node_modules/bits-ui/dist/bits/utilities/config/prop-resolvers.js
function createPropResolver(configOption, fallback) {
  return (getProp) => {
    const config = getBitsConfig();
    return box.with(() => {
      const propValue = getProp();
      if (propValue !== void 0)
        return propValue;
      const option = configOption(config).current;
      if (option !== void 0)
        return option;
      return fallback;
    });
  };
}
var resolveLocaleProp = createPropResolver((config) => config.defaultLocale, "en");
var resolvePortalToProp = createPropResolver((config) => config.defaultPortalTo, "body");

// node_modules/bits-ui/dist/bits/utilities/portal/portal.svelte
Portal[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/portal/portal.svelte";
function Portal($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Portal);
  const to = resolvePortalToProp(() => $$props.to);
  const context = getAllContexts();
  let target = tag(user_derived(getTarget), "target");
  function getTarget() {
    if (!isBrowser || $$props.disabled) return null;
    let localTarget = null;
    if (strict_equals(typeof to.current, "string")) {
      const target2 = document.querySelector(to.current);
      if (true_default && strict_equals(target2, null)) {
        throw new Error(`Target element "${to.current}" not found.`);
      }
      localTarget = target2;
    } else {
      localTarget = to.current;
    }
    if (true_default && !(localTarget instanceof Element)) {
      const type = strict_equals(localTarget, null) ? "null" : typeof localTarget;
      throw new TypeError(`Unknown portal target type: ${type}. Allowed types: string (query selector) or Element.`);
    }
    return localTarget;
  }
  let instance;
  function unmountInstance() {
    if (instance) {
      unmount(instance);
      instance = null;
    }
  }
  watch([() => get(target), () => $$props.disabled], ([target2, disabled]) => {
    if (!target2 || disabled) {
      unmountInstance();
      return;
    }
    instance = mount(portal_consumer_default, { target: target2, props: { children: $$props.children }, context });
    return () => {
      unmountInstance();
    };
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop), "render", Portal, 69, 1);
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.disabled) $$render(consequent);
      }),
      "if",
      Portal,
      68,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Portal = hmr(Portal, () => Portal[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Portal[HMR].source;
    set(Portal[HMR].source, module.default[HMR].original);
  });
}
var portal_default = Portal;

// node_modules/bits-ui/dist/internal/events.js
function addEventListener(target, event, handler, options) {
  const events = Array.isArray(event) ? event : [event];
  events.forEach((_event) => target.addEventListener(_event, handler, options));
  return () => {
    events.forEach((_event) => target.removeEventListener(_event, handler, options));
  };
}
var CustomEventDispatcher = class {
  eventName;
  options;
  constructor(eventName, options = { bubbles: true, cancelable: true }) {
    this.eventName = eventName;
    this.options = options;
  }
  createEvent(detail) {
    return new CustomEvent(this.eventName, {
      ...this.options,
      detail
    });
  }
  dispatch(element2, detail) {
    const event = this.createEvent(detail);
    element2.dispatchEvent(event);
    return event;
  }
  listen(element2, callback, options) {
    const handler = (event) => {
      callback(event);
    };
    return on(element2, this.eventName, handler, options);
  }
};

// node_modules/bits-ui/dist/internal/debounce.js
function debounce2(fn, wait = 500) {
  let timeout = null;
  const debounced = (...args) => {
    if (timeout !== null) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(() => {
      fn(...args);
    }, wait);
  };
  debounced.destroy = () => {
    if (timeout !== null) {
      clearTimeout(timeout);
      timeout = null;
    }
  };
  return debounced;
}

// node_modules/bits-ui/dist/internal/elements.js
function isOrContainsTarget2(node, target) {
  return node === target || node.contains(target);
}
function getOwnerDocument2(el) {
  return el?.ownerDocument ?? document;
}

// node_modules/bits-ui/dist/internal/dom.js
function getFirstNonCommentChild(element2) {
  if (!element2)
    return null;
  for (const child2 of element2.childNodes) {
    if (child2.nodeType !== Node.COMMENT_NODE) {
      return child2;
    }
  }
  return null;
}
function isClickTrulyOutside(event, contentNode) {
  const { clientX, clientY } = event;
  const rect = contentNode.getBoundingClientRect();
  return clientX < rect.left || clientX > rect.right || clientY < rect.top || clientY > rect.bottom;
}

// node_modules/bits-ui/dist/bits/utilities/dismissible-layer/use-dismissable-layer.svelte.js
globalThis.bitsDismissableLayers ??= /* @__PURE__ */ new Map();
var DismissibleLayerState = class _DismissibleLayerState {
  static create(opts) {
    return new _DismissibleLayerState(opts);
  }
  opts;
  #interactOutsideProp;
  #behaviorType;
  #interceptedEvents = { pointerdown: false };
  #isResponsibleLayer = false;
  #isFocusInsideDOMTree = false;
  #documentObj = void 0;
  #onFocusOutside;
  #unsubClickListener = noop3;
  constructor(opts) {
    this.opts = opts;
    this.#behaviorType = opts.interactOutsideBehavior;
    this.#interactOutsideProp = opts.onInteractOutside;
    this.#onFocusOutside = opts.onFocusOutside;
    user_effect(() => {
      this.#documentObj = getOwnerDocument2(this.opts.ref.current);
    });
    let unsubEvents = noop3;
    const cleanup = () => {
      this.#resetState();
      globalThis.bitsDismissableLayers.delete(this);
      this.#handleInteractOutside.destroy();
      unsubEvents();
    };
    watch([() => this.opts.enabled.current, () => this.opts.ref.current], () => {
      if (!this.opts.enabled.current || !this.opts.ref.current) return;
      afterSleep(1, () => {
        if (!this.opts.ref.current) return;
        globalThis.bitsDismissableLayers.set(this, this.#behaviorType);
        unsubEvents();
        unsubEvents = this.#addEventListeners();
      });
      return cleanup;
    });
    onDestroyEffect(() => {
      this.#resetState.destroy();
      globalThis.bitsDismissableLayers.delete(this);
      this.#handleInteractOutside.destroy();
      this.#unsubClickListener();
      unsubEvents();
    });
  }
  #handleFocus = (event) => {
    if (event.defaultPrevented) return;
    if (!this.opts.ref.current) return;
    afterTick(() => {
      if (!this.opts.ref.current || this.#isTargetWithinLayer(event.target)) return;
      if (event.target && !this.#isFocusInsideDOMTree) {
        this.#onFocusOutside.current?.(event);
      }
    });
  };
  #addEventListeners() {
    return executeCallbacks(
      /**
       * CAPTURE INTERACTION START
       * mark interaction-start event as intercepted.
       * mark responsible layer during interaction start
       * to avoid checking if is responsible layer during interaction end
       * when a new floating element may have been opened.
       */
      on(this.#documentObj, "pointerdown", executeCallbacks(this.#markInterceptedEvent, this.#markResponsibleLayer), { capture: true }),
      /**
       * BUBBLE INTERACTION START
       * Mark interaction-start event as non-intercepted. Debounce `onInteractOutsideStart`
       * to avoid prematurely checking if other events were intercepted.
       */
      on(this.#documentObj, "pointerdown", executeCallbacks(this.#markNonInterceptedEvent, this.#handleInteractOutside)),
      /**
       * HANDLE FOCUS OUTSIDE
       */
      on(this.#documentObj, "focusin", this.#handleFocus)
    );
  }
  #handleDismiss = (e) => {
    let event = e;
    if (event.defaultPrevented) {
      event = createWrappedEvent(e);
    }
    this.#interactOutsideProp.current(e);
  };
  #handleInteractOutside = debounce2(
    (e) => {
      if (!this.opts.ref.current) {
        this.#unsubClickListener();
        return;
      }
      const isEventValid = this.opts.isValidEvent.current(e, this.opts.ref.current) || isValidEvent(e, this.opts.ref.current);
      if (!this.#isResponsibleLayer || this.#isAnyEventIntercepted() || !isEventValid) {
        this.#unsubClickListener();
        return;
      }
      let event = e;
      if (event.defaultPrevented) {
        event = createWrappedEvent(event);
      }
      if (strict_equals(this.#behaviorType.current, "close", false) && strict_equals(this.#behaviorType.current, "defer-otherwise-close", false)) {
        this.#unsubClickListener();
        return;
      }
      if (strict_equals(e.pointerType, "touch")) {
        this.#unsubClickListener();
        this.#unsubClickListener = addEventListener(this.#documentObj, "click", this.#handleDismiss, { once: true });
      } else {
        this.#interactOutsideProp.current(event);
      }
    },
    10
  );
  #markInterceptedEvent = (e) => {
    this.#interceptedEvents[e.type] = true;
  };
  #markNonInterceptedEvent = (e) => {
    this.#interceptedEvents[e.type] = false;
  };
  #markResponsibleLayer = () => {
    if (!this.opts.ref.current) return;
    this.#isResponsibleLayer = isResponsibleLayer(this.opts.ref.current);
  };
  #isTargetWithinLayer = (target) => {
    if (!this.opts.ref.current) return false;
    return isOrContainsTarget2(this.opts.ref.current, target);
  };
  #resetState = debounce2(
    () => {
      for (const eventType in this.#interceptedEvents) {
        this.#interceptedEvents[eventType] = false;
      }
      this.#isResponsibleLayer = false;
    },
    20
  );
  #isAnyEventIntercepted() {
    const i = Object.values(this.#interceptedEvents).some(Boolean);
    return i;
  }
  #onfocuscapture = () => {
    this.#isFocusInsideDOMTree = true;
  };
  #onblurcapture = () => {
    this.#isFocusInsideDOMTree = false;
  };
  props = {
    onfocuscapture: this.#onfocuscapture,
    onblurcapture: this.#onblurcapture
  };
};
function getTopMostLayer(layersArr) {
  return layersArr.findLast(([_, { current: behaviorType }]) => strict_equals(behaviorType, "close") || strict_equals(behaviorType, "ignore"));
}
function isResponsibleLayer(node) {
  const layersArr = [...globalThis.bitsDismissableLayers];
  const topMostLayer = getTopMostLayer(layersArr);
  if (topMostLayer) return strict_equals(topMostLayer[0].opts.ref.current, node);
  const [firstLayerNode] = layersArr[0];
  return strict_equals(firstLayerNode.opts.ref.current, node);
}
function isValidEvent(e, node) {
  if ("button" in e && e.button > 0) return false;
  const target = e.target;
  if (!isElement2(target)) return false;
  const ownerDocument = getOwnerDocument2(target);
  const isValid = ownerDocument.documentElement.contains(target) && !isOrContainsTarget2(node, target) && isClickTrulyOutside(e, node);
  return isValid;
}
function createWrappedEvent(e) {
  const capturedCurrentTarget = e.currentTarget;
  const capturedTarget = e.target;
  let newEvent;
  if (e instanceof PointerEvent) {
    newEvent = new PointerEvent(e.type, e);
  } else {
    newEvent = new PointerEvent("pointerdown", e);
  }
  let isPrevented = false;
  const wrappedEvent = new Proxy(newEvent, {
    get: (target, prop2) => {
      if (strict_equals(prop2, "currentTarget")) {
        return capturedCurrentTarget;
      }
      if (strict_equals(prop2, "target")) {
        return capturedTarget;
      }
      if (strict_equals(prop2, "preventDefault")) {
        return () => {
          isPrevented = true;
          if (strict_equals(typeof target.preventDefault, "function")) {
            target.preventDefault();
          }
        };
      }
      if (strict_equals(prop2, "defaultPrevented")) {
        return isPrevented;
      }
      if (prop2 in target) {
        return target[prop2];
      }
      return e[prop2];
    }
  });
  return wrappedEvent;
}

// node_modules/bits-ui/dist/bits/utilities/dismissible-layer/dismissible-layer.svelte
Dismissible_layer[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/dismissible-layer/dismissible-layer.svelte";
function Dismissible_layer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Dismissible_layer);
  let interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onFocusOutside = prop($$props, "onFocusOutside", 3, noop3), isValidEvent2 = prop($$props, "isValidEvent", 3, () => false);
  const dismissibleLayerState = DismissibleLayerState.create({
    id: box.with(() => $$props.id),
    interactOutsideBehavior: box.with(() => interactOutsideBehavior()),
    onInteractOutside: box.with(() => onInteractOutside()),
    enabled: box.with(() => $$props.enabled),
    onFocusOutside: box.with(() => onFocusOutside()),
    isValidEvent: box.with(() => isValidEvent2()),
    ref: $$props.ref
  });
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop, () => ({ props: dismissibleLayerState.props })), "render", Dismissible_layer, 29, 0);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dismissible_layer = hmr(Dismissible_layer, () => Dismissible_layer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dismissible_layer[HMR].source;
    set(Dismissible_layer[HMR].source, module.default[HMR].original);
  });
}
var dismissible_layer_default = Dismissible_layer;

// node_modules/bits-ui/dist/bits/utilities/escape-layer/use-escape-layer.svelte.js
globalThis.bitsEscapeLayers ??= /* @__PURE__ */ new Map();
var EscapeLayerState = class _EscapeLayerState {
  static create(opts) {
    return new _EscapeLayerState(opts);
  }
  opts;
  domContext;
  constructor(opts) {
    this.opts = opts;
    this.domContext = new DOMContext(this.opts.ref);
    let unsubEvents = noop3;
    watch(() => opts.enabled.current, (enabled) => {
      if (enabled) {
        globalThis.bitsEscapeLayers.set(this, opts.escapeKeydownBehavior);
        unsubEvents = this.#addEventListener();
      }
      return () => {
        unsubEvents();
        globalThis.bitsEscapeLayers.delete(this);
      };
    });
  }
  #addEventListener = () => {
    return on(this.domContext.getDocument(), "keydown", this.#onkeydown, { passive: false });
  };
  #onkeydown = (e) => {
    if (strict_equals(e.key, kbd_constants_exports.ESCAPE, false) || !isResponsibleEscapeLayer(this)) return;
    const clonedEvent = new KeyboardEvent(e.type, e);
    e.preventDefault();
    const behaviorType = this.opts.escapeKeydownBehavior.current;
    if (strict_equals(behaviorType, "close", false) && strict_equals(behaviorType, "defer-otherwise-close", false)) return;
    this.opts.onEscapeKeydown.current(clonedEvent);
  };
};
function isResponsibleEscapeLayer(instance) {
  const layersArr = [...globalThis.bitsEscapeLayers];
  const topMostLayer = layersArr.findLast(([_, { current: behaviorType }]) => strict_equals(behaviorType, "close") || strict_equals(behaviorType, "ignore"));
  if (topMostLayer) return strict_equals(topMostLayer[0], instance);
  const [firstLayerNode] = layersArr[0];
  return strict_equals(firstLayerNode, instance);
}

// node_modules/bits-ui/dist/bits/utilities/escape-layer/escape-layer.svelte
Escape_layer[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/escape-layer/escape-layer.svelte";
function Escape_layer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Escape_layer);
  let escapeKeydownBehavior = prop($$props, "escapeKeydownBehavior", 3, "close"), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3);
  EscapeLayerState.create({
    escapeKeydownBehavior: box.with(() => escapeKeydownBehavior()),
    onEscapeKeydown: box.with(() => onEscapeKeydown()),
    enabled: box.with(() => $$props.enabled),
    ref: $$props.ref
  });
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop), "render", Escape_layer, 23, 0);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Escape_layer = hmr(Escape_layer, () => Escape_layer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Escape_layer[HMR].source;
    set(Escape_layer[HMR].source, module.default[HMR].original);
  });
}
var escape_layer_default = Escape_layer;

// node_modules/bits-ui/dist/bits/utilities/focus-scope/focus-scope-manager.js
var FocusScopeManager = class _FocusScopeManager {
  static instance;
  #scopeStack = box([]);
  #focusHistory = /* @__PURE__ */ new WeakMap();
  static getInstance() {
    if (!this.instance) {
      this.instance = new _FocusScopeManager();
    }
    return this.instance;
  }
  register(scope) {
    const current = this.getActive();
    if (current && current !== scope) {
      current.pause();
    }
    this.#scopeStack.current = this.#scopeStack.current.filter((s) => s !== scope);
    this.#scopeStack.current.unshift(scope);
  }
  unregister(scope) {
    this.#scopeStack.current = this.#scopeStack.current.filter((s) => s !== scope);
    const next3 = this.getActive();
    if (next3) {
      next3.resume();
    }
  }
  getActive() {
    return this.#scopeStack.current[0];
  }
  setFocusMemory(scope, element2) {
    this.#focusHistory.set(scope, element2);
  }
  getFocusMemory(scope) {
    return this.#focusHistory.get(scope);
  }
  isActiveScope(scope) {
    return this.getActive() === scope;
  }
};

// node_modules/bits-ui/dist/bits/utilities/focus-scope/focus-scope.svelte.js
var FocusScope = class _FocusScope {
  #paused = false;
  #container = null;
  #manager = FocusScopeManager.getInstance();
  #cleanupFns = [];
  #opts;
  constructor(opts) {
    this.#opts = opts;
  }
  get paused() {
    return this.#paused;
  }
  pause() {
    this.#paused = true;
  }
  resume() {
    this.#paused = false;
  }
  #cleanup() {
    for (const fn of this.#cleanupFns) {
      fn();
    }
    this.#cleanupFns = [];
  }
  mount(container) {
    if (this.#container) {
      this.unmount();
    }
    this.#container = container;
    this.#manager.register(this);
    this.#setupEventListeners();
    this.#handleOpenAutoFocus();
  }
  unmount() {
    if (!this.#container) return;
    this.#cleanup();
    this.#handleCloseAutoFocus();
    this.#manager.unregister(this);
    this.#container = null;
  }
  #handleOpenAutoFocus() {
    if (!this.#container) return;
    const event = new CustomEvent("focusScope.onOpenAutoFocus", { bubbles: false, cancelable: true });
    this.#opts.onOpenAutoFocus.current(event);
    if (!event.defaultPrevented) {
      requestAnimationFrame(() => {
        if (!this.#container) return;
        const firstTabbable = this.#getFirstTabbable();
        if (firstTabbable) {
          firstTabbable.focus();
          this.#manager.setFocusMemory(this, firstTabbable);
        } else {
          this.#container.focus();
        }
      });
    }
  }
  #handleCloseAutoFocus() {
    const event = new CustomEvent("focusScope.onCloseAutoFocus", { bubbles: false, cancelable: true });
    this.#opts.onCloseAutoFocus.current?.(event);
    if (!event.defaultPrevented) {
      const prevFocused = document.activeElement;
      if (prevFocused && strict_equals(prevFocused, document.body, false)) {
        prevFocused.focus();
      }
    }
  }
  #setupEventListeners() {
    if (!this.#container || !this.#opts.trap.current) return;
    const container = this.#container;
    const doc = container.ownerDocument;
    const handleFocus = (e) => {
      if (this.#paused || !this.#manager.isActiveScope(this)) return;
      const target = e.target;
      if (!target) return;
      const isInside = container.contains(target);
      if (isInside) {
        this.#manager.setFocusMemory(this, target);
      } else {
        const lastFocused = this.#manager.getFocusMemory(this);
        if (lastFocused && container.contains(lastFocused) && isFocusable(lastFocused)) {
          e.preventDefault();
          lastFocused.focus();
        } else {
          const firstTabbable = this.#getFirstTabbable();
          const firstFocusable = this.#getAllFocusables()[0];
          (firstTabbable || firstFocusable || container).focus();
        }
      }
    };
    const handleKeydown = (e) => {
      if (!this.#opts.loop || this.#paused || strict_equals(e.key, "Tab", false)) return;
      if (!this.#manager.isActiveScope(this)) return;
      const tabbables = this.#getTabbables();
      if (tabbables.length < 2) return;
      const first = tabbables[0];
      const last = tabbables[tabbables.length - 1];
      if (!e.shiftKey && strict_equals(doc.activeElement, last)) {
        e.preventDefault();
        first.focus();
      } else if (e.shiftKey && strict_equals(doc.activeElement, first)) {
        e.preventDefault();
        last.focus();
      }
    };
    this.#cleanupFns.push(on(doc, "focusin", handleFocus, { capture: true }), on(container, "keydown", handleKeydown));
    const observer = new MutationObserver(() => {
      const lastFocused = this.#manager.getFocusMemory(this);
      if (lastFocused && !container.contains(lastFocused)) {
        const firstTabbable = this.#getFirstTabbable();
        const firstFocusable = this.#getAllFocusables()[0];
        const elementToFocus = firstTabbable || firstFocusable;
        if (elementToFocus) {
          elementToFocus.focus();
          this.#manager.setFocusMemory(this, elementToFocus);
        } else {
          container.focus();
        }
      }
    });
    observer.observe(container, { childList: true, subtree: true });
    this.#cleanupFns.push(() => observer.disconnect());
  }
  #getTabbables() {
    if (!this.#container) return [];
    return tabbable(this.#container, { includeContainer: false, getShadowRoot: true });
  }
  #getFirstTabbable() {
    const tabbables = this.#getTabbables();
    return tabbables[0] || null;
  }
  #getAllFocusables() {
    if (!this.#container) return [];
    return focusable(this.#container, { includeContainer: false, getShadowRoot: true });
  }
  static use(opts) {
    let scope = null;
    watch([() => opts.ref.current, () => opts.enabled.current], ([ref, enabled]) => {
      if (ref && enabled) {
        if (!scope) {
          scope = new _FocusScope(opts);
        }
        scope.mount(ref);
      } else if (scope) {
        scope.unmount();
        scope = null;
      }
    });
    onDestroyEffect(() => {
      scope?.unmount();
    });
    return {
      get props() {
        return { tabindex: -1 };
      }
    };
  }
};

// node_modules/bits-ui/dist/bits/utilities/focus-scope/focus-scope.svelte
Focus_scope[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/focus-scope/focus-scope.svelte";
function Focus_scope($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Focus_scope);
  let enabled = prop($$props, "enabled", 3, false), trapFocus = prop($$props, "trapFocus", 3, false), loop = prop($$props, "loop", 3, false), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), onOpenAutoFocus = prop($$props, "onOpenAutoFocus", 3, noop3);
  const focusScopeState = FocusScope.use({
    enabled: box.with(() => enabled()),
    trap: box.with(() => trapFocus()),
    loop: loop(),
    onCloseAutoFocus: box.with(() => onCloseAutoFocus()),
    onOpenAutoFocus: box.with(() => onOpenAutoFocus()),
    ref: $$props.ref
  });
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => $$props.focusScope ?? noop, () => ({ props: focusScopeState.props })), "render", Focus_scope, 27, 0);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Focus_scope = hmr(Focus_scope, () => Focus_scope[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Focus_scope[HMR].source;
    set(Focus_scope[HMR].source, module.default[HMR].original);
  });
}
var focus_scope_default = Focus_scope;

// node_modules/bits-ui/dist/bits/utilities/text-selection-layer/use-text-selection-layer.svelte.js
globalThis.bitsTextSelectionLayers ??= /* @__PURE__ */ new Map();
var TextSelectionLayerState = class _TextSelectionLayerState {
  static create(opts) {
    return new _TextSelectionLayerState(opts);
  }
  opts;
  domContext;
  #unsubSelectionLock = noop3;
  constructor(opts) {
    this.opts = opts;
    this.domContext = new DOMContext(opts.ref);
    let unsubEvents = noop3;
    watch(() => this.opts.enabled.current, (isEnabled) => {
      if (isEnabled) {
        globalThis.bitsTextSelectionLayers.set(this, this.opts.enabled);
        unsubEvents();
        unsubEvents = this.#addEventListeners();
      }
      return () => {
        unsubEvents();
        this.#resetSelectionLock();
        globalThis.bitsTextSelectionLayers.delete(this);
      };
    });
  }
  #addEventListeners() {
    return executeCallbacks(on(this.domContext.getDocument(), "pointerdown", this.#pointerdown), on(this.domContext.getDocument(), "pointerup", composeHandlers(this.#resetSelectionLock, this.opts.onPointerUp.current)));
  }
  #pointerdown = (e) => {
    const node = this.opts.ref.current;
    const target = e.target;
    if (!isHTMLElement2(node) || !isHTMLElement2(target) || !this.opts.enabled.current) return;
    if (!isHighestLayer(this) || !contains(node, target)) return;
    this.opts.onPointerDown.current(e);
    if (e.defaultPrevented) return;
    this.#unsubSelectionLock = preventTextSelectionOverflow(node, this.domContext.getDocument().body);
  };
  #resetSelectionLock = () => {
    this.#unsubSelectionLock();
    this.#unsubSelectionLock = noop3;
  };
};
var getUserSelect = (node) => node.style.userSelect || node.style.webkitUserSelect;
function preventTextSelectionOverflow(node, body) {
  const originalBodyUserSelect = getUserSelect(body);
  const originalNodeUserSelect = getUserSelect(node);
  setUserSelect(body, "none");
  setUserSelect(node, "text");
  return () => {
    setUserSelect(body, originalBodyUserSelect);
    setUserSelect(node, originalNodeUserSelect);
  };
}
function setUserSelect(node, value) {
  node.style.userSelect = value;
  node.style.webkitUserSelect = value;
}
function isHighestLayer(instance) {
  const layersArr = [...globalThis.bitsTextSelectionLayers];
  if (!layersArr.length) return false;
  const highestLayer = layersArr.at(-1);
  if (!highestLayer) return false;
  return strict_equals(highestLayer[0], instance);
}

// node_modules/bits-ui/dist/bits/utilities/text-selection-layer/text-selection-layer.svelte
Text_selection_layer[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/text-selection-layer/text-selection-layer.svelte";
function Text_selection_layer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Text_selection_layer);
  let preventOverflowTextSelection = prop($$props, "preventOverflowTextSelection", 3, true), onPointerDown = prop($$props, "onPointerDown", 3, noop3), onPointerUp = prop($$props, "onPointerUp", 3, noop3);
  TextSelectionLayerState.create({
    id: box.with(() => $$props.id),
    onPointerDown: box.with(() => onPointerDown()),
    onPointerUp: box.with(() => onPointerUp()),
    enabled: box.with(() => $$props.enabled && preventOverflowTextSelection()),
    ref: $$props.ref
  });
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop), "render", Text_selection_layer, 26, 0);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Text_selection_layer = hmr(Text_selection_layer, () => Text_selection_layer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Text_selection_layer[HMR].source;
    set(Text_selection_layer[HMR].source, module.default[HMR].original);
  });
}
var text_selection_layer_default = Text_selection_layer;

// node_modules/bits-ui/dist/internal/use-id.js
globalThis.bitsIdCounter ??= { current: 0 };
function useId(prefix = "bits") {
  globalThis.bitsIdCounter.current++;
  return `${prefix}-${globalThis.bitsIdCounter.current}`;
}

// node_modules/bits-ui/dist/internal/shared-state.svelte.js
var SharedState = class {
  #factory;
  #subscribers = 0;
  #state = tag(state(), "SharedState.#state");
  #scope;
  constructor(factory) {
    this.#factory = factory;
  }
  #dispose() {
    this.#subscribers -= 1;
    if (this.#scope && this.#subscribers <= 0) {
      this.#scope();
      set(this.#state, void 0);
      this.#scope = void 0;
    }
  }
  get(...args) {
    this.#subscribers += 1;
    if (strict_equals(get(this.#state), void 0)) {
      this.#scope = effect_root(() => {
        set(this.#state, this.#factory(...args), true);
      });
    }
    user_effect(() => {
      return () => {
        this.#dispose();
      };
    });
    return get(this.#state);
  }
};

// node_modules/bits-ui/dist/internal/body-scroll-lock.svelte.js
var bodyLockStackCount = new SharedState(() => {
  const map = new SvelteMap();
  const locked = tag(
    user_derived(() => {
      for (const value of map.values()) {
        if (value) return true;
      }
      return false;
    }),
    "locked"
  );
  let initialBodyStyle = tag(state(null), "initialBodyStyle");
  let stopTouchMoveListener = null;
  function resetBodyStyle() {
    if (!isBrowser) return;
    document.body.setAttribute("style", get(initialBodyStyle) ?? "");
    document.body.style.removeProperty("--scrollbar-width");
    isIOS && stopTouchMoveListener?.();
  }
  watch(() => get(locked), () => {
    if (!get(locked)) return;
    set(initialBodyStyle, document.body.getAttribute("style"), true);
    const bodyStyle = getComputedStyle(document.body);
    const verticalScrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
    const paddingRight = Number.parseInt(bodyStyle.paddingRight ?? "0", 10);
    const config = {
      padding: paddingRight + verticalScrollbarWidth,
      margin: Number.parseInt(bodyStyle.marginRight ?? "0", 10)
    };
    if (verticalScrollbarWidth > 0) {
      document.body.style.paddingRight = `${config.padding}px`;
      document.body.style.marginRight = `${config.margin}px`;
      document.body.style.setProperty("--scrollbar-width", `${verticalScrollbarWidth}px`);
      document.body.style.overflow = "hidden";
    }
    if (isIOS) {
      stopTouchMoveListener = addEventListener(
        document,
        "touchmove",
        (e) => {
          if (strict_equals(e.target, document.documentElement, false)) return;
          if (e.touches.length > 1) return;
          e.preventDefault();
        },
        { passive: false }
      );
    }
    afterTick(() => {
      document.body.style.pointerEvents = "none";
      document.body.style.overflow = "hidden";
    });
  });
  onDestroyEffect(() => {
    return () => {
      stopTouchMoveListener?.();
    };
  });
  return {
    get map() {
      return map;
    },
    resetBodyStyle
  };
});
var BodyScrollLock = class {
  #id = useId();
  #initialState;
  #restoreScrollDelay = () => null;
  #countState;
  locked;
  constructor(initialState, restoreScrollDelay = () => null) {
    this.#initialState = initialState;
    this.#restoreScrollDelay = restoreScrollDelay;
    this.#countState = bodyLockStackCount.get();
    if (!this.#countState) return;
    this.#countState.map.set(this.#id, this.#initialState ?? false);
    this.locked = box.with(() => this.#countState.map.get(this.#id) ?? false, (v) => this.#countState.map.set(this.#id, v));
    onDestroyEffect(() => {
      this.#countState.map.delete(this.#id);
      if (isAnyLocked(this.#countState.map)) return;
      const restoreScrollDelay2 = this.#restoreScrollDelay();
      if (strict_equals(restoreScrollDelay2, null)) {
        requestAnimationFrame(() => this.#countState.resetBodyStyle());
      } else {
        afterSleep(restoreScrollDelay2, () => this.#countState.resetBodyStyle());
      }
    });
  }
};
function isAnyLocked(map) {
  for (const [_, value] of map) {
    if (value) return true;
  }
  return false;
}

// node_modules/bits-ui/dist/bits/utilities/scroll-lock/scroll-lock.svelte
Scroll_lock[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/scroll-lock/scroll-lock.svelte";
function Scroll_lock($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_lock);
  let preventScroll = prop($$props, "preventScroll", 3, true), restoreScrollDelay = prop($$props, "restoreScrollDelay", 3, null);
  if (preventScroll()) {
    new BodyScrollLock(preventScroll(), () => restoreScrollDelay());
  }
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_lock = hmr(Scroll_lock, () => Scroll_lock[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_lock[HMR].source;
    set(Scroll_lock[HMR].source, module.default[HMR].original);
  });
}
var scroll_lock_default = Scroll_lock;

// node_modules/bits-ui/dist/internal/should-enable-focus-trap.js
function shouldEnableFocusTrap({ forceMount, present, open }) {
  if (forceMount)
    return open;
  return present && open;
}

// node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-content.svelte
Alert_dialog_content[FILENAME] = "node_modules/bits-ui/dist/bits/alert-dialog/components/alert-dialog-content.svelte";
var root_6 = add_locations(from_html(`<!> <!>`, 1), Alert_dialog_content[FILENAME], []);
var root_8 = add_locations(from_html(`<!> <div><!></div>`, 1), Alert_dialog_content[FILENAME], [[109, 8]]);
function Alert_dialog_content($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Alert_dialog_content);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "ignore"), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), onOpenAutoFocus = prop($$props, "onOpenAutoFocus", 3, noop3), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), preventScroll = prop($$props, "preventScroll", 3, true), trapFocus = prop($$props, "trapFocus", 3, true), restoreScrollDelay = prop($$props, "restoreScrollDelay", 3, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "children",
      "child",
      "ref",
      "forceMount",
      "interactOutsideBehavior",
      "onCloseAutoFocus",
      "onEscapeKeydown",
      "onOpenAutoFocus",
      "onInteractOutside",
      "preventScroll",
      "trapFocus",
      "restoreScrollDelay"
    ],
    "restProps"
  );
  const contentState = DialogContentState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    const presence = wrap_snippet(Alert_dialog_content, function($$anchor2) {
      validate_snippet_args(...arguments);
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const focusScope = wrap_snippet(Alert_dialog_content, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let focusScopeProps = () => $$arg0?.().props;
          focusScopeProps();
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          add_svelte_meta(
            () => escape_layer_default(node_2, spread_props(() => get(mergedProps), {
              get enabled() {
                return contentState.root.opts.open.current;
              },
              get ref() {
                return contentState.opts.ref;
              },
              onEscapeKeydown: (e) => {
                onEscapeKeydown()(e);
                if (e.defaultPrevented) return;
                contentState.root.handleClose();
              },
              children: wrap_snippet(Alert_dialog_content, ($$anchor4, $$slotProps) => {
                var fragment_3 = comment();
                var node_3 = first_child(fragment_3);
                add_svelte_meta(
                  () => dismissible_layer_default(node_3, spread_props(() => get(mergedProps), {
                    get ref() {
                      return contentState.opts.ref;
                    },
                    get enabled() {
                      return contentState.root.opts.open.current;
                    },
                    get interactOutsideBehavior() {
                      return interactOutsideBehavior();
                    },
                    onInteractOutside: (e) => {
                      onInteractOutside()(e);
                      if (e.defaultPrevented) return;
                      contentState.root.handleClose();
                    },
                    children: wrap_snippet(Alert_dialog_content, ($$anchor5, $$slotProps2) => {
                      var fragment_4 = comment();
                      var node_4 = first_child(fragment_4);
                      add_svelte_meta(
                        () => text_selection_layer_default(node_4, spread_props(() => get(mergedProps), {
                          get ref() {
                            return contentState.opts.ref;
                          },
                          get enabled() {
                            return contentState.root.opts.open.current;
                          },
                          children: wrap_snippet(Alert_dialog_content, ($$anchor6, $$slotProps3) => {
                            var fragment_5 = comment();
                            var node_5 = first_child(fragment_5);
                            {
                              var consequent_1 = ($$anchor7) => {
                                var fragment_6 = root_6();
                                var node_6 = first_child(fragment_6);
                                {
                                  var consequent = ($$anchor8) => {
                                    var fragment_7 = comment();
                                    var node_7 = first_child(fragment_7);
                                    add_svelte_meta(
                                      () => scroll_lock_default(node_7, {
                                        get preventScroll() {
                                          return preventScroll();
                                        },
                                        get restoreScrollDelay() {
                                          return restoreScrollDelay();
                                        }
                                      }),
                                      "component",
                                      Alert_dialog_content,
                                      101,
                                      9,
                                      { componentTag: "ScrollLock" }
                                    );
                                    append($$anchor8, fragment_7);
                                  };
                                  add_svelte_meta(
                                    () => if_block(node_6, ($$render) => {
                                      if (contentState.root.opts.open.current) $$render(consequent);
                                    }),
                                    "if",
                                    Alert_dialog_content,
                                    100,
                                    8
                                  );
                                }
                                var node_8 = sibling(node_6, 2);
                                {
                                  let $03 = user_derived(() => ({
                                    props: mergeProps(get(mergedProps), focusScopeProps()),
                                    ...contentState.snippetProps
                                  }));
                                  add_svelte_meta(() => snippet(node_8, () => $$props.child, () => get($03)), "render", Alert_dialog_content, 103, 8);
                                }
                                append($$anchor7, fragment_6);
                              };
                              var alternate = ($$anchor7) => {
                                var fragment_8 = root_8();
                                var node_9 = first_child(fragment_8);
                                add_svelte_meta(
                                  () => scroll_lock_default(node_9, {
                                    get preventScroll() {
                                      return preventScroll();
                                    }
                                  }),
                                  "component",
                                  Alert_dialog_content,
                                  108,
                                  8,
                                  { componentTag: "ScrollLock" }
                                );
                                var div = sibling(node_9, 2);
                                attribute_effect(div, ($03) => ({ ...$03 }), [() => mergeProps(get(mergedProps), focusScopeProps())]);
                                var node_10 = child(div);
                                add_svelte_meta(() => snippet(node_10, () => $$props.children ?? noop), "render", Alert_dialog_content, 110, 9);
                                reset(div);
                                append($$anchor7, fragment_8);
                              };
                              add_svelte_meta(
                                () => if_block(node_5, ($$render) => {
                                  if ($$props.child) $$render(consequent_1);
                                  else $$render(alternate, false);
                                }),
                                "if",
                                Alert_dialog_content,
                                99,
                                7
                              );
                            }
                            append($$anchor6, fragment_5);
                          }),
                          $$slots: { default: true }
                        })),
                        "component",
                        Alert_dialog_content,
                        94,
                        6,
                        { componentTag: "TextSelectionLayer" }
                      );
                      append($$anchor5, fragment_4);
                    }),
                    $$slots: { default: true }
                  })),
                  "component",
                  Alert_dialog_content,
                  83,
                  5,
                  { componentTag: "DismissibleLayer" }
                );
                append($$anchor4, fragment_3);
              }),
              $$slots: { default: true }
            })),
            "component",
            Alert_dialog_content,
            73,
            4,
            { componentTag: "EscapeLayer" }
          );
          append($$anchor3, fragment_2);
        });
        let $02 = user_derived(() => shouldEnableFocusTrap({
          forceMount: forceMount(),
          present: contentState.root.opts.open.current,
          open: contentState.root.opts.open.current
        }));
        add_svelte_meta(
          () => focus_scope_default(node_1, {
            get ref() {
              return contentState.opts.ref;
            },
            loop: true,
            get trapFocus() {
              return trapFocus();
            },
            get enabled() {
              return get($02);
            },
            onCloseAutoFocus: (e) => {
              onCloseAutoFocus()(e);
              if (e.defaultPrevented) return;
              afterSleep(0, () => contentState.root.triggerNode?.focus());
            },
            onOpenAutoFocus: (e) => {
              onOpenAutoFocus()(e);
              if (e.defaultPrevented) return;
              e.preventDefault();
              afterSleep(0, () => contentState.opts.ref.current?.focus());
            },
            focusScope,
            $$slots: { focusScope: true }
          }),
          "component",
          Alert_dialog_content,
          51,
          2,
          { componentTag: "FocusScope" }
        );
      }
      append($$anchor2, fragment_1);
    });
    let $0 = user_derived(() => contentState.root.opts.open.current || forceMount());
    add_svelte_meta(
      () => presence_layer_default(node, {
        get forceMount() {
          return forceMount();
        },
        get open() {
          return get($0);
        },
        get ref() {
          return contentState.opts.ref;
        },
        presence,
        $$slots: { presence: true }
      }),
      "component",
      Alert_dialog_content,
      45,
      0,
      { componentTag: "PresenceLayer" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Alert_dialog_content = hmr(Alert_dialog_content, () => Alert_dialog_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Alert_dialog_content[HMR].source;
    set(Alert_dialog_content[HMR].source, module.default[HMR].original);
  });
}
var alert_dialog_content_default = Alert_dialog_content;

// node_modules/bits-ui/dist/bits/dialog/components/dialog-overlay.svelte
Dialog_overlay[FILENAME] = "node_modules/bits-ui/dist/bits/dialog/components/dialog-overlay.svelte";
var root_32 = add_locations(from_html(`<div><!></div>`), Dialog_overlay[FILENAME], [[35, 3]]);
function Dialog_overlay($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Dialog_overlay);
  let id = prop($$props, "id", 19, () => createId(uid)), forceMount = prop($$props, "forceMount", 3, false), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "forceMount",
      "child",
      "children",
      "ref"
    ],
    "restProps"
  );
  const overlayState = DialogOverlayState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, overlayState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    const presence = wrap_snippet(Dialog_overlay, function($$anchor2) {
      validate_snippet_args(...arguments);
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          {
            let $02 = user_derived(() => ({
              props: mergeProps(get(mergedProps)),
              ...overlayState.snippetProps
            }));
            add_svelte_meta(() => snippet(node_2, () => $$props.child, () => get($02)), "render", Dialog_overlay, 33, 3);
          }
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var div = root_32();
          attribute_effect(div, ($02) => ({ ...$02 }), [() => mergeProps(get(mergedProps))]);
          var node_3 = child(div);
          add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop, () => overlayState.snippetProps), "render", Dialog_overlay, 36, 4);
          reset(div);
          append($$anchor3, div);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if ($$props.child) $$render(consequent);
            else $$render(alternate, false);
          }),
          "if",
          Dialog_overlay,
          32,
          2
        );
      }
      append($$anchor2, fragment_1);
    });
    let $0 = user_derived(() => overlayState.root.opts.open.current || forceMount());
    add_svelte_meta(
      () => presence_layer_default(node, {
        get open() {
          return get($0);
        },
        get ref() {
          return overlayState.opts.ref;
        },
        presence,
        $$slots: { presence: true }
      }),
      "component",
      Dialog_overlay,
      30,
      0,
      { componentTag: "PresenceLayer" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dialog_overlay = hmr(Dialog_overlay, () => Dialog_overlay[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dialog_overlay[HMR].source;
    set(Dialog_overlay[HMR].source, module.default[HMR].original);
  });
}
var dialog_overlay_default = Dialog_overlay;

// node_modules/bits-ui/dist/bits/dialog/components/dialog-trigger.svelte
Dialog_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/dialog/components/dialog-trigger.svelte";
var root_28 = add_locations(from_html(`<button><!></button>`), Dialog_trigger[FILENAME], [[33, 1]]);
function Dialog_trigger($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Dialog_trigger);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child",
      "disabled"
    ],
    "restProps"
  );
  const triggerState = DialogTriggerState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => Boolean(disabled()))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, triggerState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Dialog_trigger, 31, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_28();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Dialog_trigger, 34, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Dialog_trigger,
      30,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dialog_trigger = hmr(Dialog_trigger, () => Dialog_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dialog_trigger[HMR].source;
    set(Dialog_trigger[HMR].source, module.default[HMR].original);
  });
}
var dialog_trigger_default = Dialog_trigger;

// node_modules/bits-ui/dist/bits/dialog/components/dialog-description.svelte
Dialog_description[FILENAME] = "node_modules/bits-ui/dist/bits/dialog/components/dialog-description.svelte";
var root_29 = add_locations(from_html(`<div><!></div>`), Dialog_description[FILENAME], [[31, 1]]);
function Dialog_description($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Dialog_description);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "children",
      "child",
      "ref"
    ],
    "restProps"
  );
  const descriptionState = DialogDescriptionState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, descriptionState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Dialog_description, 29, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_29();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Dialog_description, 32, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Dialog_description,
      28,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dialog_description = hmr(Dialog_description, () => Dialog_description[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dialog_description[HMR].source;
    set(Dialog_description[HMR].source, module.default[HMR].original);
  });
}
var dialog_description_default = Dialog_description;

// node_modules/bits-ui/dist/bits/aspect-ratio/exports.js
var exports_exports3 = {};
__export(exports_exports3, {
  Root: () => aspect_ratio_default
});

// node_modules/bits-ui/dist/bits/aspect-ratio/aspect-ratio.svelte.js
var aspectRatioAttrs = createBitsAttrs({ component: "aspect-ratio", parts: ["root"] });
var AspectRatioRootState = class _AspectRatioRootState {
  static create(opts) {
    return new _AspectRatioRootState(opts);
  }
  opts;
  attachment;
  constructor(opts) {
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      style: { position: "absolute", top: 0, right: 0, bottom: 0, left: 0 },
      [aspectRatioAttrs.root]: "",
      ...this.attachment
    })),
    "AspectRatioRootState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};

// node_modules/bits-ui/dist/bits/aspect-ratio/components/aspect-ratio.svelte
Aspect_ratio[FILENAME] = "node_modules/bits-ui/dist/bits/aspect-ratio/components/aspect-ratio.svelte";
var root_210 = add_locations(from_html(`<div><!></div>`), Aspect_ratio[FILENAME], [[34, 2]]);
var root = add_locations(from_html(`<div><!></div>`), Aspect_ratio[FILENAME], [[30, 0]]);
function Aspect_ratio($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Aspect_ratio);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), ratio = prop($$props, "ratio", 3, 1), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "ratio",
      "children",
      "child"
    ],
    "restProps"
  );
  const rootState = AspectRatioRootState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    ratio: box.with(() => ratio())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var div = root();
  let styles;
  var node = child(div);
  {
    var consequent = ($$anchor2) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Aspect_ratio, 32, 2);
      append($$anchor2, fragment);
    };
    var alternate = ($$anchor2) => {
      var div_1 = root_210();
      attribute_effect(div_1, () => ({ ...get(mergedProps) }));
      var node_2 = child(div_1);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Aspect_ratio, 35, 3);
      reset(div_1);
      append($$anchor2, div_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Aspect_ratio,
      31,
      1
    );
  }
  reset(div);
  template_effect(($0) => styles = set_style(div, "", styles, $0), [
    () => ({
      position: "relative",
      width: "100%",
      "padding-bottom": `${ratio() ? 100 / ratio() : 0}%`
    })
  ]);
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Aspect_ratio = hmr(Aspect_ratio, () => Aspect_ratio[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Aspect_ratio[HMR].source;
    set(Aspect_ratio[HMR].source, module.default[HMR].original);
  });
}
var aspect_ratio_default = Aspect_ratio;

// node_modules/bits-ui/dist/bits/avatar/exports.js
var exports_exports4 = {};
__export(exports_exports4, {
  Fallback: () => avatar_fallback_default,
  Image: () => avatar_image_default,
  Root: () => avatar_default
});

// node_modules/bits-ui/dist/bits/avatar/avatar.svelte.js
var avatarAttrs = createBitsAttrs({ component: "avatar", parts: ["root", "image", "fallback"] });
var AvatarRootContext = new Context("Avatar.Root");
var AvatarRootState = class _AvatarRootState {
  static create(opts) {
    return AvatarRootContext.set(new _AvatarRootState(opts));
  }
  opts;
  domContext;
  attachment;
  constructor(opts) {
    this.opts = opts;
    this.domContext = new DOMContext(this.opts.ref);
    this.loadImage = this.loadImage.bind(this);
    this.attachment = attachRef(this.opts.ref);
  }
  loadImage(src, crossorigin, referrerPolicy) {
    if (strict_equals(this.opts.loadingStatus.current, "loaded")) return;
    let imageTimerId;
    const image = new Image();
    image.src = src;
    if (strict_equals(crossorigin, void 0, false)) image.crossOrigin = crossorigin;
    if (referrerPolicy) image.referrerPolicy = referrerPolicy;
    this.opts.loadingStatus.current = "loading";
    image.onload = () => {
      imageTimerId = this.domContext.setTimeout(
        () => {
          this.opts.loadingStatus.current = "loaded";
        },
        this.opts.delayMs.current
      );
    };
    image.onerror = () => {
      this.opts.loadingStatus.current = "error";
    };
    return () => {
      if (!imageTimerId) return;
      this.domContext.clearTimeout(imageTimerId);
    };
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      [avatarAttrs.root]: "",
      "data-status": this.opts.loadingStatus.current,
      ...this.attachment
    })),
    "AvatarRootState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var AvatarImageState = class _AvatarImageState {
  static create(opts) {
    return new _AvatarImageState(opts, AvatarRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    watch.pre(
      [
        () => this.opts.src.current,
        () => this.opts.crossOrigin.current
      ],
      ([src, crossOrigin]) => {
        if (!src) {
          this.root.opts.loadingStatus.current = "error";
          return;
        }
        this.root.loadImage(src, crossOrigin, this.opts.referrerPolicy.current);
      }
    );
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      style: {
        display: strict_equals(this.root.opts.loadingStatus.current, "loaded") ? "block" : "none"
      },
      "data-status": this.root.opts.loadingStatus.current,
      [avatarAttrs.image]: "",
      src: this.opts.src.current,
      crossorigin: this.opts.crossOrigin.current,
      referrerpolicy: this.opts.referrerPolicy.current,
      ...this.attachment
    })),
    "AvatarImageState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var AvatarFallbackState = class _AvatarFallbackState {
  static create(opts) {
    return new _AvatarFallbackState(opts, AvatarRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  #style = tag(user_derived(() => strict_equals(this.root.opts.loadingStatus.current, "loaded") ? { display: "none" } : void 0), "AvatarFallbackState.style");
  get style() {
    return get(this.#style);
  }
  set style(value) {
    set(this.#style, value);
  }
  #props = tag(
    user_derived(() => ({
      style: this.style,
      "data-status": this.root.opts.loadingStatus.current,
      [avatarAttrs.fallback]: "",
      ...this.attachment
    })),
    "AvatarFallbackState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};

// node_modules/bits-ui/dist/bits/avatar/components/avatar.svelte
Avatar[FILENAME] = "node_modules/bits-ui/dist/bits/avatar/components/avatar.svelte";
var root_211 = add_locations(from_html(`<div><!></div>`), Avatar[FILENAME], [[44, 1]]);
function Avatar($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Avatar);
  let delayMs = prop($$props, "delayMs", 3, 0), loadingStatus = prop($$props, "loadingStatus", 15, "loading"), id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "delayMs",
      "loadingStatus",
      "onLoadingStatusChange",
      "child",
      "children",
      "id",
      "ref"
    ],
    "restProps"
  );
  const rootState = AvatarRootState.create({
    delayMs: box.with(() => delayMs()),
    loadingStatus: box.with(() => loadingStatus(), (v) => {
      if (strict_equals(loadingStatus(), v, false)) {
        loadingStatus(v);
        $$props.onLoadingStatusChange?.(v);
      }
    }),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Avatar, 42, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_211();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Avatar, 45, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Avatar,
      41,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Avatar = hmr(Avatar, () => Avatar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Avatar[HMR].source;
    set(Avatar[HMR].source, module.default[HMR].original);
  });
}
var avatar_default = Avatar;

// node_modules/bits-ui/dist/bits/avatar/components/avatar-image.svelte
Avatar_image[FILENAME] = "node_modules/bits-ui/dist/bits/avatar/components/avatar-image.svelte";
var root_212 = add_locations(from_html(`<img/>`), Avatar_image[FILENAME], [[36, 1]]);
function Avatar_image($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Avatar_image);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), crossorigin = prop($$props, "crossorigin", 3, void 0), referrerpolicy = prop($$props, "referrerpolicy", 3, void 0), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "src",
      "child",
      "id",
      "ref",
      "crossorigin",
      "referrerpolicy"
    ],
    "restProps"
  );
  const imageState = AvatarImageState.create({
    src: box.with(() => $$props.src),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    crossOrigin: box.with(() => crossorigin()),
    referrerPolicy: box.with(() => referrerpolicy())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, imageState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Avatar_image, 34, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var img = root_212();
      attribute_effect(img, () => ({ ...get(mergedProps), src: $$props.src }));
      replay_events(img);
      append($$anchor2, img);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Avatar_image,
      33,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Avatar_image = hmr(Avatar_image, () => Avatar_image[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Avatar_image[HMR].source;
    set(Avatar_image[HMR].source, module.default[HMR].original);
  });
}
var avatar_image_default = Avatar_image;

// node_modules/bits-ui/dist/bits/avatar/components/avatar-fallback.svelte
Avatar_fallback[FILENAME] = "node_modules/bits-ui/dist/bits/avatar/components/avatar-fallback.svelte";
var root_213 = add_locations(from_html(`<span><!></span>`), Avatar_fallback[FILENAME], [[31, 1]]);
function Avatar_fallback($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Avatar_fallback);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref"
    ],
    "restProps"
  );
  const fallbackState = AvatarFallbackState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, fallbackState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Avatar_fallback, 29, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_213();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Avatar_fallback, 32, 2);
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Avatar_fallback,
      28,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Avatar_fallback = hmr(Avatar_fallback, () => Avatar_fallback[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Avatar_fallback[HMR].source;
    set(Avatar_fallback[HMR].source, module.default[HMR].original);
  });
}
var avatar_fallback_default = Avatar_fallback;

// node_modules/bits-ui/dist/bits/utilities/config/components/bits-config.svelte
Bits_config[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/config/components/bits-config.svelte";
function Bits_config($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Bits_config);
  useBitsConfig({
    defaultPortalTo: box.with(() => $$props.defaultPortalTo),
    defaultLocale: box.with(() => $$props.defaultLocale)
  });
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop), "render", Bits_config, 14, 0);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Bits_config = hmr(Bits_config, () => Bits_config[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Bits_config[HMR].source;
    set(Bits_config[HMR].source, module.default[HMR].original);
  });
}
var bits_config_default = Bits_config;

// node_modules/bits-ui/dist/bits/button/exports.js
var exports_exports5 = {};
__export(exports_exports5, {
  Root: () => button_default
});

// node_modules/bits-ui/dist/bits/button/components/button.svelte
Button[FILENAME] = "node_modules/bits-ui/dist/bits/button/components/button.svelte";
function Button($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Button);
  let disabled = prop($$props, "disabled", 3, false), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "href",
      "type",
      "children",
      "disabled",
      "ref"
    ],
    "restProps"
  );
  var fragment = comment();
  var node = first_child(fragment);
  {
    validate_void_dynamic_element(() => $$props.href ? "a" : "button");
    validate_dynamic_element_tag(() => $$props.href ? "a" : "button");
    element(
      node,
      () => $$props.href ? "a" : "button",
      false,
      ($$element, $$anchor2) => {
        bind_this($$element, ($$value) => ref($$value), () => ref());
        attribute_effect($$element, () => ({
          "data-button-root": true,
          type: $$props.href ? void 0 : $$props.type,
          href: $$props.href && !disabled() ? $$props.href : void 0,
          disabled: $$props.href ? void 0 : disabled(),
          "aria-disabled": $$props.href ? disabled() : void 0,
          role: $$props.href && disabled() ? "link" : void 0,
          tabindex: $$props.href && disabled() ? -1 : 0,
          ...restProps
        }));
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop), "render", Button, 26, 1);
        append($$anchor2, fragment_1);
      },
      void 0,
      [14, 0]
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Button = hmr(Button, () => Button[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Button[HMR].source;
    set(Button[HMR].source, module.default[HMR].original);
  });
}
var button_default = Button;

// node_modules/bits-ui/dist/bits/calendar/exports.js
var exports_exports6 = {};
__export(exports_exports6, {
  Cell: () => calendar_cell_default,
  Day: () => calendar_day_default,
  Grid: () => calendar_grid_default,
  GridBody: () => calendar_grid_body_default,
  GridHead: () => calendar_grid_head_default,
  GridRow: () => calendar_grid_row_default,
  HeadCell: () => calendar_head_cell_default,
  Header: () => calendar_header_default,
  Heading: () => calendar_heading_default,
  MonthSelect: () => calendar_month_select_default,
  NextButton: () => calendar_next_button_default,
  PrevButton: () => calendar_prev_button_default,
  Root: () => calendar_default,
  YearSelect: () => calendar_year_select_default
});

// node_modules/bits-ui/dist/internal/date-time/announcer.js
function initAnnouncer(doc) {
  if (!isBrowser || !doc)
    return null;
  let el = doc.querySelector("[data-bits-announcer]");
  const createLog = (kind) => {
    const log = doc.createElement("div");
    log.role = "log";
    log.ariaLive = kind;
    log.setAttribute("aria-relevant", "additions");
    return log;
  };
  if (!isHTMLElement2(el)) {
    const div = doc.createElement("div");
    div.style.cssText = srOnlyStylesString;
    div.setAttribute("data-bits-announcer", "");
    div.appendChild(createLog("assertive"));
    div.appendChild(createLog("polite"));
    el = div;
    doc.body.insertBefore(el, doc.body.firstChild);
  }
  const getLog = (kind) => {
    if (!isHTMLElement2(el))
      return null;
    const log = el.querySelector(`[aria-live="${kind}"]`);
    if (!isHTMLElement2(log))
      return null;
    return log;
  };
  return {
    getLog
  };
}
function getAnnouncer(doc) {
  const announcer = initAnnouncer(doc);
  function announce(value, kind = "assertive", timeout = 7500) {
    if (!announcer || !isBrowser || !doc)
      return;
    const log = announcer.getLog(kind);
    const content = doc.createElement("div");
    if (typeof value === "number") {
      value = value.toString();
    } else if (value === null) {
      value = "Empty";
    } else {
      value = value.trim();
    }
    content.innerText = value;
    if (kind === "assertive") {
      log?.replaceChildren(content);
    } else {
      log?.appendChild(content);
    }
    return setTimeout(() => {
      content.remove();
    }, timeout);
  }
  return {
    announce
  };
}

// node_modules/bits-ui/dist/internal/date-time/utils.js
var defaultDateDefaults = {
  defaultValue: void 0,
  granularity: "day"
};
var defaultTimeDefaults = {
  defaultValue: void 0,
  granularity: "minute"
};
function getDefaultDate(opts) {
  const withDefaults = { ...defaultDateDefaults, ...opts };
  const { defaultValue, granularity } = withDefaults;
  if (Array.isArray(defaultValue) && defaultValue.length) {
    return defaultValue[defaultValue.length - 1];
  }
  if (defaultValue && !Array.isArray(defaultValue)) {
    return defaultValue;
  } else {
    const date = /* @__PURE__ */ new Date();
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    const day = date.getDate();
    const calendarDateTimeGranularities = ["hour", "minute", "second"];
    if (calendarDateTimeGranularities.includes(granularity ?? "day")) {
      return new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(year, month, day, 0, 0, 0);
    }
    return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(year, month, day);
  }
}
function getDefaultTime(opts) {
  const withDefaults = { ...defaultTimeDefaults, ...opts };
  const { defaultValue } = withDefaults;
  if (defaultValue) {
    return defaultValue;
  } else {
    return new $35ea8db9cb2ccb90$export$680ea196effce5f(0, 0, 0);
  }
}
function parseStringToDateValue(dateStr, referenceVal) {
  let dateValue;
  if (referenceVal instanceof $35ea8db9cb2ccb90$export$d3b7288e7994edea) {
    dateValue = $fae977aafc393c5c$export$fd7893f06e92a6a4(dateStr);
  } else if (referenceVal instanceof $35ea8db9cb2ccb90$export$ca871e8dbb80966f) {
    dateValue = $fae977aafc393c5c$export$588937bcd60ade55(dateStr);
  } else {
    dateValue = $fae977aafc393c5c$export$6b862160d295c8e(dateStr);
  }
  return dateValue.calendar !== referenceVal.calendar ? $11d87f3f76e88657$export$b4a036af3fc0b032(dateValue, referenceVal.calendar) : dateValue;
}
function toDate(dateValue, tz = $14e0f24ef4ac5c92$export$aa8b41735afcabd2()) {
  if (dateValue instanceof $35ea8db9cb2ccb90$export$d3b7288e7994edea) {
    return dateValue.toDate();
  } else {
    return dateValue.toDate(tz);
  }
}
function getDateValueType(date) {
  if (date instanceof $35ea8db9cb2ccb90$export$99faa760c7908e4f)
    return "date";
  if (date instanceof $35ea8db9cb2ccb90$export$ca871e8dbb80966f)
    return "datetime";
  if (date instanceof $35ea8db9cb2ccb90$export$d3b7288e7994edea)
    return "zoneddatetime";
  throw new Error("Unknown date type");
}
function parseAnyDateValue(value, type) {
  switch (type) {
    case "date":
      return $fae977aafc393c5c$export$6b862160d295c8e(value);
    case "datetime":
      return $fae977aafc393c5c$export$588937bcd60ade55(value);
    case "zoneddatetime":
      return $fae977aafc393c5c$export$fd7893f06e92a6a4(value);
    default:
      throw new Error(`Unknown date type: ${type}`);
  }
}
function isCalendarDateTime(dateValue) {
  return dateValue instanceof $35ea8db9cb2ccb90$export$ca871e8dbb80966f;
}
function isZonedDateTime(dateValue) {
  return dateValue instanceof $35ea8db9cb2ccb90$export$d3b7288e7994edea;
}
function hasTime(dateValue) {
  return isCalendarDateTime(dateValue) || isZonedDateTime(dateValue);
}
function getDaysInMonth(date) {
  if (date instanceof Date) {
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    return new Date(year, month, 0).getDate();
  } else {
    return date.set({ day: 100 }).day;
  }
}
function isBefore(dateToCompare, referenceDate) {
  return dateToCompare.compare(referenceDate) < 0;
}
function isAfter(dateToCompare, referenceDate) {
  return dateToCompare.compare(referenceDate) > 0;
}
function isBeforeOrSame(dateToCompare, referenceDate) {
  return dateToCompare.compare(referenceDate) <= 0;
}
function isAfterOrSame(dateToCompare, referenceDate) {
  return dateToCompare.compare(referenceDate) >= 0;
}
function isBetweenInclusive(date, start, end) {
  return isAfterOrSame(date, start) && isBeforeOrSame(date, end);
}
function getLastFirstDayOfWeek(date, firstDayOfWeek, locale) {
  const day = $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale);
  if (firstDayOfWeek > day) {
    return date.subtract({ days: day + 7 - firstDayOfWeek });
  }
  if (firstDayOfWeek === day) {
    return date;
  }
  return date.subtract({ days: day - firstDayOfWeek });
}
function getNextLastDayOfWeek(date, firstDayOfWeek, locale) {
  const day = $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale);
  const lastDayOfWeek = firstDayOfWeek === 0 ? 6 : firstDayOfWeek - 1;
  if (day === lastDayOfWeek) {
    return date;
  }
  if (day > lastDayOfWeek) {
    return date.add({ days: 7 - day + lastDayOfWeek });
  }
  return date.add({ days: lastDayOfWeek - day });
}
function areAllDaysBetweenValid(start, end, isUnavailable, isDisabled) {
  if (isUnavailable === void 0 && isDisabled === void 0) {
    return true;
  }
  let dCurrent = start.add({ days: 1 });
  if (isDisabled?.(dCurrent) || isUnavailable?.(dCurrent)) {
    return false;
  }
  const dEnd = end;
  while (dCurrent.compare(dEnd) < 0) {
    dCurrent = dCurrent.add({ days: 1 });
    if (isDisabled?.(dCurrent) || isUnavailable?.(dCurrent)) {
      return false;
    }
  }
  return true;
}

// node_modules/bits-ui/dist/internal/date-time/field/parts.js
var DATE_SEGMENT_PARTS = ["day", "month", "year"];
var EDITABLE_TIME_SEGMENT_PARTS = ["hour", "minute", "second", "dayPeriod"];
var NON_EDITABLE_SEGMENT_PARTS = ["literal", "timeZoneName"];
var EDITABLE_SEGMENT_PARTS = [
  ...DATE_SEGMENT_PARTS,
  ...EDITABLE_TIME_SEGMENT_PARTS
];
var ALL_SEGMENT_PARTS = [
  ...EDITABLE_SEGMENT_PARTS,
  ...NON_EDITABLE_SEGMENT_PARTS
];
var ALL_TIME_SEGMENT_PARTS = [
  ...EDITABLE_TIME_SEGMENT_PARTS,
  ...NON_EDITABLE_SEGMENT_PARTS
];
var ALL_EXCEPT_LITERAL_PARTS = ALL_SEGMENT_PARTS.filter((part) => part !== "literal");
var ALL_TIME_EXCEPT_LITERAL_PARTS = ALL_TIME_SEGMENT_PARTS.filter((part) => part !== "literal");

// node_modules/bits-ui/dist/internal/date-time/placeholders.js
var supportedLocales = [
  "ach",
  "af",
  "am",
  "an",
  "ar",
  "ast",
  "az",
  "be",
  "bg",
  "bn",
  "br",
  "bs",
  "ca",
  "cak",
  "ckb",
  "cs",
  "cy",
  "da",
  "de",
  "dsb",
  "el",
  "en",
  "eo",
  "es",
  "et",
  "eu",
  "fa",
  "ff",
  "fi",
  "fr",
  "fy",
  "ga",
  "gd",
  "gl",
  "he",
  "hr",
  "hsb",
  "hu",
  "ia",
  "id",
  "it",
  "ja",
  "ka",
  "kk",
  "kn",
  "ko",
  "lb",
  "lo",
  "lt",
  "lv",
  "meh",
  "ml",
  "ms",
  "nl",
  "nn",
  "no",
  "oc",
  "pl",
  "pt",
  "rm",
  "ro",
  "ru",
  "sc",
  "scn",
  "sk",
  "sl",
  "sr",
  "sv",
  "szl",
  "tg",
  "th",
  "tr",
  "uk",
  "zh-CN",
  "zh-TW"
];
var placeholderFields = ["year", "month", "day"];
var placeholders = {
  ach: { year: "mwaka", month: "dwe", day: "nino" },
  af: { year: "jjjj", month: "mm", day: "dd" },
  am: { year: "", month: "", day: "" },
  an: { year: "aaaa", month: "mm", day: "dd" },
  ar: { year: "", month: "", day: "" },
  ast: { year: "aaaa", month: "mm", day: "dd" },
  az: { year: "iiii", month: "aa", day: "gg" },
  be: { year: "", month: "", day: "" },
  bg: { year: "", month: "", day: "" },
  bn: { year: "yyyy", month: "", day: "dd" },
  br: { year: "bbbb", month: "mm", day: "dd" },
  bs: { year: "gggg", month: "mm", day: "dd" },
  ca: { year: "aaaa", month: "mm", day: "dd" },
  cak: { year: "jjjj", month: "ii", day: "q'q'" },
  ckb: { year: "", month: "", day: "" },
  cs: { year: "rrrr", month: "mm", day: "dd" },
  cy: { year: "bbbb", month: "mm", day: "dd" },
  da: { year: "", month: "mm", day: "dd" },
  de: { year: "jjjj", month: "mm", day: "tt" },
  dsb: { year: "llll", month: "mm", day: "" },
  el: { year: "", month: "", day: "" },
  en: { year: "yyyy", month: "mm", day: "dd" },
  eo: { year: "jjjj", month: "mm", day: "tt" },
  es: { year: "aaaa", month: "mm", day: "dd" },
  et: { year: "aaaa", month: "kk", day: "pp" },
  eu: { year: "uuuu", month: "hh", day: "ee" },
  fa: { year: "", month: "", day: "" },
  ff: { year: "hhhh", month: "ll", day: "" },
  fi: { year: "vvvv", month: "kk", day: "pp" },
  fr: { year: "aaaa", month: "mm", day: "jj" },
  fy: { year: "jjjj", month: "mm", day: "dd" },
  ga: { year: "bbbb", month: "mm", day: "ll" },
  gd: { year: "bbbb", month: "mm", day: "ll" },
  gl: { year: "aaaa", month: "mm", day: "dd" },
  he: { year: "", month: "", day: "" },
  hr: { year: "gggg", month: "mm", day: "dd" },
  hsb: { year: "llll", month: "mm", day: "dd" },
  hu: { year: "", month: "hh", day: "nn" },
  ia: { year: "aaaa", month: "mm", day: "dd" },
  id: { year: "tttt", month: "bb", day: "hh" },
  it: { year: "aaaa", month: "mm", day: "gg" },
  ja: { year: "  ", month: "", day: "" },
  ka: { year: "", month: "", day: "" },
  kk: { year: "", month: "", day: "" },
  kn: { year: "", month: "", day: "" },
  ko: { year: "", month: "", day: "" },
  lb: { year: "jjjj", month: "mm", day: "dd" },
  lo: { year: "", month: "", day: "" },
  lt: { year: "mmmm", month: "mm", day: "dd" },
  lv: { year: "gggg", month: "mm", day: "dd" },
  meh: { year: "aaaa", month: "mm", day: "dd" },
  ml: { year: "", month: "", day: "" },
  ms: { year: "tttt", month: "mm", day: "hh" },
  nl: { year: "jjjj", month: "mm", day: "dd" },
  nn: { year: "", month: "mm", day: "dd" },
  no: { year: "", month: "mm", day: "dd" },
  oc: { year: "aaaa", month: "mm", day: "jj" },
  pl: { year: "rrrr", month: "mm", day: "dd" },
  pt: { year: "aaaa", month: "mm", day: "dd" },
  rm: { year: "oooo", month: "mm", day: "dd" },
  ro: { year: "aaaa", month: "ll", day: "zz" },
  ru: { year: "", month: "", day: "" },
  sc: { year: "aaaa", month: "mm", day: "dd" },
  scn: { year: "aaaa", month: "mm", day: "jj" },
  sk: { year: "rrrr", month: "mm", day: "dd" },
  sl: { year: "llll", month: "mm", day: "dd" },
  sr: { year: "", month: "", day: "" },
  sv: { year: "", month: "mm", day: "dd" },
  szl: { year: "rrrr", month: "mm", day: "dd" },
  tg: { year: "", month: "", day: "" },
  th: { year: "", month: "", day: "" },
  tr: { year: "yyyy", month: "aa", day: "gg" },
  uk: { year: "", month: "", day: "" },
  "zh-CN": { year: "", month: "", day: "" },
  "zh-TW": { year: "", month: "", day: "" }
};
function getPlaceholderObj(locale) {
  if (!isSupportedLocale(locale)) {
    const localeLanguage = getLocaleLanguage(locale);
    if (!isSupportedLocale(localeLanguage)) {
      return placeholders.en;
    } else {
      return placeholders[localeLanguage];
    }
  } else {
    return placeholders[locale];
  }
}
function getPlaceholder(field, value, locale) {
  if (isPlaceholderField(field))
    return getPlaceholderObj(locale)[field];
  if (isDefaultField(field))
    return value;
  if (isTimeField(field))
    return "";
  return "";
}
function isSupportedLocale(locale) {
  return supportedLocales.includes(locale);
}
function isPlaceholderField(field) {
  return placeholderFields.includes(field);
}
function isTimeField(field) {
  return field === "hour" || field === "minute" || field === "second";
}
function isDefaultField(field) {
  return field === "era" || field === "dayPeriod";
}
function getLocaleLanguage(locale) {
  if (Intl.Locale) {
    return new Intl.Locale(locale).language;
  }
  return locale.split("-")[0];
}

// node_modules/bits-ui/dist/internal/date-time/field/helpers.js
function initializeSegmentValues(granularity) {
  const calendarDateTimeGranularities = ["hour", "minute", "second"];
  const initialParts = EDITABLE_SEGMENT_PARTS.map((part) => {
    if (part === "dayPeriod") {
      return [part, "AM"];
    }
    return [part, null];
  }).filter(([key2]) => {
    if (key2 === "literal" || key2 === null)
      return false;
    if (granularity === "day") {
      return !calendarDateTimeGranularities.includes(key2);
    } else {
      return true;
    }
  });
  return Object.fromEntries(initialParts);
}
function createContentObj(props) {
  const { segmentValues, formatter, locale, dateRef } = props;
  const content = Object.keys(segmentValues).reduce((obj, part) => {
    if (!isSegmentPart(part))
      return obj;
    if ("hour" in segmentValues && part === "dayPeriod") {
      const value = segmentValues[part];
      if (!isNull(value)) {
        obj[part] = value;
      } else {
        obj[part] = getPlaceholder(part, "AM", locale);
      }
    } else {
      obj[part] = getPartContent(part);
    }
    return obj;
  }, {});
  function getPartContent(part) {
    if ("hour" in segmentValues) {
      const value = segmentValues[part];
      const leadingZero = typeof value === "string" && value?.startsWith("0");
      const intValue = value !== null ? Number.parseInt(value) : null;
      if (value === "0" && part !== "year") {
        return "0";
      } else if (!isNull(value) && !isNull(intValue)) {
        const formatted = formatter.part(dateRef.set({ [part]: value }), part, {
          hourCycle: props.hourCycle === 24 ? "h23" : void 0
        });
        if (part === "hour" && "dayPeriod" in segmentValues && props.hourCycle !== 24) {
          if (intValue > 12) {
            const hour = intValue - 12;
            if (hour === 0) {
              return "12";
            } else if (hour < 10) {
              return `0${hour}`;
            } else {
              return `${hour}`;
            }
          }
          if (intValue === 0) {
            return "12";
          }
          if (intValue < 10) {
            return `0${intValue}`;
          }
          return `${intValue}`;
        }
        if (part === "year") {
          return `${value}`;
        }
        if (leadingZero && formatted.length === 1) {
          return `0${formatted}`;
        }
        return formatted;
      } else {
        return getPlaceholder(part, "", locale);
      }
    } else {
      if (isDateSegmentPart(part)) {
        const value = segmentValues[part];
        const leadingZero = typeof value === "string" && value?.startsWith("0");
        if (value === "0") {
          return "0";
        } else if (!isNull(value)) {
          const formatted = formatter.part(dateRef.set({ [part]: value }), part);
          if (part === "year") {
            return `${value}`;
          }
          if (leadingZero && formatted.length === 1) {
            return `0${formatted}`;
          }
          return formatted;
        } else {
          return getPlaceholder(part, "", locale);
        }
      }
      return "";
    }
  }
  return content;
}
function createContentArr(props) {
  const { granularity, dateRef, formatter, contentObj, hideTimeZone, hourCycle } = props;
  const parts = formatter.toParts(dateRef, getOptsByGranularity(granularity, hourCycle));
  const segmentContentArr = parts.map((part) => {
    const defaultParts = ["literal", "dayPeriod", "timeZoneName", null];
    if (defaultParts.includes(part.type) || !isSegmentPart(part.type)) {
      return {
        part: part.type,
        value: part.value
      };
    }
    return {
      part: part.type,
      value: contentObj[part.type]
    };
  }).filter((segment) => {
    if (isNull(segment.part) || isNull(segment.value))
      return false;
    if (segment.part === "timeZoneName" && (!isZonedDateTime(dateRef) || hideTimeZone)) {
      return false;
    }
    return true;
  });
  return segmentContentArr;
}
function createContent(props) {
  const contentObj = createContentObj(props);
  const contentArr = createContentArr({
    contentObj,
    ...props
  });
  return {
    obj: contentObj,
    arr: contentArr
  };
}
function getOptsByGranularity(granularity, hourCycle) {
  const opts = {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    timeZoneName: "short",
    hourCycle: hourCycle === 24 ? "h23" : void 0,
    hour12: hourCycle === 24 ? false : void 0
  };
  if (granularity === "day") {
    delete opts.second;
    delete opts.hour;
    delete opts.minute;
    delete opts.timeZoneName;
  }
  if (granularity === "hour") {
    delete opts.minute;
  }
  if (granularity === "minute") {
    delete opts.second;
  }
  return opts;
}
function initSegmentStates() {
  return EDITABLE_SEGMENT_PARTS.reduce((acc, key2) => {
    acc[key2] = {
      lastKeyZero: false,
      hasLeftFocus: true,
      updating: null
    };
    return acc;
  }, {});
}
function isDateSegmentPart(part) {
  return DATE_SEGMENT_PARTS.includes(part);
}
function isSegmentPart(part) {
  return EDITABLE_SEGMENT_PARTS.includes(part);
}
function isAnySegmentPart(part) {
  return ALL_SEGMENT_PARTS.includes(part);
}
function getUsedSegments(fieldNode) {
  if (!isBrowser || !fieldNode)
    return [];
  const usedSegments = getSegments(fieldNode).map((el) => el.dataset.segment).filter((part) => {
    return EDITABLE_SEGMENT_PARTS.includes(part);
  });
  return usedSegments;
}
function getValueFromSegments(props) {
  const { segmentObj, fieldNode, dateRef } = props;
  const usedSegments = getUsedSegments(fieldNode);
  let date = dateRef;
  for (const part of usedSegments) {
    if ("hour" in segmentObj) {
      const value = segmentObj[part];
      if (isNull(value))
        continue;
      date = date.set({ [part]: segmentObj[part] });
    } else if (isDateSegmentPart(part)) {
      const value = segmentObj[part];
      if (isNull(value))
        continue;
      date = date.set({ [part]: segmentObj[part] });
    }
  }
  return date;
}
function areAllSegmentsFilled(segmentValues, fieldNode) {
  const usedSegments = getUsedSegments(fieldNode);
  for (const part of usedSegments) {
    if ("hour" in segmentValues) {
      if (segmentValues[part] === null) {
        return false;
      }
    } else if (isDateSegmentPart(part)) {
      if (segmentValues[part] === null) {
        return false;
      }
    }
  }
  return true;
}
function isDateAndTimeSegmentObj(obj) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  return Object.entries(obj).every(([key2, value]) => {
    const validKey = EDITABLE_TIME_SEGMENT_PARTS.includes(key2) || DATE_SEGMENT_PARTS.includes(key2);
    const validValue = key2 === "dayPeriod" ? value === "AM" || value === "PM" || value === null : typeof value === "string" || typeof value === "number" || value === null;
    return validKey && validValue;
  });
}
function inferGranularity(value, granularity) {
  if (granularity)
    return granularity;
  if (hasTime(value))
    return "minute";
  return "day";
}
function isAcceptableSegmentKey(key2) {
  const acceptableSegmentKeys = [
    kbd_constants_exports.ENTER,
    kbd_constants_exports.ARROW_UP,
    kbd_constants_exports.ARROW_DOWN,
    kbd_constants_exports.ARROW_LEFT,
    kbd_constants_exports.ARROW_RIGHT,
    kbd_constants_exports.BACKSPACE,
    kbd_constants_exports.SPACE
  ];
  if (acceptableSegmentKeys.includes(key2))
    return true;
  if (isNumberString(key2))
    return true;
  return false;
}
function isFirstSegment(id, fieldNode) {
  if (!isBrowser)
    return false;
  const segments = getSegments(fieldNode);
  return segments.length ? segments[0].id === id : false;
}
function setDescription(props) {
  const { id, formatter, value, doc } = props;
  if (!isBrowser)
    return;
  const valueString = formatter.selectedDate(value);
  const el = doc.getElementById(id);
  if (!el) {
    const div = doc.createElement("div");
    div.style.cssText = styleToString({
      display: "none"
    });
    div.id = id;
    div.innerText = `Selected Date: ${valueString}`;
    doc.body.appendChild(div);
  } else {
    el.innerText = `Selected Date: ${valueString}`;
  }
}
function removeDescriptionElement(id, doc) {
  if (!isBrowser)
    return;
  const el = doc.getElementById(id);
  if (!el)
    return;
  doc.body.removeChild(el);
}
function getDefaultHourCycle(locale) {
  const formatter = new Intl.DateTimeFormat(locale, { hour: "numeric" });
  const parts = formatter.formatToParts(/* @__PURE__ */ new Date("2023-01-01T13:00:00"));
  const hourPart = parts.find((part) => part.type === "hour");
  return hourPart?.value === "1" ? 12 : 24;
}

// node_modules/bits-ui/dist/internal/date-time/field/segments.js
function handleSegmentNavigation(e, fieldNode) {
  const currentTarget = e.currentTarget;
  if (!isHTMLElement2(currentTarget))
    return;
  const { prev: prev2, next: next3 } = getPrevNextSegments(currentTarget, fieldNode);
  if (e.key === kbd_constants_exports.ARROW_LEFT) {
    if (!prev2)
      return;
    prev2.focus();
  } else if (e.key === kbd_constants_exports.ARROW_RIGHT) {
    if (!next3)
      return;
    next3.focus();
  }
}
function handleTimeSegmentNavigation(e, fieldNode) {
  const currentTarget = e.currentTarget;
  if (!isHTMLElement2(currentTarget))
    return;
  const { prev: prev2, next: next3 } = getPrevNextTimeSegments(currentTarget, fieldNode);
  if (e.key === kbd_constants_exports.ARROW_LEFT) {
    if (!prev2)
      return;
    prev2.focus();
  } else if (e.key === kbd_constants_exports.ARROW_RIGHT) {
    if (!next3)
      return;
    next3.focus();
  }
}
function getNextSegment(node, segments) {
  const index = segments.indexOf(node);
  if (index === segments.length - 1 || index === -1)
    return null;
  const nextIndex = index + 1;
  const nextSegment = segments[nextIndex];
  return nextSegment;
}
function getPrevSegment(node, segments) {
  const index = segments.indexOf(node);
  if (index === 0 || index === -1)
    return null;
  const prevIndex = index - 1;
  const prevSegment = segments[prevIndex];
  return prevSegment;
}
function getPrevNextSegments(startingNode, fieldNode) {
  const segments = getSegments(fieldNode);
  if (!segments.length) {
    return {
      next: null,
      prev: null
    };
  }
  return {
    next: getNextSegment(startingNode, segments),
    prev: getPrevSegment(startingNode, segments)
  };
}
function getPrevNextTimeSegments(startingNode, fieldNode) {
  const segments = getTimeSegments(fieldNode);
  if (!segments.length) {
    return {
      next: null,
      prev: null
    };
  }
  return {
    next: getNextSegment(startingNode, segments),
    prev: getPrevSegment(startingNode, segments)
  };
}
function moveToNextSegment(e, fieldNode) {
  const node = e.currentTarget;
  if (!isHTMLElement2(node))
    return;
  const { next: next3 } = getPrevNextSegments(node, fieldNode);
  if (!next3)
    return;
  next3.focus();
}
function moveToNextTimeSegment(e, fieldNode) {
  const node = e.currentTarget;
  if (!isHTMLElement2(node))
    return;
  const { next: next3 } = getPrevNextTimeSegments(node, fieldNode);
  if (!next3)
    return;
  next3.focus();
}
function moveToPrevTimeSegment(e, fieldNode) {
  const node = e.currentTarget;
  if (!isHTMLElement2(node))
    return;
  const { prev: prev2 } = getPrevNextTimeSegments(node, fieldNode);
  if (!prev2)
    return;
  prev2.focus();
}
function moveToPrevSegment(e, fieldNode) {
  const node = e.currentTarget;
  if (!isHTMLElement2(node))
    return;
  const { prev: prev2 } = getPrevNextSegments(node, fieldNode);
  if (!prev2)
    return;
  prev2.focus();
}
function isSegmentNavigationKey(key2) {
  if (key2 === kbd_constants_exports.ARROW_RIGHT || key2 === kbd_constants_exports.ARROW_LEFT)
    return true;
  return false;
}
function getSegments(fieldNode) {
  if (!fieldNode)
    return [];
  const segments = Array.from(fieldNode.querySelectorAll("[data-segment]")).filter((el) => {
    if (!isHTMLElement2(el))
      return false;
    const segment = el.dataset.segment;
    if (segment === "trigger")
      return true;
    if (!isAnySegmentPart(segment) || segment === "literal")
      return false;
    return true;
  });
  return segments;
}
function getTimeSegments(fieldNode) {
  if (!fieldNode)
    return [];
  const segments = Array.from(fieldNode.querySelectorAll("[data-segment]")).filter((el) => {
    if (!isHTMLElement2(el))
      return false;
    const segment = el.dataset.segment;
    if (segment === "trigger")
      return true;
    if (segment === "literal")
      return false;
    return true;
  });
  return segments;
}
function getFirstTimeSegment(fieldNode) {
  return getTimeSegments(fieldNode)[0];
}
function getFirstSegment(fieldNode) {
  return getSegments(fieldNode)[0];
}

// node_modules/bits-ui/dist/internal/date-time/field/time-helpers.js
function createTimeContentObj(props) {
  const { segmentValues, formatter, locale, timeRef } = props;
  const content = Object.keys(segmentValues).reduce((obj, part) => {
    if (!isEditableTimeSegmentPart(part))
      return obj;
    if (part === "dayPeriod") {
      const value = segmentValues[part];
      if (!isNull(value)) {
        obj[part] = value;
      } else {
        obj[part] = getPlaceholder(part, "AM", locale);
      }
    } else {
      obj[part] = getPartContent(part);
    }
    return obj;
  }, {});
  function getPartContent(part) {
    const value = segmentValues[part];
    const leadingZero = typeof value === "string" && value?.startsWith("0");
    const intValue = value !== null ? Number.parseInt(value) : null;
    if (!isNull(value) && !isNull(intValue)) {
      const formatted = formatter.part(timeRef.set({ [part]: value }), part, {
        hourCycle: props.hourCycle === 24 ? "h23" : void 0
      });
      if (part === "hour" && "dayPeriod" in segmentValues && props.hourCycle !== 24) {
        if (intValue > 12) {
          const hour = intValue - 12;
          if (hour === 0) {
            return "12";
          } else if (hour < 10) {
            return `0${hour}`;
          } else {
            return `${hour}`;
          }
        }
        if (intValue === 0) {
          return "12";
        }
        if (intValue < 10) {
          return `0${intValue}`;
        }
        return `${intValue}`;
      }
      if (leadingZero && formatted.length === 1) {
        return `0${formatted}`;
      }
      return formatted;
    } else {
      return getPlaceholder(part, "", locale);
    }
  }
  return content;
}
function createTimeContentArr(props) {
  const { granularity, timeRef, formatter, contentObj, hideTimeZone, hourCycle } = props;
  const parts = formatter.toParts(timeRef, getOptsByGranularity2(granularity, hourCycle));
  const timeSegmentContentArr = parts.map((part) => {
    const defaultParts = ["literal", "timeZoneName", null];
    if (defaultParts.includes(part.type) || !isEditableTimeSegmentPart(part.type)) {
      return {
        part: part.type,
        value: part.value
      };
    }
    return {
      part: part.type,
      value: contentObj[part.type]
    };
  }).filter((segment) => {
    if (isNull(segment.part) || isNull(segment.value))
      return false;
    if (segment.part === "timeZoneName" && (!isZonedDateTime(timeRef) || hideTimeZone)) {
      return false;
    }
    return true;
  });
  return timeSegmentContentArr;
}
function createTimeContent(props) {
  const contentObj = createTimeContentObj(props);
  const contentArr = createTimeContentArr({
    contentObj,
    ...props
  });
  return {
    obj: contentObj,
    arr: contentArr
  };
}
function getOptsByGranularity2(granularity, hourCycle) {
  const opts = {
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    timeZoneName: "short",
    hourCycle: hourCycle === 24 ? "h23" : void 0,
    hour12: hourCycle === 24 ? false : void 0
  };
  if (granularity === "hour") {
    delete opts.minute;
    delete opts.second;
  }
  if (granularity === "minute") {
    delete opts.second;
  }
  return opts;
}
function initTimeSegmentStates() {
  return EDITABLE_TIME_SEGMENT_PARTS.reduce((acc, key2) => {
    acc[key2] = {
      lastKeyZero: false,
      hasLeftFocus: true,
      updating: null
    };
    return acc;
  }, {});
}
function isEditableTimeSegmentPart(part) {
  return EDITABLE_TIME_SEGMENT_PARTS.includes(part);
}
function getUsedTimeSegments(fieldNode) {
  if (!isBrowser || !fieldNode)
    return [];
  const usedSegments = getTimeSegments(fieldNode).map((el) => el.dataset.segment).filter((part) => {
    return EDITABLE_TIME_SEGMENT_PARTS.includes(part);
  });
  return usedSegments;
}
function getTimeValueFromSegments(props) {
  const usedSegments = getUsedTimeSegments(props.fieldNode);
  for (const part of usedSegments) {
    const value = props.segmentObj[part];
    if (isNull(value))
      continue;
    props.timeRef = props.timeRef.set({ [part]: props.segmentObj[part] });
  }
  return props.timeRef;
}
function areAllTimeSegmentsFilled(segmentValues, fieldNode) {
  const usedSegments = getUsedTimeSegments(fieldNode);
  for (const part of usedSegments) {
    if (segmentValues[part] === null)
      return false;
  }
  return true;
}
function isFirstTimeSegment(id, fieldNode) {
  if (!isBrowser)
    return false;
  const segments = getTimeSegments(fieldNode);
  return segments.length ? segments[0].id === id : false;
}
function setTimeDescription(props) {
  if (!isBrowser)
    return;
  const valueString = props.formatter.selectedTime(props.value);
  const el = props.doc.getElementById(props.id);
  if (!el) {
    const div = props.doc.createElement("div");
    div.style.cssText = styleToString({
      display: "none"
    });
    div.id = props.id;
    div.innerText = `Selected Time: ${valueString}`;
    props.doc.body.appendChild(div);
  } else {
    el.innerText = `Selected Time: ${valueString}`;
  }
}
function removeTimeDescriptionElement(id, doc) {
  if (!isBrowser)
    return;
  const el = doc.getElementById(id);
  if (!el)
    return;
  doc.body.removeChild(el);
}
function convertTimeValueToDateValue(time) {
  if (time instanceof $35ea8db9cb2ccb90$export$680ea196effce5f) {
    return new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(2020, 1, 1, time.hour, time.minute, time.second, time.millisecond);
  }
  return time;
}
function convertTimeValueToTime(time) {
  if (time instanceof $35ea8db9cb2ccb90$export$680ea196effce5f)
    return time;
  return new $35ea8db9cb2ccb90$export$680ea196effce5f(time.hour, time.minute, time.second, time.millisecond);
}
function isTimeBefore(timeToCompare, referenceTime) {
  return timeToCompare.compare(referenceTime) < 0;
}
function getISOTimeValue(time) {
  if (time instanceof $35ea8db9cb2ccb90$export$680ea196effce5f) {
    return $35ea8db9cb2ccb90$export$680ea196effce5f.toString();
  }
  return new $35ea8db9cb2ccb90$export$680ea196effce5f(time.hour, time.minute, time.second, time.millisecond).toString();
}

// node_modules/bits-ui/dist/internal/date-time/formatter.js
var defaultPartOptions = {
  year: "numeric",
  month: "numeric",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric"
};
function createFormatter(opts) {
  let locale = opts.initialLocale;
  function setLocale(newLocale) {
    locale = newLocale;
  }
  function getLocale() {
    return locale;
  }
  function custom(date, options) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, options).format(date);
  }
  function selectedDate(date, includeTime = true) {
    if (hasTime(date) && includeTime) {
      return custom(toDate(date), {
        dateStyle: "long",
        timeStyle: "long"
      });
    } else {
      return custom(toDate(date), {
        dateStyle: "long"
      });
    }
  }
  function fullMonthAndYear(date) {
    if (typeof opts.monthFormat.current !== "function" && typeof opts.yearFormat.current !== "function") {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
        month: opts.monthFormat.current,
        year: opts.yearFormat.current
      }).format(date);
    }
    const formattedMonth = typeof opts.monthFormat.current === "function" ? opts.monthFormat.current(date.getMonth() + 1) : new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { month: opts.monthFormat.current }).format(date);
    const formattedYear = typeof opts.yearFormat.current === "function" ? opts.yearFormat.current(date.getFullYear()) : new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { year: opts.yearFormat.current }).format(date);
    return `${formattedMonth} ${formattedYear}`;
  }
  function fullMonth(date) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { month: "long" }).format(date);
  }
  function fullYear(date) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { year: "numeric" }).format(date);
  }
  function toParts(date, options) {
    if (isZonedDateTime(date)) {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
        ...options,
        timeZone: date.timeZone
      }).formatToParts(toDate(date));
    } else {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, options).formatToParts(toDate(date));
    }
  }
  function dayOfWeek(date, length = "narrow") {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { weekday: length }).format(date);
  }
  function dayPeriod(date, hourCycle = void 0) {
    const parts = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
      hour: "numeric",
      minute: "numeric",
      hourCycle: hourCycle === 24 ? "h23" : void 0
    }).formatToParts(date);
    const value = parts.find((p2) => p2.type === "dayPeriod")?.value;
    if (value === "PM") {
      return "PM";
    }
    return "AM";
  }
  function part(dateObj, type, options = {}) {
    const opts2 = { ...defaultPartOptions, ...options };
    const parts = toParts(dateObj, opts2);
    const part2 = parts.find((p2) => p2.type === type);
    return part2 ? part2.value : "";
  }
  return {
    setLocale,
    getLocale,
    fullMonth,
    fullYear,
    fullMonthAndYear,
    toParts,
    custom,
    part,
    dayPeriod,
    selectedDate,
    dayOfWeek
  };
}
function createTimeFormatter(initialLocale) {
  let locale = initialLocale;
  function setLocale(newLocale) {
    locale = newLocale;
  }
  function getLocale() {
    return locale;
  }
  function custom(date, options) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, options).format(date);
  }
  function selectedTime(date) {
    return custom(toDate(convertTimeValueToDateValue(date)), {
      timeStyle: "long"
    });
  }
  function toParts(timeValue, options) {
    const dateValue = convertTimeValueToDateValue(timeValue);
    if (isZonedDateTime(dateValue)) {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
        ...options,
        timeZone: dateValue.timeZone
      }).formatToParts(toDate(dateValue));
    } else {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, options).formatToParts(toDate(dateValue));
    }
  }
  function dayPeriod(date, hourCycle = void 0) {
    const parts = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
      hour: "numeric",
      minute: "numeric",
      hourCycle: hourCycle === 24 ? "h23" : void 0
    }).formatToParts(date);
    const value = parts.find((p2) => p2.type === "dayPeriod")?.value;
    if (value === "PM")
      return "PM";
    return "AM";
  }
  function part(dateObj, type, options = {}) {
    const opts = { ...defaultPartOptions, ...options };
    const parts = toParts(dateObj, opts);
    const part2 = parts.find((p2) => p2.type === type);
    return part2 ? part2.value : "";
  }
  return {
    setLocale,
    getLocale,
    toParts,
    custom,
    part,
    dayPeriod,
    selectedTime
  };
}

// node_modules/bits-ui/dist/internal/arrays.js
function arraysAreEqual(arr1, arr2) {
  if (arr1.length !== arr2.length)
    return false;
  return arr1.every((value, index) => isEqual(value, arr2[index]));
}
function isEqual(a2, b) {
  if (Number.isNaN(a2) && Number.isNaN(b))
    return true;
  if (Array.isArray(a2) && Array.isArray(b))
    return arraysAreEqual(a2, b);
  if (typeof a2 === "object" && typeof b === "object")
    return isDeepEqual(a2, b);
  return Object.is(a2, b);
}
function isDeepEqual(a2, b) {
  if (typeof a2 !== "object" || typeof b !== "object" || a2 === null || b === null)
    return false;
  const aKeys = Object.keys(a2);
  const bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length)
    return false;
  for (const key2 of aKeys) {
    if (!bKeys.includes(key2))
      return false;
    if (!isEqual(a2[key2], b[key2])) {
      return false;
    }
  }
  return true;
}
function chunk(arr, size2) {
  if (size2 <= 0)
    return [];
  const result = [];
  for (let i = 0; i < arr.length; i += size2) {
    result.push(arr.slice(i, i + size2));
  }
  return result;
}
function isValidIndex(index, arr) {
  return index >= 0 && index < arr.length;
}
function next2(array, index, loop = true) {
  if (array.length === 0 || index < 0 || index >= array.length)
    return;
  if (array.length === 1 && index === 0)
    return array[0];
  if (index === array.length - 1)
    return loop ? array[0] : void 0;
  return array[index + 1];
}
function prev(array, index, loop = true) {
  if (array.length === 0 || index < 0 || index >= array.length)
    return;
  if (array.length === 1 && index === 0)
    return array[0];
  if (index === 0)
    return loop ? array[array.length - 1] : void 0;
  return array[index - 1];
}
function forward(array, index, increment, loop = true) {
  if (array.length === 0 || index < 0 || index >= array.length)
    return;
  let targetIndex = index + increment;
  if (loop) {
    targetIndex = (targetIndex % array.length + array.length) % array.length;
  } else {
    targetIndex = Math.max(0, Math.min(targetIndex, array.length - 1));
  }
  return array[targetIndex];
}
function backward(array, index, decrement, loop = true) {
  if (array.length === 0 || index < 0 || index >= array.length)
    return;
  let targetIndex = index - decrement;
  if (loop) {
    targetIndex = (targetIndex % array.length + array.length) % array.length;
  } else {
    targetIndex = Math.max(0, Math.min(targetIndex, array.length - 1));
  }
  return array[targetIndex];
}
function getNextMatch(values, search, currentMatch) {
  const lowerSearch = search.toLowerCase();
  if (lowerSearch.endsWith(" ")) {
    const searchWithoutSpace = lowerSearch.slice(0, -1);
    const matchesWithoutSpace = values.filter((value) => value.toLowerCase().startsWith(searchWithoutSpace));
    if (matchesWithoutSpace.length <= 1) {
      return getNextMatch(values, searchWithoutSpace, currentMatch);
    }
    const currentMatchLowercase = currentMatch?.toLowerCase();
    if (currentMatchLowercase && currentMatchLowercase.startsWith(searchWithoutSpace) && currentMatchLowercase.charAt(searchWithoutSpace.length) === " " && search.trim() === searchWithoutSpace) {
      return currentMatch;
    }
    const spacedMatches = values.filter((value) => value.toLowerCase().startsWith(lowerSearch));
    if (spacedMatches.length > 0) {
      const currentMatchIndex2 = currentMatch ? values.indexOf(currentMatch) : -1;
      let wrappedMatches = wrapArray(spacedMatches, Math.max(currentMatchIndex2, 0));
      const nextMatch2 = wrappedMatches.find((match) => match !== currentMatch);
      return nextMatch2 || currentMatch;
    }
  }
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const normalizedLowerSearch = normalizedSearch.toLowerCase();
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = wrapArray(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch)
    wrappedValues = wrappedValues.filter((v) => v !== currentMatch);
  const nextMatch = wrappedValues.find((value) => value?.toLowerCase().startsWith(normalizedLowerSearch));
  return nextMatch !== currentMatch ? nextMatch : void 0;
}
function wrapArray(array, startIndex) {
  return array.map((_, index) => array[(startIndex + index) % array.length]);
}

// node_modules/bits-ui/dist/internal/date-time/calendar-helpers.svelte.js
function isCalendarDayNode(node) {
  if (!isHTMLElement2(node)) return false;
  if (!node.hasAttribute("data-bits-day")) return false;
  return true;
}
function getDaysBetween(start, end) {
  const days = [];
  let dCurrent = start.add({ days: 1 });
  const dEnd = end;
  while (dCurrent.compare(dEnd) < 0) {
    days.push(dCurrent);
    dCurrent = dCurrent.add({ days: 1 });
  }
  return days;
}
function createMonth(props) {
  const { dateObj, weekStartsOn, fixedWeeks, locale } = props;
  const daysInMonth = getDaysInMonth(dateObj);
  const datesArray = Array.from({ length: daysInMonth }, (_, i) => dateObj.set({ day: i + 1 }));
  const firstDayOfMonth = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(dateObj);
  const lastDayOfMonth = $14e0f24ef4ac5c92$export$a2258d9c4118825c(dateObj);
  const lastSunday = strict_equals(weekStartsOn, void 0, false) ? getLastFirstDayOfWeek(firstDayOfMonth, weekStartsOn, "en-US") : getLastFirstDayOfWeek(firstDayOfMonth, 0, locale);
  const nextSaturday = strict_equals(weekStartsOn, void 0, false) ? getNextLastDayOfWeek(lastDayOfMonth, weekStartsOn, "en-US") : getNextLastDayOfWeek(lastDayOfMonth, 0, locale);
  const lastMonthDays = getDaysBetween(lastSunday.subtract({ days: 1 }), firstDayOfMonth);
  const nextMonthDays = getDaysBetween(lastDayOfMonth, nextSaturday.add({ days: 1 }));
  const totalDays = lastMonthDays.length + datesArray.length + nextMonthDays.length;
  if (fixedWeeks && totalDays < 42) {
    const extraDays = 42 - totalDays;
    let startFrom = nextMonthDays[nextMonthDays.length - 1];
    if (!startFrom) {
      startFrom = dateObj.add({ months: 1 }).set({ day: 1 });
    }
    let length = extraDays;
    if (strict_equals(nextMonthDays.length, 0)) {
      length = extraDays - 1;
      nextMonthDays.push(startFrom);
    }
    const extraDaysArray = Array.from({ length }, (_, i) => {
      const incr = i + 1;
      return startFrom.add({ days: incr });
    });
    nextMonthDays.push(...extraDaysArray);
  }
  const allDays = lastMonthDays.concat(datesArray, nextMonthDays);
  const weeks = chunk(allDays, 7);
  return { value: dateObj, dates: allDays, weeks };
}
function createMonths(props) {
  const { numberOfMonths, dateObj, ...monthProps } = props;
  const months = [];
  if (!numberOfMonths || strict_equals(numberOfMonths, 1)) {
    months.push(createMonth({ ...monthProps, dateObj }));
    return months;
  }
  months.push(createMonth({ ...monthProps, dateObj }));
  for (let i = 1; i < numberOfMonths; i++) {
    const nextMonth = dateObj.add({ months: i });
    months.push(createMonth({ ...monthProps, dateObj: nextMonth }));
  }
  return months;
}
function getSelectableCells(calendarNode) {
  if (!calendarNode) return [];
  const selectableSelector = `[data-bits-day]:not([data-disabled]):not([data-outside-visible-months])`;
  return Array.from(calendarNode.querySelectorAll(selectableSelector)).filter((el) => isHTMLElement2(el));
}
function setPlaceholderToNodeValue(node, placeholder) {
  const cellValue = node.getAttribute("data-value");
  if (!cellValue) return;
  placeholder.current = parseStringToDateValue(cellValue, placeholder.current);
}
function shiftCalendarFocus({
  node,
  add,
  placeholder,
  calendarNode,
  isPrevButtonDisabled,
  isNextButtonDisabled,
  months,
  numberOfMonths
}) {
  const candidateCells = getSelectableCells(calendarNode);
  if (!candidateCells.length) return;
  const index = candidateCells.indexOf(node);
  const nextIndex = index + add;
  if (isValidIndex(nextIndex, candidateCells)) {
    const nextCell = candidateCells[nextIndex];
    setPlaceholderToNodeValue(nextCell, placeholder);
    return nextCell.focus();
  }
  if (nextIndex < 0) {
    if (isPrevButtonDisabled) return;
    const firstMonth = months[0]?.value;
    if (!firstMonth) return;
    placeholder.current = firstMonth.subtract({ months: numberOfMonths });
    afterTick(() => {
      const newCandidateCells = getSelectableCells(calendarNode);
      if (!newCandidateCells.length) return;
      const newIndex = newCandidateCells.length - Math.abs(nextIndex);
      if (isValidIndex(newIndex, newCandidateCells)) {
        const newCell = newCandidateCells[newIndex];
        setPlaceholderToNodeValue(newCell, placeholder);
        return newCell.focus();
      }
    });
  }
  if (nextIndex >= candidateCells.length) {
    if (isNextButtonDisabled) return;
    const firstMonth = months[0]?.value;
    if (!firstMonth) return;
    placeholder.current = firstMonth.add({ months: numberOfMonths });
    afterTick(() => {
      const newCandidateCells = getSelectableCells(calendarNode);
      if (!newCandidateCells.length) return;
      const newIndex = nextIndex - candidateCells.length;
      if (isValidIndex(newIndex, newCandidateCells)) {
        const nextCell = newCandidateCells[newIndex];
        return nextCell.focus();
      }
    });
  }
}
var ARROW_KEYS = [
  kbd_constants_exports.ARROW_DOWN,
  kbd_constants_exports.ARROW_UP,
  kbd_constants_exports.ARROW_LEFT,
  kbd_constants_exports.ARROW_RIGHT
];
var SELECT_KEYS = [kbd_constants_exports.ENTER, kbd_constants_exports.SPACE];
function handleCalendarKeydown({ event, handleCellClick, shiftFocus, placeholderValue }) {
  const currentCell = event.target;
  if (!isCalendarDayNode(currentCell)) return;
  if (!ARROW_KEYS.includes(event.key) && !SELECT_KEYS.includes(event.key)) return;
  event.preventDefault();
  const kbdFocusMap = {
    [kbd_constants_exports.ARROW_DOWN]: 7,
    [kbd_constants_exports.ARROW_UP]: -7,
    [kbd_constants_exports.ARROW_LEFT]: -1,
    [kbd_constants_exports.ARROW_RIGHT]: 1
  };
  if (ARROW_KEYS.includes(event.key)) {
    const add = kbdFocusMap[event.key];
    if (strict_equals(add, void 0, false)) {
      shiftFocus(currentCell, add);
    }
  }
  if (SELECT_KEYS.includes(event.key)) {
    const cellValue = currentCell.getAttribute("data-value");
    if (!cellValue) return;
    handleCellClick(event, parseStringToDateValue(cellValue, placeholderValue));
  }
}
function handleCalendarNextPage({
  months,
  setMonths,
  numberOfMonths,
  pagedNavigation,
  weekStartsOn,
  locale,
  fixedWeeks,
  setPlaceholder
}) {
  const firstMonth = months[0]?.value;
  if (!firstMonth) return;
  if (pagedNavigation) {
    setPlaceholder(firstMonth.add({ months: numberOfMonths }));
  } else {
    const newMonths = createMonths({
      dateObj: firstMonth.add({ months: 1 }),
      weekStartsOn,
      locale,
      fixedWeeks,
      numberOfMonths
    });
    setMonths(newMonths);
    const firstNewMonth = newMonths[0];
    if (!firstNewMonth) return;
    setPlaceholder(firstNewMonth.value.set({ day: 1 }));
  }
}
function handleCalendarPrevPage({
  months,
  setMonths,
  numberOfMonths,
  pagedNavigation,
  weekStartsOn,
  locale,
  fixedWeeks,
  setPlaceholder
}) {
  const firstMonth = months[0]?.value;
  if (!firstMonth) return;
  if (pagedNavigation) {
    setPlaceholder(firstMonth.subtract({ months: numberOfMonths }));
  } else {
    const newMonths = createMonths({
      dateObj: firstMonth.subtract({ months: 1 }),
      weekStartsOn,
      locale,
      fixedWeeks,
      numberOfMonths
    });
    setMonths(newMonths);
    const firstNewMonth = newMonths[0];
    if (!firstNewMonth) return;
    setPlaceholder(firstNewMonth.value.set({ day: 1 }));
  }
}
function getWeekdays({ months, formatter, weekdayFormat }) {
  if (!months.length) return [];
  const firstMonth = months[0];
  const firstWeek = firstMonth.weeks[0];
  if (!firstWeek) return [];
  return firstWeek.map((date) => formatter.dayOfWeek(toDate(date), weekdayFormat));
}
function useMonthViewOptionsSync(props) {
  user_effect(() => {
    const weekStartsOn = props.weekStartsOn.current;
    const locale = props.locale.current;
    const fixedWeeks = props.fixedWeeks.current;
    const numberOfMonths = props.numberOfMonths.current;
    untrack(() => {
      const placeholder = props.placeholder.current;
      if (!placeholder) return;
      const defaultMonthProps = { weekStartsOn, locale, fixedWeeks, numberOfMonths };
      props.setMonths(createMonths({ ...defaultMonthProps, dateObj: placeholder }));
    });
  });
}
function createAccessibleHeading({ calendarNode, label, accessibleHeadingId }) {
  const doc = getDocument(calendarNode);
  const div = doc.createElement("div");
  div.style.cssText = styleToString({
    border: "0px",
    clip: "rect(0px, 0px, 0px, 0px)",
    clipPath: "inset(50%)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: "0px",
    position: "absolute",
    whiteSpace: "nowrap",
    width: "1px"
  });
  const h2 = doc.createElement("div");
  h2.textContent = label;
  h2.id = accessibleHeadingId;
  h2.role = "heading";
  h2.ariaLevel = "2";
  calendarNode.insertBefore(div, calendarNode.firstChild);
  div.appendChild(h2);
  return () => {
    const h22 = doc.getElementById(accessibleHeadingId);
    if (!h22) return;
    div.parentElement?.removeChild(div);
    h22.remove();
  };
}
function useMonthViewPlaceholderSync({
  placeholder,
  getVisibleMonths,
  weekStartsOn,
  locale,
  fixedWeeks,
  numberOfMonths,
  setMonths
}) {
  user_effect(() => {
    placeholder.current;
    untrack(() => {
      if (getVisibleMonths().some((month) => $14e0f24ef4ac5c92$export$a18c89cbd24170ff(month, placeholder.current))) {
        return;
      }
      const defaultMonthProps = {
        weekStartsOn: weekStartsOn.current,
        locale: locale.current,
        fixedWeeks: fixedWeeks.current,
        numberOfMonths: numberOfMonths.current
      };
      setMonths(createMonths({ ...defaultMonthProps, dateObj: placeholder.current }));
    });
  });
}
function getIsNextButtonDisabled({ maxValue, months, disabled }) {
  if (!maxValue || !months.length) return false;
  if (disabled) return true;
  const lastMonthInView = months[months.length - 1]?.value;
  if (!lastMonthInView) return false;
  const firstMonthOfNextPage = lastMonthInView.add({ months: 1 }).set({ day: 1 });
  return isAfter(firstMonthOfNextPage, maxValue);
}
function getIsPrevButtonDisabled({ minValue, months, disabled }) {
  if (!minValue || !months.length) return false;
  if (disabled) return true;
  const firstMonthInView = months[0]?.value;
  if (!firstMonthInView) return false;
  const lastMonthOfPrevPage = firstMonthInView.subtract({ months: 1 }).set({ day: 35 });
  return isBefore(lastMonthOfPrevPage, minValue);
}
function getCalendarHeadingValue({ months, locale, formatter }) {
  if (!months.length) return "";
  if (strict_equals(locale, formatter.getLocale(), false)) {
    formatter.setLocale(locale);
  }
  if (strict_equals(months.length, 1)) {
    const month = toDate(months[0].value);
    return `${formatter.fullMonthAndYear(month)}`;
  }
  const startMonth = toDate(months[0].value);
  const endMonth = toDate(months[months.length - 1].value);
  const startMonthName = formatter.fullMonth(startMonth);
  const endMonthName = formatter.fullMonth(endMonth);
  const startMonthYear = formatter.fullYear(startMonth);
  const endMonthYear = formatter.fullYear(endMonth);
  const content = strict_equals(startMonthYear, endMonthYear) ? `${startMonthName} - ${endMonthName} ${endMonthYear}` : `${startMonthName} ${startMonthYear} - ${endMonthName} ${endMonthYear}`;
  return content;
}
function getCalendarElementProps({ fullCalendarLabel, id, isInvalid, disabled, readonly }) {
  return {
    id,
    role: "application",
    "aria-label": fullCalendarLabel,
    "data-invalid": getDataInvalid(isInvalid),
    "data-disabled": getDataDisabled(disabled),
    "data-readonly": getDataReadonly(readonly)
  };
}
function pickerOpenFocus(e) {
  const doc = getDocument(e.target);
  const nodeToFocus = doc.querySelector("[data-bits-day][data-focused]");
  if (nodeToFocus) {
    e.preventDefault();
    nodeToFocus?.focus();
  }
}
function getFirstNonDisabledDateInView(calendarRef) {
  if (!isBrowser) return;
  const daysInView = Array.from(calendarRef.querySelectorAll("[data-bits-day]:not([aria-disabled=true])"));
  if (strict_equals(daysInView.length, 0)) return;
  const element2 = daysInView[0];
  const value = element2?.getAttribute("data-value");
  const type = element2?.getAttribute("data-type");
  if (!value || !type) return;
  return parseAnyDateValue(value, type);
}
function useEnsureNonDisabledPlaceholder({
  ref,
  placeholder,
  defaultPlaceholder,
  minValue,
  maxValue,
  isDateDisabled
}) {
  function isDisabled(date) {
    if (isDateDisabled.current(date)) return true;
    if (minValue.current && isBefore(date, minValue.current)) return true;
    if (maxValue.current && isBefore(maxValue.current, date)) return true;
    return false;
  }
  watch(() => ref.current, () => {
    if (!ref.current) return;
    if (placeholder.current && $14e0f24ef4ac5c92$export$ea39ec197993aef0(placeholder.current, defaultPlaceholder) && isDisabled(defaultPlaceholder)) {
      placeholder.current = getFirstNonDisabledDateInView(ref.current) ?? defaultPlaceholder;
    }
  });
}
function getDateWithPreviousTime(date, prev2) {
  if (!date || !prev2) return date;
  if (hasTime(date) && hasTime(prev2)) {
    return date.set({
      hour: prev2.hour,
      minute: prev2.minute,
      millisecond: prev2.millisecond,
      second: prev2.second
    });
  }
  return date;
}
var calendarAttrs = createBitsAttrs({
  component: "calendar",
  parts: [
    "root",
    "grid",
    "cell",
    "next-button",
    "prev-button",
    "day",
    "grid-body",
    "grid-head",
    "grid-row",
    "head-cell",
    "header",
    "heading",
    "month-select",
    "year-select"
  ]
});
function getDefaultYears(opts) {
  const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
  const latestYear = Math.max(opts.placeholderYear, currentYear);
  let minYear;
  let maxYear;
  if (opts.minValue) {
    minYear = opts.minValue.year;
  } else {
    const initialMinYear = latestYear - 100;
    minYear = opts.placeholderYear < initialMinYear ? opts.placeholderYear - 10 : initialMinYear;
  }
  if (opts.maxValue) {
    maxYear = opts.maxValue.year;
  } else {
    maxYear = latestYear + 10;
  }
  if (minYear > maxYear) {
    minYear = maxYear;
  }
  const totalYears = maxYear - minYear + 1;
  return Array.from({ length: totalYears }, (_, i) => minYear + i);
}

// node_modules/bits-ui/dist/bits/calendar/calendar.svelte.js
var CalendarRootContext = new Context("Calendar.Root | RangeCalender.Root");
var CalendarRootState = class _CalendarRootState {
  static create(opts) {
    return CalendarRootContext.set(new _CalendarRootState(opts));
  }
  opts;
  #visibleMonths = tag(user_derived(() => this.months.map((month) => month.value)), "CalendarRootState.visibleMonths");
  get visibleMonths() {
    return get(this.#visibleMonths);
  }
  set visibleMonths(value) {
    set(this.#visibleMonths, value);
  }
  formatter;
  accessibleHeadingId = useId();
  domContext;
  attachment;
  #months = tag(state(proxy([])), "CalendarRootState.months");
  get months() {
    return get(this.#months);
  }
  set months(value) {
    set(this.#months, value, true);
  }
  announcer;
  constructor(opts) {
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.domContext = new DOMContext(opts.ref);
    this.announcer = getAnnouncer(null);
    this.formatter = createFormatter({
      initialLocale: this.opts.locale.current,
      monthFormat: this.opts.monthFormat,
      yearFormat: this.opts.yearFormat
    });
    this.setMonths = this.setMonths.bind(this);
    this.nextPage = this.nextPage.bind(this);
    this.prevPage = this.prevPage.bind(this);
    this.prevYear = this.prevYear.bind(this);
    this.nextYear = this.nextYear.bind(this);
    this.setYear = this.setYear.bind(this);
    this.setMonth = this.setMonth.bind(this);
    this.isOutsideVisibleMonths = this.isOutsideVisibleMonths.bind(this);
    this.isDateDisabled = this.isDateDisabled.bind(this);
    this.isDateSelected = this.isDateSelected.bind(this);
    this.shiftFocus = this.shiftFocus.bind(this);
    this.handleCellClick = this.handleCellClick.bind(this);
    this.handleMultipleUpdate = this.handleMultipleUpdate.bind(this);
    this.handleSingleUpdate = this.handleSingleUpdate.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
    this.getBitsAttr = this.getBitsAttr.bind(this);
    onMount(() => {
      this.announcer = getAnnouncer(this.domContext.getDocument());
    });
    this.months = createMonths({
      dateObj: this.opts.placeholder.current,
      weekStartsOn: this.opts.weekStartsOn.current,
      locale: this.opts.locale.current,
      fixedWeeks: this.opts.fixedWeeks.current,
      numberOfMonths: this.opts.numberOfMonths.current
    });
    this.#setupInitialFocusEffect();
    this.#setupAccessibleHeadingEffect();
    this.#setupFormatterEffect();
    useMonthViewPlaceholderSync({
      placeholder: this.opts.placeholder,
      getVisibleMonths: () => this.visibleMonths,
      weekStartsOn: this.opts.weekStartsOn,
      locale: this.opts.locale,
      fixedWeeks: this.opts.fixedWeeks,
      numberOfMonths: this.opts.numberOfMonths,
      setMonths: (months) => this.months = months
    });
    useMonthViewOptionsSync({
      fixedWeeks: this.opts.fixedWeeks,
      locale: this.opts.locale,
      numberOfMonths: this.opts.numberOfMonths,
      placeholder: this.opts.placeholder,
      setMonths: this.setMonths,
      weekStartsOn: this.opts.weekStartsOn
    });
    watch(() => this.fullCalendarLabel, (label) => {
      const node = this.domContext.getElementById(this.accessibleHeadingId);
      if (!node) return;
      node.textContent = label;
    });
    watch(() => this.opts.value.current, () => {
      const value = this.opts.value.current;
      if (Array.isArray(value) && value.length) {
        const lastValue = value[value.length - 1];
        if (lastValue && strict_equals(this.opts.placeholder.current, lastValue, false)) {
          this.opts.placeholder.current = lastValue;
        }
      } else if (!Array.isArray(value) && value && strict_equals(this.opts.placeholder.current, value, false)) {
        this.opts.placeholder.current = value;
      }
    });
    useEnsureNonDisabledPlaceholder({
      placeholder: opts.placeholder,
      defaultPlaceholder: opts.defaultPlaceholder,
      isDateDisabled: opts.isDateDisabled,
      maxValue: opts.maxValue,
      minValue: opts.minValue,
      ref: opts.ref
    });
  }
  setMonths(months) {
    this.months = months;
  }
  #weekdays = tag(
    user_derived(
      /**
       * This derived state holds an array of localized day names for the current
       * locale and calendar view. It dynamically syncs with the 'weekStartsOn' option,
       * updating its content when the option changes. Using this state to render the
       * calendar's days of the week is strongly recommended, as it guarantees that
       * the days are correctly formatted for the current locale and calendar view.
       */
      () => {
        return getWeekdays({
          months: this.months,
          formatter: this.formatter,
          weekdayFormat: this.opts.weekdayFormat.current
        });
      }
    ),
    "CalendarRootState.weekdays"
  );
  get weekdays() {
    return get(this.#weekdays);
  }
  set weekdays(value) {
    set(this.#weekdays, value);
  }
  #initialPlaceholderYear = tag(user_derived(() => untrack(() => this.opts.placeholder.current.year)), "CalendarRootState.initialPlaceholderYear");
  get initialPlaceholderYear() {
    return get(this.#initialPlaceholderYear);
  }
  set initialPlaceholderYear(value) {
    set(this.#initialPlaceholderYear, value);
  }
  #defaultYears = tag(
    user_derived(() => {
      return getDefaultYears({
        minValue: this.opts.minValue.current,
        maxValue: this.opts.maxValue.current,
        placeholderYear: this.initialPlaceholderYear
      });
    }),
    "CalendarRootState.defaultYears"
  );
  get defaultYears() {
    return get(this.#defaultYears);
  }
  set defaultYears(value) {
    set(this.#defaultYears, value);
  }
  #setupInitialFocusEffect() {
    user_effect(() => {
      const initialFocus = untrack(() => this.opts.initialFocus.current);
      if (initialFocus) {
        const firstFocusedDay = this.opts.ref.current?.querySelector(`[data-focused]`);
        if (firstFocusedDay) {
          firstFocusedDay.focus();
        }
      }
    });
  }
  #setupAccessibleHeadingEffect() {
    user_effect(() => {
      if (!this.opts.ref.current) return;
      const removeHeading = createAccessibleHeading({
        calendarNode: this.opts.ref.current,
        label: this.fullCalendarLabel,
        accessibleHeadingId: this.accessibleHeadingId
      });
      return removeHeading;
    });
  }
  #setupFormatterEffect() {
    user_pre_effect(() => {
      if (strict_equals(this.formatter.getLocale(), this.opts.locale.current)) return;
      this.formatter.setLocale(this.opts.locale.current);
    });
  }
  /**
   * Navigates to the next page of the calendar.
   */
  nextPage() {
    handleCalendarNextPage({
      fixedWeeks: this.opts.fixedWeeks.current,
      locale: this.opts.locale.current,
      numberOfMonths: this.opts.numberOfMonths.current,
      pagedNavigation: this.opts.pagedNavigation.current,
      setMonths: this.setMonths,
      setPlaceholder: (date) => this.opts.placeholder.current = date,
      weekStartsOn: this.opts.weekStartsOn.current,
      months: this.months
    });
  }
  /**
   * Navigates to the previous page of the calendar.
   */
  prevPage() {
    handleCalendarPrevPage({
      fixedWeeks: this.opts.fixedWeeks.current,
      locale: this.opts.locale.current,
      numberOfMonths: this.opts.numberOfMonths.current,
      pagedNavigation: this.opts.pagedNavigation.current,
      setMonths: this.setMonths,
      setPlaceholder: (date) => this.opts.placeholder.current = date,
      weekStartsOn: this.opts.weekStartsOn.current,
      months: this.months
    });
  }
  nextYear() {
    this.opts.placeholder.current = this.opts.placeholder.current.add({ years: 1 });
  }
  prevYear() {
    this.opts.placeholder.current = this.opts.placeholder.current.subtract({ years: 1 });
  }
  setYear(year) {
    this.opts.placeholder.current = this.opts.placeholder.current.set({ year });
  }
  setMonth(month) {
    this.opts.placeholder.current = this.opts.placeholder.current.set({ month });
  }
  #isNextButtonDisabled = tag(
    user_derived(() => {
      return getIsNextButtonDisabled({
        maxValue: this.opts.maxValue.current,
        months: this.months,
        disabled: this.opts.disabled.current
      });
    }),
    "CalendarRootState.isNextButtonDisabled"
  );
  get isNextButtonDisabled() {
    return get(this.#isNextButtonDisabled);
  }
  set isNextButtonDisabled(value) {
    set(this.#isNextButtonDisabled, value);
  }
  #isPrevButtonDisabled = tag(
    user_derived(() => {
      return getIsPrevButtonDisabled({
        minValue: this.opts.minValue.current,
        months: this.months,
        disabled: this.opts.disabled.current
      });
    }),
    "CalendarRootState.isPrevButtonDisabled"
  );
  get isPrevButtonDisabled() {
    return get(this.#isPrevButtonDisabled);
  }
  set isPrevButtonDisabled(value) {
    set(this.#isPrevButtonDisabled, value);
  }
  #isInvalid = tag(
    user_derived(() => {
      const value = this.opts.value.current;
      const isDateDisabled = this.opts.isDateDisabled.current;
      const isDateUnavailable = this.opts.isDateUnavailable.current;
      if (Array.isArray(value)) {
        if (!value.length) return false;
        for (const date of value) {
          if (isDateDisabled(date)) return true;
          if (isDateUnavailable(date)) return true;
        }
      } else {
        if (!value) return false;
        if (isDateDisabled(value)) return true;
        if (isDateUnavailable(value)) return true;
      }
      return false;
    }),
    "CalendarRootState.isInvalid"
  );
  get isInvalid() {
    return get(this.#isInvalid);
  }
  set isInvalid(value) {
    set(this.#isInvalid, value);
  }
  #headingValue = tag(
    user_derived(() => {
      this.opts.monthFormat.current;
      this.opts.yearFormat.current;
      return getCalendarHeadingValue({
        months: this.months,
        formatter: this.formatter,
        locale: this.opts.locale.current
      });
    }),
    "CalendarRootState.headingValue"
  );
  get headingValue() {
    return get(this.#headingValue);
  }
  set headingValue(value) {
    set(this.#headingValue, value);
  }
  #fullCalendarLabel = tag(
    user_derived(() => {
      return `${this.opts.calendarLabel.current} ${this.headingValue}`;
    }),
    "CalendarRootState.fullCalendarLabel"
  );
  get fullCalendarLabel() {
    return get(this.#fullCalendarLabel);
  }
  set fullCalendarLabel(value) {
    set(this.#fullCalendarLabel, value);
  }
  isOutsideVisibleMonths(date) {
    return !this.visibleMonths.some((month) => $14e0f24ef4ac5c92$export$a18c89cbd24170ff(date, month));
  }
  isDateDisabled(date) {
    if (this.opts.isDateDisabled.current(date) || this.opts.disabled.current) return true;
    const minValue = this.opts.minValue.current;
    const maxValue = this.opts.maxValue.current;
    if (minValue && isBefore(date, minValue)) return true;
    if (maxValue && isBefore(maxValue, date)) return true;
    return false;
  }
  isDateSelected(date) {
    const value = this.opts.value.current;
    if (Array.isArray(value)) {
      return value.some((d) => $14e0f24ef4ac5c92$export$ea39ec197993aef0(d, date));
    } else if (!value) {
      return false;
    }
    return $14e0f24ef4ac5c92$export$ea39ec197993aef0(value, date);
  }
  shiftFocus(node, add) {
    return shiftCalendarFocus({
      node,
      add,
      placeholder: this.opts.placeholder,
      calendarNode: this.opts.ref.current,
      isPrevButtonDisabled: this.isPrevButtonDisabled,
      isNextButtonDisabled: this.isNextButtonDisabled,
      months: this.months,
      numberOfMonths: this.opts.numberOfMonths.current
    });
  }
  #isMultipleSelectionValid(selectedDates) {
    if (strict_equals(this.opts.type.current, "multiple", false)) return true;
    if (!this.opts.maxDays.current) return true;
    const selectedCount = selectedDates.length;
    if (this.opts.maxDays.current && selectedCount > this.opts.maxDays.current) return false;
    return true;
  }
  handleCellClick(_, date) {
    if (this.opts.readonly.current || this.opts.isDateDisabled.current?.(date) || this.opts.isDateUnavailable.current?.(date)) {
      return;
    }
    const prev2 = this.opts.value.current;
    const multiple = strict_equals(this.opts.type.current, "multiple");
    if (multiple) {
      if (Array.isArray(prev2) || strict_equals(prev2, void 0)) {
        this.opts.value.current = this.handleMultipleUpdate(prev2, date);
      }
    } else if (!Array.isArray(prev2)) {
      const next3 = this.handleSingleUpdate(prev2, date);
      if (!next3) {
        this.announcer.announce("Selected date is now empty.", "polite", 5e3);
      } else {
        this.announcer.announce(`Selected Date: ${this.formatter.selectedDate(next3, false)}`, "polite");
      }
      this.opts.value.current = getDateWithPreviousTime(next3, prev2);
      if (strict_equals(next3, void 0, false)) {
        this.opts.onDateSelect?.current?.();
      }
    }
  }
  handleMultipleUpdate(prev2, date) {
    if (!prev2) {
      const newSelection = [date];
      return this.#isMultipleSelectionValid(newSelection) ? newSelection : [date];
    }
    if (!Array.isArray(prev2)) {
      if (true_default) throw new Error("Invalid value for multiple prop.");
      return;
    }
    const index = prev2.findIndex((d) => $14e0f24ef4ac5c92$export$ea39ec197993aef0(d, date));
    const preventDeselect = this.opts.preventDeselect.current;
    if (strict_equals(index, -1)) {
      const newSelection = [...prev2, date];
      if (this.#isMultipleSelectionValid(newSelection)) {
        return newSelection;
      } else {
        return [date];
      }
    } else if (preventDeselect) {
      return prev2;
    } else {
      const next3 = prev2.filter((d) => !$14e0f24ef4ac5c92$export$ea39ec197993aef0(d, date));
      if (!next3.length) {
        this.opts.placeholder.current = date;
        return void 0;
      }
      return next3;
    }
  }
  handleSingleUpdate(prev2, date) {
    if (Array.isArray(prev2)) {
      if (true_default) throw new Error("Invalid value for single prop.");
    }
    if (!prev2) return date;
    const preventDeselect = this.opts.preventDeselect.current;
    if (!preventDeselect && $14e0f24ef4ac5c92$export$ea39ec197993aef0(prev2, date)) {
      this.opts.placeholder.current = date;
      return void 0;
    }
    return date;
  }
  onkeydown(event) {
    handleCalendarKeydown({
      event,
      handleCellClick: this.handleCellClick,
      shiftFocus: this.shiftFocus,
      placeholderValue: this.opts.placeholder.current
    });
  }
  #snippetProps = tag(user_derived(() => ({ months: this.months, weekdays: this.weekdays })), "CalendarRootState.snippetProps");
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
  getBitsAttr = (part) => {
    return calendarAttrs.getAttr(part);
  };
  #props = tag(
    user_derived(() => ({
      ...getCalendarElementProps({
        fullCalendarLabel: this.fullCalendarLabel,
        id: this.opts.id.current,
        isInvalid: this.isInvalid,
        disabled: this.opts.disabled.current,
        readonly: this.opts.readonly.current
      }),
      [this.getBitsAttr("root")]: "",
      //
      onkeydown: this.onkeydown,
      ...this.attachment
    })),
    "CalendarRootState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var CalendarHeadingState = class _CalendarHeadingState {
  static create(opts) {
    return new _CalendarHeadingState(opts, CalendarRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "aria-hidden": getAriaHidden(true),
      "data-disabled": getDataDisabled(this.root.opts.disabled.current),
      "data-readonly": getDataReadonly(this.root.opts.readonly.current),
      [this.root.getBitsAttr("heading")]: "",
      ...this.attachment
    })),
    "CalendarHeadingState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var CalendarCellContext = new Context("Calendar.Cell | RangeCalendar.Cell");
var CalendarCellState = class _CalendarCellState {
  static create(opts) {
    return CalendarCellContext.set(new _CalendarCellState(opts, CalendarRootContext.get()));
  }
  opts;
  root;
  #cellDate = tag(user_derived(() => toDate(this.opts.date.current)), "CalendarCellState.cellDate");
  get cellDate() {
    return get(this.#cellDate);
  }
  set cellDate(value) {
    set(this.#cellDate, value);
  }
  #isUnavailable = tag(user_derived(() => this.root.opts.isDateUnavailable.current(this.opts.date.current)), "CalendarCellState.isUnavailable");
  get isUnavailable() {
    return get(this.#isUnavailable);
  }
  set isUnavailable(value) {
    set(this.#isUnavailable, value);
  }
  #isDateToday = tag(user_derived(() => $14e0f24ef4ac5c92$export$629b0a497aa65267(this.opts.date.current, $14e0f24ef4ac5c92$export$aa8b41735afcabd2())), "CalendarCellState.isDateToday");
  get isDateToday() {
    return get(this.#isDateToday);
  }
  set isDateToday(value) {
    set(this.#isDateToday, value);
  }
  #isOutsideMonth = tag(user_derived(() => !$14e0f24ef4ac5c92$export$a18c89cbd24170ff(this.opts.date.current, this.opts.month.current)), "CalendarCellState.isOutsideMonth");
  get isOutsideMonth() {
    return get(this.#isOutsideMonth);
  }
  set isOutsideMonth(value) {
    set(this.#isOutsideMonth, value);
  }
  #isOutsideVisibleMonths = tag(user_derived(() => this.root.isOutsideVisibleMonths(this.opts.date.current)), "CalendarCellState.isOutsideVisibleMonths");
  get isOutsideVisibleMonths() {
    return get(this.#isOutsideVisibleMonths);
  }
  set isOutsideVisibleMonths(value) {
    set(this.#isOutsideVisibleMonths, value);
  }
  #isDisabled = tag(user_derived(() => this.root.isDateDisabled(this.opts.date.current) || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current), "CalendarCellState.isDisabled");
  get isDisabled() {
    return get(this.#isDisabled);
  }
  set isDisabled(value) {
    set(this.#isDisabled, value);
  }
  #isFocusedDate = tag(user_derived(() => $14e0f24ef4ac5c92$export$ea39ec197993aef0(this.opts.date.current, this.root.opts.placeholder.current)), "CalendarCellState.isFocusedDate");
  get isFocusedDate() {
    return get(this.#isFocusedDate);
  }
  set isFocusedDate(value) {
    set(this.#isFocusedDate, value);
  }
  #isSelectedDate = tag(user_derived(() => this.root.isDateSelected(this.opts.date.current)), "CalendarCellState.isSelectedDate");
  get isSelectedDate() {
    return get(this.#isSelectedDate);
  }
  set isSelectedDate(value) {
    set(this.#isSelectedDate, value);
  }
  #labelText = tag(
    user_derived(() => this.root.formatter.custom(this.cellDate, {
      weekday: "long",
      month: "long",
      day: "numeric",
      year: "numeric"
    })),
    "CalendarCellState.labelText"
  );
  get labelText() {
    return get(this.#labelText);
  }
  set labelText(value) {
    set(this.#labelText, value);
  }
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  #snippetProps = tag(
    user_derived(() => ({
      disabled: this.isDisabled,
      unavailable: this.isUnavailable,
      selected: this.isSelectedDate,
      day: `${this.opts.date.current.day}`
    })),
    "CalendarCellState.snippetProps"
  );
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
  #ariaDisabled = tag(
    user_derived(() => {
      return this.isDisabled || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current || this.isUnavailable;
    }),
    "CalendarCellState.ariaDisabled"
  );
  get ariaDisabled() {
    return get(this.#ariaDisabled);
  }
  set ariaDisabled(value) {
    set(this.#ariaDisabled, value);
  }
  #sharedDataAttrs = tag(
    user_derived(() => ({
      "data-unavailable": getDataUnavailable(this.isUnavailable),
      "data-today": this.isDateToday ? "" : void 0,
      "data-outside-month": this.isOutsideMonth ? "" : void 0,
      "data-outside-visible-months": this.isOutsideVisibleMonths ? "" : void 0,
      "data-focused": this.isFocusedDate ? "" : void 0,
      "data-selected": getDataSelected(this.isSelectedDate),
      "data-value": this.opts.date.current.toString(),
      "data-type": getDateValueType(this.opts.date.current),
      "data-disabled": getDataDisabled(this.isDisabled || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current)
    })),
    "CalendarCellState.sharedDataAttrs"
  );
  get sharedDataAttrs() {
    return get(this.#sharedDataAttrs);
  }
  set sharedDataAttrs(value) {
    set(this.#sharedDataAttrs, value);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "gridcell",
      "aria-selected": getAriaSelected(this.isSelectedDate),
      "aria-disabled": getAriaDisabled(this.ariaDisabled),
      ...this.sharedDataAttrs,
      [this.root.getBitsAttr("cell")]: "",
      ...this.attachment
    })),
    "CalendarCellState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var CalendarDayState = class _CalendarDayState {
  static create(opts) {
    return new _CalendarDayState(opts, CalendarCellContext.get());
  }
  opts;
  cell;
  attachment;
  constructor(opts, cell) {
    this.opts = opts;
    this.cell = cell;
    this.onclick = this.onclick.bind(this);
    this.attachment = attachRef(this.opts.ref);
  }
  #tabindex = tag(user_derived(() => this.cell.isOutsideMonth && this.cell.root.opts.disableDaysOutsideMonth.current || this.cell.isDisabled ? void 0 : this.cell.isFocusedDate ? 0 : -1), "CalendarDayState.#tabindex");
  onclick(e) {
    if (this.cell.isDisabled) return;
    this.cell.root.handleCellClick(e, this.cell.opts.date.current);
  }
  #snippetProps = tag(
    user_derived(() => ({
      disabled: this.cell.isDisabled,
      unavailable: this.cell.isUnavailable,
      selected: this.cell.isSelectedDate,
      day: `${this.cell.opts.date.current.day}`
    })),
    "CalendarDayState.snippetProps"
  );
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "button",
      "aria-label": this.cell.labelText,
      "aria-disabled": getAriaDisabled(this.cell.ariaDisabled),
      ...this.cell.sharedDataAttrs,
      tabindex: get(this.#tabindex),
      [this.cell.root.getBitsAttr("day")]: "",
      "data-bits-day": "",
      onclick: this.onclick,
      ...this.attachment
    })),
    "CalendarDayState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var CalendarNextButtonState = class _CalendarNextButtonState {
  static create(opts) {
    return new _CalendarNextButtonState(opts, CalendarRootContext.get());
  }
  opts;
  root;
  #isDisabled = tag(user_derived(() => this.root.isNextButtonDisabled), "CalendarNextButtonState.isDisabled");
  get isDisabled() {
    return get(this.#isDisabled);
  }
  set isDisabled(value) {
    set(this.#isDisabled, value);
  }
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.onclick = this.onclick.bind(this);
    this.attachment = attachRef(this.opts.ref);
  }
  onclick(_) {
    if (this.isDisabled) return;
    this.root.nextPage();
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "button",
      type: "button",
      "aria-label": "Next",
      "aria-disabled": getAriaDisabled(this.isDisabled),
      "data-disabled": getDataDisabled(this.isDisabled),
      disabled: this.isDisabled,
      [this.root.getBitsAttr("next-button")]: "",
      //
      onclick: this.onclick,
      ...this.attachment
    })),
    "CalendarNextButtonState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var CalendarPrevButtonState = class _CalendarPrevButtonState {
  static create(opts) {
    return new _CalendarPrevButtonState(opts, CalendarRootContext.get());
  }
  opts;
  root;
  #isDisabled = tag(user_derived(() => this.root.isPrevButtonDisabled), "CalendarPrevButtonState.isDisabled");
  get isDisabled() {
    return get(this.#isDisabled);
  }
  set isDisabled(value) {
    set(this.#isDisabled, value);
  }
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.onclick = this.onclick.bind(this);
    this.attachment = attachRef(this.opts.ref);
  }
  onclick(_) {
    if (this.isDisabled) return;
    this.root.prevPage();
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "button",
      type: "button",
      "aria-label": "Previous",
      "aria-disabled": getAriaDisabled(this.isDisabled),
      "data-disabled": getDataDisabled(this.isDisabled),
      disabled: this.isDisabled,
      [this.root.getBitsAttr("prev-button")]: "",
      //
      onclick: this.onclick,
      ...this.attachment
    })),
    "CalendarPrevButtonState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var CalendarGridState = class _CalendarGridState {
  static create(opts) {
    return new _CalendarGridState(opts, CalendarRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      tabindex: -1,
      role: "grid",
      "aria-readonly": getAriaReadonly(this.root.opts.readonly.current),
      "aria-disabled": getAriaDisabled(this.root.opts.disabled.current),
      "data-readonly": getDataReadonly(this.root.opts.readonly.current),
      "data-disabled": getDataDisabled(this.root.opts.disabled.current),
      [this.root.getBitsAttr("grid")]: "",
      ...this.attachment
    })),
    "CalendarGridState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var CalendarGridBodyState = class _CalendarGridBodyState {
  static create(opts) {
    return new _CalendarGridBodyState(opts, CalendarRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "data-disabled": getDataDisabled(this.root.opts.disabled.current),
      "data-readonly": getDataReadonly(this.root.opts.readonly.current),
      [this.root.getBitsAttr("grid-body")]: "",
      ...this.attachment
    })),
    "CalendarGridBodyState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var CalendarGridHeadState = class _CalendarGridHeadState {
  static create(opts) {
    return new _CalendarGridHeadState(opts, CalendarRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "data-disabled": getDataDisabled(this.root.opts.disabled.current),
      "data-readonly": getDataReadonly(this.root.opts.readonly.current),
      [this.root.getBitsAttr("grid-head")]: "",
      ...this.attachment
    })),
    "CalendarGridHeadState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var CalendarGridRowState = class _CalendarGridRowState {
  static create(opts) {
    return new _CalendarGridRowState(opts, CalendarRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "data-disabled": getDataDisabled(this.root.opts.disabled.current),
      "data-readonly": getDataReadonly(this.root.opts.readonly.current),
      [this.root.getBitsAttr("grid-row")]: "",
      ...this.attachment
    })),
    "CalendarGridRowState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var CalendarHeadCellState = class _CalendarHeadCellState {
  static create(opts) {
    return new _CalendarHeadCellState(opts, CalendarRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "data-disabled": getDataDisabled(this.root.opts.disabled.current),
      "data-readonly": getDataReadonly(this.root.opts.readonly.current),
      [this.root.getBitsAttr("head-cell")]: "",
      ...this.attachment
    })),
    "CalendarHeadCellState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var CalendarHeaderState = class _CalendarHeaderState {
  static create(opts) {
    return new _CalendarHeaderState(opts, CalendarRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "data-disabled": getDataDisabled(this.root.opts.disabled.current),
      "data-readonly": getDataReadonly(this.root.opts.readonly.current),
      [this.root.getBitsAttr("header")]: "",
      ...this.attachment
    })),
    "CalendarHeaderState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var CalendarMonthSelectState = class _CalendarMonthSelectState {
  static create(opts) {
    return new _CalendarMonthSelectState(opts, CalendarRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.onchange = this.onchange.bind(this);
    this.attachment = attachRef(this.opts.ref);
  }
  #monthItems = tag(
    user_derived(() => {
      this.root.opts.locale.current;
      const monthNumbers = this.opts.months.current;
      const monthFormat = this.opts.monthFormat.current;
      const months = [];
      for (const month of monthNumbers) {
        const date = this.root.opts.placeholder.current.set({ month });
        let label;
        if (strict_equals(typeof monthFormat, "function")) {
          label = monthFormat(month);
        } else {
          label = this.root.formatter.custom(toDate(date), { month: monthFormat });
        }
        months.push({ value: month, label });
      }
      return months;
    }),
    "CalendarMonthSelectState.monthItems"
  );
  get monthItems() {
    return get(this.#monthItems);
  }
  set monthItems(value) {
    set(this.#monthItems, value);
  }
  #currentMonth = tag(user_derived(() => this.root.opts.placeholder.current.month), "CalendarMonthSelectState.currentMonth");
  get currentMonth() {
    return get(this.#currentMonth);
  }
  set currentMonth(value) {
    set(this.#currentMonth, value);
  }
  #isDisabled = tag(user_derived(() => this.root.opts.disabled.current || this.opts.disabled.current), "CalendarMonthSelectState.isDisabled");
  get isDisabled() {
    return get(this.#isDisabled);
  }
  set isDisabled(value) {
    set(this.#isDisabled, value);
  }
  #snippetProps = tag(
    user_derived(() => {
      return {
        monthItems: this.monthItems,
        selectedMonthItem: this.monthItems.find((month) => strict_equals(month.value, this.currentMonth))
      };
    }),
    "CalendarMonthSelectState.snippetProps"
  );
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
  onchange(event) {
    if (this.isDisabled) return;
    const target = event.target;
    const month = parseInt(target.value, 10);
    if (!isNaN(month)) {
      this.root.opts.placeholder.current = this.root.opts.placeholder.current.set({ month });
    }
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      value: this.currentMonth,
      disabled: this.isDisabled,
      "data-disabled": getDataDisabled(this.isDisabled),
      [this.root.getBitsAttr("month-select")]: "",
      //
      onchange: this.onchange,
      ...this.attachment
    })),
    "CalendarMonthSelectState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var CalendarYearSelectState = class _CalendarYearSelectState {
  static create(opts) {
    return new _CalendarYearSelectState(opts, CalendarRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.onchange = this.onchange.bind(this);
    this.attachment = attachRef(this.opts.ref);
  }
  #years = tag(
    user_derived(() => {
      if (this.opts.years.current && this.opts.years.current.length) return this.opts.years.current;
      return this.root.defaultYears;
    }),
    "CalendarYearSelectState.years"
  );
  get years() {
    return get(this.#years);
  }
  set years(value) {
    set(this.#years, value);
  }
  #yearItems = tag(
    user_derived(() => {
      this.root.opts.locale.current;
      const yearFormat = this.opts.yearFormat.current;
      const localYears = [];
      for (const year of this.years) {
        const date = this.root.opts.placeholder.current.set({ year });
        let label;
        if (strict_equals(typeof yearFormat, "function")) {
          label = yearFormat(year);
        } else {
          label = this.root.formatter.custom(toDate(date), { year: yearFormat });
        }
        localYears.push({ value: year, label });
      }
      return localYears;
    }),
    "CalendarYearSelectState.yearItems"
  );
  get yearItems() {
    return get(this.#yearItems);
  }
  set yearItems(value) {
    set(this.#yearItems, value);
  }
  #currentYear = tag(user_derived(() => this.root.opts.placeholder.current.year), "CalendarYearSelectState.currentYear");
  get currentYear() {
    return get(this.#currentYear);
  }
  set currentYear(value) {
    set(this.#currentYear, value);
  }
  #isDisabled = tag(user_derived(() => this.root.opts.disabled.current || this.opts.disabled.current), "CalendarYearSelectState.isDisabled");
  get isDisabled() {
    return get(this.#isDisabled);
  }
  set isDisabled(value) {
    set(this.#isDisabled, value);
  }
  #snippetProps = tag(
    user_derived(() => {
      return {
        yearItems: this.yearItems,
        selectedYearItem: this.yearItems.find((year) => strict_equals(year.value, this.currentYear))
      };
    }),
    "CalendarYearSelectState.snippetProps"
  );
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
  onchange(event) {
    if (this.isDisabled) return;
    const target = event.target;
    const year = parseInt(target.value, 10);
    if (!isNaN(year)) {
      this.root.opts.placeholder.current = this.root.opts.placeholder.current.set({ year });
    }
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      value: this.currentYear,
      disabled: this.isDisabled,
      "data-disabled": getDataDisabled(this.isDisabled),
      [this.root.getBitsAttr("year-select")]: "",
      //
      onchange: this.onchange,
      ...this.attachment
    })),
    "CalendarYearSelectState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};

// node_modules/bits-ui/dist/bits/calendar/components/calendar.svelte
Calendar[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar.svelte";
var root_214 = add_locations(from_html(`<div><!></div>`), Calendar[FILENAME], [[128, 1]]);
function Calendar($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Calendar);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop3), placeholder = prop($$props, "placeholder", 15), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop3), weekdayFormat = prop($$props, "weekdayFormat", 3, "narrow"), pagedNavigation = prop($$props, "pagedNavigation", 3, false), isDateDisabled = prop($$props, "isDateDisabled", 3, () => false), isDateUnavailable = prop($$props, "isDateUnavailable", 3, () => false), fixedWeeks = prop($$props, "fixedWeeks", 3, false), numberOfMonths = prop($$props, "numberOfMonths", 3, 1), calendarLabel = prop($$props, "calendarLabel", 3, "Event"), disabled = prop($$props, "disabled", 3, false), readonly = prop($$props, "readonly", 3, false), minValue = prop($$props, "minValue", 3, void 0), maxValue = prop($$props, "maxValue", 3, void 0), preventDeselect = prop($$props, "preventDeselect", 3, false), disableDaysOutsideMonth = prop($$props, "disableDaysOutsideMonth", 3, true), initialFocus = prop($$props, "initialFocus", 3, false), monthFormat = prop($$props, "monthFormat", 3, "long"), yearFormat = prop($$props, "yearFormat", 3, "numeric"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "id",
      "ref",
      "value",
      "onValueChange",
      "placeholder",
      "onPlaceholderChange",
      "weekdayFormat",
      "weekStartsOn",
      "pagedNavigation",
      "isDateDisabled",
      "isDateUnavailable",
      "fixedWeeks",
      "numberOfMonths",
      "locale",
      "calendarLabel",
      "disabled",
      "readonly",
      "minValue",
      "maxValue",
      "preventDeselect",
      "type",
      "disableDaysOutsideMonth",
      "initialFocus",
      "maxDays",
      "monthFormat",
      "yearFormat"
    ],
    "restProps"
  );
  const defaultPlaceholder = getDefaultDate({ defaultValue: value() });
  function handleDefaultPlaceholder() {
    if (strict_equals(placeholder(), void 0, false)) return;
    placeholder(defaultPlaceholder);
  }
  handleDefaultPlaceholder();
  watch.pre(() => placeholder(), () => {
    handleDefaultPlaceholder();
  });
  function handleDefaultValue() {
    if (strict_equals(value(), void 0, false)) return;
    value(strict_equals($$props.type, "single") ? void 0 : []);
  }
  handleDefaultValue();
  watch.pre(() => value(), () => {
    handleDefaultValue();
  });
  const rootState = CalendarRootState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    weekdayFormat: box.with(() => weekdayFormat()),
    weekStartsOn: box.with(() => $$props.weekStartsOn),
    pagedNavigation: box.with(() => pagedNavigation()),
    isDateDisabled: box.with(() => isDateDisabled()),
    isDateUnavailable: box.with(() => isDateUnavailable()),
    fixedWeeks: box.with(() => fixedWeeks()),
    numberOfMonths: box.with(() => numberOfMonths()),
    locale: resolveLocaleProp(() => $$props.locale),
    calendarLabel: box.with(() => calendarLabel()),
    readonly: box.with(() => readonly()),
    disabled: box.with(() => disabled()),
    minValue: box.with(() => minValue()),
    maxValue: box.with(() => maxValue()),
    disableDaysOutsideMonth: box.with(() => disableDaysOutsideMonth()),
    initialFocus: box.with(() => initialFocus()),
    maxDays: box.with(() => $$props.maxDays),
    placeholder: box.with(() => placeholder(), (v) => {
      placeholder(v);
      onPlaceholderChange()(v);
    }),
    preventDeselect: box.with(() => preventDeselect()),
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    type: box.with(() => $$props.type),
    monthFormat: box.with(() => monthFormat()),
    yearFormat: box.with(() => yearFormat()),
    defaultPlaceholder
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => ({ props: get(mergedProps), ...rootState.snippetProps }));
        add_svelte_meta(() => snippet(node_1, () => $$props.child, () => get($0)), "render", Calendar, 126, 1);
      }
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_214();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => rootState.snippetProps), "render", Calendar, 129, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Calendar,
      125,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar = hmr(Calendar, () => Calendar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar[HMR].source;
    set(Calendar[HMR].source, module.default[HMR].original);
  });
}
var calendar_default = Calendar;

// node_modules/bits-ui/dist/bits/calendar/components/calendar-day.svelte
Calendar_day[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-day.svelte";
var root_215 = add_locations(from_html(`<div><!></div>`), Calendar_day[FILENAME], [[34, 1]]);
function Calendar_day($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Calendar_day);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const dayState = CalendarDayState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, dayState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => ({ props: get(mergedProps), ...dayState.snippetProps }));
        add_svelte_meta(() => snippet(node_1, () => $$props.child, () => get($0)), "render", Calendar_day, 29, 1);
      }
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2) => {
      var div = root_215();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop, () => dayState.snippetProps), "render", Calendar_day, 36, 3);
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, dayState.cell.opts.date.current.day));
          append($$anchor3, text2);
        };
        add_svelte_meta(
          () => if_block(node_2, ($$render) => {
            if ($$props.children) $$render(consequent_1);
            else $$render(alternate, false);
          }),
          "if",
          Calendar_day,
          35,
          2
        );
      }
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate_1, false);
      }),
      "if",
      Calendar_day,
      28,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_day = hmr(Calendar_day, () => Calendar_day[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_day[HMR].source;
    set(Calendar_day[HMR].source, module.default[HMR].original);
  });
}
var calendar_day_default = Calendar_day;

// node_modules/bits-ui/dist/bits/calendar/components/calendar-grid.svelte
Calendar_grid[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-grid.svelte";
var root_216 = add_locations(from_html(`<table><!></table>`), Calendar_grid[FILENAME], [[31, 1]]);
function Calendar_grid($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Calendar_grid);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const gridState = CalendarGridState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, gridState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Calendar_grid, 29, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var table = root_216();
      attribute_effect(table, () => ({ ...get(mergedProps) }));
      var node_2 = child(table);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Calendar_grid, 32, 2);
      reset(table);
      append($$anchor2, table);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Calendar_grid,
      28,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_grid = hmr(Calendar_grid, () => Calendar_grid[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_grid[HMR].source;
    set(Calendar_grid[HMR].source, module.default[HMR].original);
  });
}
var calendar_grid_default = Calendar_grid;

// node_modules/bits-ui/dist/bits/calendar/components/calendar-grid-body.svelte
Calendar_grid_body[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-grid-body.svelte";
var root_217 = add_locations(from_html(`<tbody><!></tbody>`), Calendar_grid_body[FILENAME], [[31, 1]]);
function Calendar_grid_body($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Calendar_grid_body);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const gridBodyState = CalendarGridBodyState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, gridBodyState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Calendar_grid_body, 29, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var tbody = root_217();
      attribute_effect(tbody, () => ({ ...get(mergedProps) }));
      var node_2 = child(tbody);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Calendar_grid_body, 32, 2);
      reset(tbody);
      append($$anchor2, tbody);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Calendar_grid_body,
      28,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_grid_body = hmr(Calendar_grid_body, () => Calendar_grid_body[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_grid_body[HMR].source;
    set(Calendar_grid_body[HMR].source, module.default[HMR].original);
  });
}
var calendar_grid_body_default = Calendar_grid_body;

// node_modules/bits-ui/dist/bits/calendar/components/calendar-cell.svelte
Calendar_cell[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-cell.svelte";
var root_218 = add_locations(from_html(`<td><!></td>`), Calendar_cell[FILENAME], [[38, 1]]);
function Calendar_cell($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Calendar_cell);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id",
      "date",
      "month"
    ],
    "restProps"
  );
  const cellState = CalendarCellState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    date: box.with(() => $$props.date),
    month: box.with(() => $$props.month)
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, cellState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => ({ props: get(mergedProps), ...cellState.snippetProps }));
        add_svelte_meta(() => snippet(node_1, () => $$props.child, () => get($0)), "render", Calendar_cell, 33, 1);
      }
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var td = root_218();
      attribute_effect(td, () => ({ ...get(mergedProps) }));
      var node_2 = child(td);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => cellState.snippetProps), "render", Calendar_cell, 39, 2);
      reset(td);
      append($$anchor2, td);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Calendar_cell,
      32,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_cell = hmr(Calendar_cell, () => Calendar_cell[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_cell[HMR].source;
    set(Calendar_cell[HMR].source, module.default[HMR].original);
  });
}
var calendar_cell_default = Calendar_cell;

// node_modules/bits-ui/dist/bits/calendar/components/calendar-grid-head.svelte
Calendar_grid_head[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-grid-head.svelte";
var root_219 = add_locations(from_html(`<thead><!></thead>`), Calendar_grid_head[FILENAME], [[31, 1]]);
function Calendar_grid_head($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Calendar_grid_head);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const gridHeadState = CalendarGridHeadState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, gridHeadState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Calendar_grid_head, 29, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var thead = root_219();
      attribute_effect(thead, () => ({ ...get(mergedProps) }));
      var node_2 = child(thead);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Calendar_grid_head, 32, 2);
      reset(thead);
      append($$anchor2, thead);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Calendar_grid_head,
      28,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_grid_head = hmr(Calendar_grid_head, () => Calendar_grid_head[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_grid_head[HMR].source;
    set(Calendar_grid_head[HMR].source, module.default[HMR].original);
  });
}
var calendar_grid_head_default = Calendar_grid_head;

// node_modules/bits-ui/dist/bits/calendar/components/calendar-head-cell.svelte
Calendar_head_cell[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-head-cell.svelte";
var root_220 = add_locations(from_html(`<th><!></th>`), Calendar_head_cell[FILENAME], [[31, 1]]);
function Calendar_head_cell($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Calendar_head_cell);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const headCellState = CalendarHeadCellState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, headCellState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Calendar_head_cell, 29, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var th = root_220();
      attribute_effect(th, () => ({ ...get(mergedProps) }));
      var node_2 = child(th);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Calendar_head_cell, 32, 2);
      reset(th);
      append($$anchor2, th);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Calendar_head_cell,
      28,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_head_cell = hmr(Calendar_head_cell, () => Calendar_head_cell[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_head_cell[HMR].source;
    set(Calendar_head_cell[HMR].source, module.default[HMR].original);
  });
}
var calendar_head_cell_default = Calendar_head_cell;

// node_modules/bits-ui/dist/bits/calendar/components/calendar-grid-row.svelte
Calendar_grid_row[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-grid-row.svelte";
var root_221 = add_locations(from_html(`<tr><!></tr>`), Calendar_grid_row[FILENAME], [[31, 1]]);
function Calendar_grid_row($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Calendar_grid_row);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const gridRowState = CalendarGridRowState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, gridRowState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Calendar_grid_row, 29, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var tr = root_221();
      attribute_effect(tr, () => ({ ...get(mergedProps) }));
      var node_2 = child(tr);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Calendar_grid_row, 32, 2);
      reset(tr);
      append($$anchor2, tr);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Calendar_grid_row,
      28,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_grid_row = hmr(Calendar_grid_row, () => Calendar_grid_row[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_grid_row[HMR].source;
    set(Calendar_grid_row[HMR].source, module.default[HMR].original);
  });
}
var calendar_grid_row_default = Calendar_grid_row;

// node_modules/bits-ui/dist/bits/calendar/components/calendar-header.svelte
Calendar_header[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-header.svelte";
var root_222 = add_locations(from_html(`<header><!></header>`), Calendar_header[FILENAME], [[31, 1]]);
function Calendar_header($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Calendar_header);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const headerState = CalendarHeaderState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, headerState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Calendar_header, 29, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var header = root_222();
      attribute_effect(header, () => ({ ...get(mergedProps) }));
      var node_2 = child(header);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Calendar_header, 32, 2);
      reset(header);
      append($$anchor2, header);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Calendar_header,
      28,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_header = hmr(Calendar_header, () => Calendar_header[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_header[HMR].source;
    set(Calendar_header[HMR].source, module.default[HMR].original);
  });
}
var calendar_header_default = Calendar_header;

// node_modules/bits-ui/dist/bits/calendar/components/calendar-heading.svelte
Calendar_heading[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-heading.svelte";
var root_223 = add_locations(from_html(`<div><!></div>`), Calendar_heading[FILENAME], [[31, 1]]);
function Calendar_heading($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Calendar_heading);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const headingState = CalendarHeadingState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, headingState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => snippet(node_1, () => $$props.child, () => ({
          props: get(mergedProps),
          headingValue: headingState.root.headingValue
        })),
        "render",
        Calendar_heading,
        29,
        1
      );
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2) => {
      var div = root_223();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop, () => ({ headingValue: headingState.root.headingValue })), "render", Calendar_heading, 33, 3);
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, headingState.root.headingValue));
          append($$anchor3, text2);
        };
        add_svelte_meta(
          () => if_block(node_2, ($$render) => {
            if ($$props.children) $$render(consequent_1);
            else $$render(alternate, false);
          }),
          "if",
          Calendar_heading,
          32,
          2
        );
      }
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate_1, false);
      }),
      "if",
      Calendar_heading,
      28,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_heading = hmr(Calendar_heading, () => Calendar_heading[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_heading[HMR].source;
    set(Calendar_heading[HMR].source, module.default[HMR].original);
  });
}
var calendar_heading_default = Calendar_heading;

// node_modules/bits-ui/dist/bits/calendar/components/calendar-month-select.svelte
Calendar_month_select[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-month-select.svelte";
var root_5 = add_locations(from_html(`<option> </option>`), Calendar_month_select[FILENAME], [[45, 4]]);
var root_224 = add_locations(from_html(`<select><!></select>`), Calendar_month_select[FILENAME], [[40, 1]]);
function Calendar_month_select($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Calendar_month_select);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), months = prop($$props, "months", 19, () => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]), monthFormat = prop($$props, "monthFormat", 3, "long"), disabled = prop($$props, "disabled", 3, false), ariaLabel = prop($$props, "aria-label", 3, "Select a month"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id",
      "months",
      "monthFormat",
      "disabled",
      "aria-label"
    ],
    "restProps"
  );
  const monthSelectState = CalendarMonthSelectState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    months: box.with(() => months()),
    monthFormat: box.with(() => monthFormat()),
    disabled: box.with(() => Boolean(disabled()))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, monthSelectState.props, { "aria-label": ariaLabel() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => ({ props: get(mergedProps), ...monthSelectState.snippetProps }));
        add_svelte_meta(() => snippet(node_1, () => $$props.child, () => get($0)), "render", Calendar_month_select, 38, 1);
      }
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2) => {
      var select = root_224();
      attribute_effect(select, () => ({ ...get(mergedProps) }));
      var node_2 = child(select);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop, () => monthSelectState.snippetProps), "render", Calendar_month_select, 42, 3);
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          validate_each_keys(() => monthSelectState.monthItems, (month) => month.value);
          add_svelte_meta(
            () => each(node_4, 17, () => monthSelectState.monthItems, (month) => month.value, ($$anchor4, month) => {
              var option = root_5();
              var text2 = child(option, true);
              reset(option);
              var option_value = {};
              template_effect(() => {
                set_selected(option, strict_equals(get(month).value, monthSelectState.currentMonth));
                set_text(text2, get(month).label);
                if (option_value !== (option_value = get(month).value)) {
                  option.value = (option.__value = get(month).value) ?? "";
                }
              });
              append($$anchor4, option);
            }),
            "each",
            Calendar_month_select,
            44,
            3
          );
          append($$anchor3, fragment_3);
        };
        add_svelte_meta(
          () => if_block(node_2, ($$render) => {
            if ($$props.children) $$render(consequent_1);
            else $$render(alternate, false);
          }),
          "if",
          Calendar_month_select,
          41,
          2
        );
      }
      reset(select);
      append($$anchor2, select);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate_1, false);
      }),
      "if",
      Calendar_month_select,
      37,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_month_select = hmr(Calendar_month_select, () => Calendar_month_select[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_month_select[HMR].source;
    set(Calendar_month_select[HMR].source, module.default[HMR].original);
  });
}
var calendar_month_select_default = Calendar_month_select;

// node_modules/bits-ui/dist/bits/calendar/components/calendar-next-button.svelte
Calendar_next_button[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-next-button.svelte";
var root_225 = add_locations(from_html(`<button><!></button>`), Calendar_next_button[FILENAME], [[33, 1]]);
function Calendar_next_button($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Calendar_next_button);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), tabindex = prop($$props, "tabindex", 3, 0), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "tabindex"
    ],
    "restProps"
  );
  const nextButtonState = CalendarNextButtonState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, nextButtonState.props, { tabindex: tabindex() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Calendar_next_button, 31, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_225();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Calendar_next_button, 34, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Calendar_next_button,
      30,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_next_button = hmr(Calendar_next_button, () => Calendar_next_button[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_next_button[HMR].source;
    set(Calendar_next_button[HMR].source, module.default[HMR].original);
  });
}
var calendar_next_button_default = Calendar_next_button;

// node_modules/bits-ui/dist/bits/calendar/components/calendar-prev-button.svelte
Calendar_prev_button[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-prev-button.svelte";
var root_226 = add_locations(from_html(`<button><!></button>`), Calendar_prev_button[FILENAME], [[33, 1]]);
function Calendar_prev_button($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Calendar_prev_button);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), tabindex = prop($$props, "tabindex", 3, 0), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "tabindex"
    ],
    "restProps"
  );
  const prevButtonState = CalendarPrevButtonState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, prevButtonState.props, { tabindex: tabindex() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Calendar_prev_button, 31, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_226();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Calendar_prev_button, 34, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Calendar_prev_button,
      30,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_prev_button = hmr(Calendar_prev_button, () => Calendar_prev_button[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_prev_button[HMR].source;
    set(Calendar_prev_button[HMR].source, module.default[HMR].original);
  });
}
var calendar_prev_button_default = Calendar_prev_button;

// node_modules/bits-ui/dist/bits/calendar/components/calendar-year-select.svelte
Calendar_year_select[FILENAME] = "node_modules/bits-ui/dist/bits/calendar/components/calendar-year-select.svelte";
var root_52 = add_locations(from_html(`<option> </option>`), Calendar_year_select[FILENAME], [[45, 4]]);
var root_227 = add_locations(from_html(`<select><!></select>`), Calendar_year_select[FILENAME], [[40, 1]]);
function Calendar_year_select($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Calendar_year_select);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), yearFormat = prop($$props, "yearFormat", 3, "numeric"), disabled = prop($$props, "disabled", 3, false), ariaLabel = prop($$props, "aria-label", 3, "Select a year"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id",
      "years",
      "yearFormat",
      "disabled",
      "aria-label"
    ],
    "restProps"
  );
  const yearSelectState = CalendarYearSelectState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    years: box.with(() => $$props.years),
    yearFormat: box.with(() => yearFormat()),
    disabled: box.with(() => Boolean(disabled()))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, yearSelectState.props, { "aria-label": ariaLabel() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => ({ props: get(mergedProps), ...yearSelectState.snippetProps }));
        add_svelte_meta(() => snippet(node_1, () => $$props.child, () => get($0)), "render", Calendar_year_select, 38, 1);
      }
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2) => {
      var select = root_227();
      attribute_effect(select, () => ({ ...get(mergedProps) }));
      var node_2 = child(select);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop, () => yearSelectState.snippetProps), "render", Calendar_year_select, 42, 3);
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          validate_each_keys(() => yearSelectState.yearItems, (year) => year.value);
          add_svelte_meta(
            () => each(node_4, 17, () => yearSelectState.yearItems, (year) => year.value, ($$anchor4, year) => {
              var option = root_52();
              var text2 = child(option, true);
              reset(option);
              var option_value = {};
              template_effect(() => {
                set_selected(option, strict_equals(get(year).value, yearSelectState.currentYear));
                set_text(text2, get(year).label);
                if (option_value !== (option_value = get(year).value)) {
                  option.value = (option.__value = get(year).value) ?? "";
                }
              });
              append($$anchor4, option);
            }),
            "each",
            Calendar_year_select,
            44,
            3
          );
          append($$anchor3, fragment_3);
        };
        add_svelte_meta(
          () => if_block(node_2, ($$render) => {
            if ($$props.children) $$render(consequent_1);
            else $$render(alternate, false);
          }),
          "if",
          Calendar_year_select,
          41,
          2
        );
      }
      reset(select);
      append($$anchor2, select);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate_1, false);
      }),
      "if",
      Calendar_year_select,
      37,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Calendar_year_select = hmr(Calendar_year_select, () => Calendar_year_select[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Calendar_year_select[HMR].source;
    set(Calendar_year_select[HMR].source, module.default[HMR].original);
  });
}
var calendar_year_select_default = Calendar_year_select;

// node_modules/bits-ui/dist/bits/checkbox/exports.js
var exports_exports7 = {};
__export(exports_exports7, {
  Group: () => checkbox_group_default,
  GroupLabel: () => checkbox_group_label_default,
  Root: () => checkbox_default
});

// node_modules/bits-ui/dist/bits/checkbox/checkbox.svelte.js
var checkboxAttrs = createBitsAttrs({
  component: "checkbox",
  parts: ["root", "group", "group-label", "input"]
});
var CheckboxGroupContext = new Context("Checkbox.Group");
var CheckboxGroupState = class _CheckboxGroupState {
  static create(opts) {
    return CheckboxGroupContext.set(new _CheckboxGroupState(opts));
  }
  opts;
  attachment;
  #labelId = tag(state(void 0), "CheckboxGroupState.labelId");
  get labelId() {
    return get(this.#labelId);
  }
  set labelId(value) {
    set(this.#labelId, value, true);
  }
  constructor(opts) {
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
  }
  addValue(checkboxValue) {
    if (!checkboxValue) return;
    if (!this.opts.value.current.includes(checkboxValue)) {
      const newValue = [...snapshot(this.opts.value.current), checkboxValue];
      this.opts.value.current = newValue;
      if (arraysAreEqual(this.opts.value.current, newValue)) return;
      this.opts.onValueChange.current(newValue);
    }
  }
  removeValue(checkboxValue) {
    if (!checkboxValue) return;
    const index = this.opts.value.current.indexOf(checkboxValue);
    if (strict_equals(index, -1)) return;
    const newValue = this.opts.value.current.filter((v) => strict_equals(v, checkboxValue, false));
    this.opts.value.current = newValue;
    if (arraysAreEqual(this.opts.value.current, newValue)) return;
    this.opts.onValueChange.current(newValue);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "group",
      "aria-labelledby": this.labelId,
      "data-disabled": getDataDisabled(this.opts.disabled.current),
      [checkboxAttrs.group]: "",
      ...this.attachment
    })),
    "CheckboxGroupState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var CheckboxGroupLabelState = class _CheckboxGroupLabelState {
  static create(opts) {
    return new _CheckboxGroupLabelState(opts, CheckboxGroupContext.get());
  }
  opts;
  group;
  attachment;
  constructor(opts, group) {
    this.opts = opts;
    this.group = group;
    this.group.labelId = this.opts.id.current;
    this.attachment = attachRef(this.opts.ref);
    watch.pre(() => this.opts.id.current, (id) => {
      this.group.labelId = id;
    });
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "data-disabled": getDataDisabled(this.group.opts.disabled.current),
      [checkboxAttrs["group-label"]]: "",
      ...this.attachment
    })),
    "CheckboxGroupLabelState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var CheckboxRootContext = new Context("Checkbox.Root");
var CheckboxRootState = class _CheckboxRootState {
  static create(opts, group = null) {
    return CheckboxRootContext.set(new _CheckboxRootState(opts, group));
  }
  opts;
  group;
  #trueName = tag(
    user_derived(() => {
      if (this.group && this.group.opts.name.current) {
        return this.group.opts.name.current;
      } else {
        return this.opts.name.current;
      }
    }),
    "CheckboxRootState.trueName"
  );
  get trueName() {
    return get(this.#trueName);
  }
  set trueName(value) {
    set(this.#trueName, value);
  }
  #trueRequired = tag(
    user_derived(() => {
      if (this.group && this.group.opts.required.current) {
        return true;
      }
      return this.opts.required.current;
    }),
    "CheckboxRootState.trueRequired"
  );
  get trueRequired() {
    return get(this.#trueRequired);
  }
  set trueRequired(value) {
    set(this.#trueRequired, value);
  }
  #trueDisabled = tag(
    user_derived(() => {
      if (this.group && this.group.opts.disabled.current) {
        return true;
      }
      return this.opts.disabled.current;
    }),
    "CheckboxRootState.trueDisabled"
  );
  get trueDisabled() {
    return get(this.#trueDisabled);
  }
  set trueDisabled(value) {
    set(this.#trueDisabled, value);
  }
  attachment;
  constructor(opts, group) {
    this.opts = opts;
    this.group = group;
    this.attachment = attachRef(this.opts.ref);
    this.onkeydown = this.onkeydown.bind(this);
    this.onclick = this.onclick.bind(this);
    watch.pre(
      [
        () => snapshot(this.group?.opts.value.current),
        () => this.opts.value.current
      ],
      ([groupValue, value]) => {
        if (!groupValue || !value) return;
        this.opts.checked.current = groupValue.includes(value);
      }
    );
    watch.pre(() => this.opts.checked.current, (checked) => {
      if (!this.group) return;
      if (checked) {
        this.group?.addValue(this.opts.value.current);
      } else {
        this.group?.removeValue(this.opts.value.current);
      }
    });
  }
  onkeydown(e) {
    if (this.opts.disabled.current) return;
    if (strict_equals(e.key, kbd_constants_exports.ENTER)) e.preventDefault();
    if (strict_equals(e.key, kbd_constants_exports.SPACE)) {
      e.preventDefault();
      this.#toggle();
    }
  }
  #toggle() {
    if (this.opts.indeterminate.current) {
      this.opts.indeterminate.current = false;
      this.opts.checked.current = true;
    } else {
      this.opts.checked.current = !this.opts.checked.current;
    }
  }
  onclick(e) {
    if (this.opts.disabled.current) return;
    e.preventDefault();
    this.#toggle();
  }
  #snippetProps = tag(
    user_derived(() => ({
      checked: this.opts.checked.current,
      indeterminate: this.opts.indeterminate.current
    })),
    "CheckboxRootState.snippetProps"
  );
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "checkbox",
      type: this.opts.type.current,
      disabled: this.trueDisabled,
      "aria-checked": getAriaChecked(this.opts.checked.current, this.opts.indeterminate.current),
      "aria-required": getAriaRequired(this.trueRequired),
      "data-disabled": getDataDisabled(this.trueDisabled),
      "data-state": getCheckboxDataState(this.opts.checked.current, this.opts.indeterminate.current),
      [checkboxAttrs.root]: "",
      onclick: this.onclick,
      onkeydown: this.onkeydown,
      ...this.attachment
    })),
    "CheckboxRootState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var CheckboxInputState = class _CheckboxInputState {
  static create() {
    return new _CheckboxInputState(CheckboxRootContext.get());
  }
  root;
  #trueChecked = tag(
    user_derived(() => {
      if (!this.root.group) return this.root.opts.checked.current;
      if (strict_equals(this.root.opts.value.current, void 0, false) && this.root.group.opts.value.current.includes(this.root.opts.value.current)) {
        return true;
      }
      return false;
    }),
    "CheckboxInputState.trueChecked"
  );
  get trueChecked() {
    return get(this.#trueChecked);
  }
  set trueChecked(value) {
    set(this.#trueChecked, value);
  }
  #shouldRender = tag(user_derived(() => Boolean(this.root.trueName)), "CheckboxInputState.shouldRender");
  get shouldRender() {
    return get(this.#shouldRender);
  }
  set shouldRender(value) {
    set(this.#shouldRender, value);
  }
  constructor(root18) {
    this.root = root18;
  }
  #props = tag(
    user_derived(() => ({
      type: "checkbox",
      checked: strict_equals(this.root.opts.checked.current, true),
      disabled: this.root.trueDisabled,
      required: this.root.trueRequired,
      name: this.root.trueName,
      value: this.root.opts.value.current
    })),
    "CheckboxInputState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
function getCheckboxDataState(checked, indeterminate) {
  if (indeterminate) return "indeterminate";
  return checked ? "checked" : "unchecked";
}

// node_modules/bits-ui/dist/bits/utilities/hidden-input.svelte
Hidden_input[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/hidden-input.svelte";
var root_1 = add_locations(from_html(`<input/>`), Hidden_input[FILENAME], [[17, 1]]);
var root_228 = add_locations(from_html(`<input/>`), Hidden_input[FILENAME], [[19, 1]]);
function Hidden_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Hidden_input);
  let value = prop($$props, "value", 15), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "value"], "restProps");
  const mergedProps = tag(
    user_derived(() => mergeProps(restProps, {
      "aria-hidden": "true",
      tabindex: -1,
      style: srOnlyStylesString
    })),
    "mergedProps"
  );
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var input = root_1();
      remove_input_defaults(input);
      attribute_effect(input, () => ({ ...get(mergedProps), value: value() }));
      append($$anchor2, input);
    };
    var alternate = ($$anchor2) => {
      var input_1 = root_228();
      remove_input_defaults(input_1);
      attribute_effect(input_1, () => ({ ...get(mergedProps) }));
      bind_value(input_1, value);
      append($$anchor2, input_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (strict_equals(get(mergedProps).type, "checkbox")) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Hidden_input,
      16,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Hidden_input = hmr(Hidden_input, () => Hidden_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Hidden_input[HMR].source;
    set(Hidden_input[HMR].source, module.default[HMR].original);
  });
}
var hidden_input_default = Hidden_input;

// node_modules/bits-ui/dist/bits/checkbox/components/checkbox-input.svelte
Checkbox_input[FILENAME] = "node_modules/bits-ui/dist/bits/checkbox/components/checkbox-input.svelte";
function Checkbox_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Checkbox_input);
  const inputState = CheckboxInputState.create();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => hidden_input_default(node_1, spread_props(() => inputState.props)), "component", Checkbox_input, 9, 1, { componentTag: "HiddenInput" });
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (inputState.shouldRender) $$render(consequent);
      }),
      "if",
      Checkbox_input,
      8,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Checkbox_input = hmr(Checkbox_input, () => Checkbox_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Checkbox_input[HMR].source;
    set(Checkbox_input[HMR].source, module.default[HMR].original);
  });
}
var checkbox_input_default = Checkbox_input;

// node_modules/bits-ui/dist/bits/checkbox/components/checkbox.svelte
Checkbox[FILENAME] = "node_modules/bits-ui/dist/bits/checkbox/components/checkbox.svelte";
var root_229 = add_locations(from_html(`<button><!></button>`), Checkbox[FILENAME], [[90, 1]]);
var root2 = add_locations(from_html(`<!> <!>`, 1), Checkbox[FILENAME], []);
function Checkbox($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Checkbox);
  let checked = prop($$props, "checked", 15, false), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), required = prop($$props, "required", 3, false), name = prop($$props, "name", 3, void 0), value = prop($$props, "value", 3, "on"), id = prop($$props, "id", 19, () => createId(uid)), indeterminate = prop($$props, "indeterminate", 15, false), type = prop($$props, "type", 3, "button"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "checked",
      "ref",
      "onCheckedChange",
      "children",
      "disabled",
      "required",
      "name",
      "value",
      "id",
      "indeterminate",
      "onIndeterminateChange",
      "child",
      "type"
    ],
    "restProps"
  );
  const group = CheckboxGroupContext.getOr(null);
  if (group && value()) {
    if (group.opts.value.current.includes(value())) {
      checked(true);
    } else {
      checked(false);
    }
  }
  watch.pre(() => value(), () => {
    if (group && value()) {
      if (group.opts.value.current.includes(value())) {
        checked(true);
      } else {
        checked(false);
      }
    }
  });
  const rootState = CheckboxRootState.create(
    {
      checked: box.with(() => checked(), (v) => {
        checked(v);
        $$props.onCheckedChange?.(v);
      }),
      disabled: box.with(() => disabled() ?? false),
      required: box.with(() => required()),
      name: box.with(() => name()),
      value: box.with(() => value()),
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v) => ref(v)),
      indeterminate: box.with(() => indeterminate(), (v) => {
        indeterminate(v);
        $$props.onIndeterminateChange?.(v);
      }),
      type: box.with(() => type())
    },
    group
  );
  const mergedProps = tag(user_derived(() => mergeProps({ ...restProps }, rootState.props)), "mergedProps");
  var fragment = root2();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => ({ props: get(mergedProps), ...rootState.snippetProps }));
        add_svelte_meta(() => snippet(node_1, () => $$props.child, () => get($0)), "render", Checkbox, 85, 1);
      }
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_229();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => rootState.snippetProps), "render", Checkbox, 91, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Checkbox,
      84,
      0
    );
  }
  var node_3 = sibling(node, 2);
  add_svelte_meta(() => checkbox_input_default(node_3, {}), "component", Checkbox, 95, 0, { componentTag: "CheckboxInput" });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Checkbox = hmr(Checkbox, () => Checkbox[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Checkbox[HMR].source;
    set(Checkbox[HMR].source, module.default[HMR].original);
  });
}
var checkbox_default = Checkbox;

// node_modules/bits-ui/dist/bits/checkbox/components/checkbox-group.svelte
Checkbox_group[FILENAME] = "node_modules/bits-ui/dist/bits/checkbox/components/checkbox-group.svelte";
var root_230 = add_locations(from_html(`<div><!></div>`), Checkbox_group[FILENAME], [[50, 1]]);
function Checkbox_group($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Checkbox_group);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), value = prop($$props, "value", 31, () => tag_proxy(proxy([]), "value")), onValueChange = prop($$props, "onValueChange", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "value",
      "onValueChange",
      "name",
      "required",
      "disabled",
      "children",
      "child"
    ],
    "restProps"
  );
  const groupState = CheckboxGroupState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => Boolean($$props.disabled)),
    required: box.with(() => Boolean($$props.required)),
    name: box.with(() => $$props.name),
    value: box.with(() => snapshot(value()), (v) => {
      if (arraysAreEqual(value(), v)) return;
      value(snapshot(v));
      onValueChange()(v);
    }),
    onValueChange: box.with(() => onValueChange())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, groupState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Checkbox_group, 48, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_230();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Checkbox_group, 51, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Checkbox_group,
      47,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Checkbox_group = hmr(Checkbox_group, () => Checkbox_group[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Checkbox_group[HMR].source;
    set(Checkbox_group[HMR].source, module.default[HMR].original);
  });
}
var checkbox_group_default = Checkbox_group;

// node_modules/bits-ui/dist/bits/checkbox/components/checkbox-group-label.svelte
Checkbox_group_label[FILENAME] = "node_modules/bits-ui/dist/bits/checkbox/components/checkbox-group-label.svelte";
var root_231 = add_locations(from_html(`<span><!></span>`), Checkbox_group_label[FILENAME], [[31, 1]]);
function Checkbox_group_label($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Checkbox_group_label);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "child",
      "children"
    ],
    "restProps"
  );
  const labelState = CheckboxGroupLabelState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, labelState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Checkbox_group_label, 29, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_231();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Checkbox_group_label, 32, 2);
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Checkbox_group_label,
      28,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Checkbox_group_label = hmr(Checkbox_group_label, () => Checkbox_group_label[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Checkbox_group_label[HMR].source;
    set(Checkbox_group_label[HMR].source, module.default[HMR].original);
  });
}
var checkbox_group_label_default = Checkbox_group_label;

// node_modules/bits-ui/dist/bits/collapsible/exports.js
var exports_exports8 = {};
__export(exports_exports8, {
  Content: () => collapsible_content_default,
  Root: () => collapsible_default,
  Trigger: () => collapsible_trigger_default
});

// node_modules/bits-ui/dist/bits/collapsible/collapsible.svelte.js
var collapsibleAttrs = createBitsAttrs({
  component: "collapsible",
  parts: ["root", "content", "trigger"]
});
var CollapsibleRootContext = new Context("Collapsible.Root");
var CollapsibleRootState = class _CollapsibleRootState {
  static create(opts) {
    return CollapsibleRootContext.set(new _CollapsibleRootState(opts));
  }
  opts;
  attachment;
  #contentNode = tag(state(null), "CollapsibleRootState.contentNode");
  get contentNode() {
    return get(this.#contentNode);
  }
  set contentNode(value) {
    set(this.#contentNode, value, true);
  }
  #contentId = tag(state(void 0), "CollapsibleRootState.contentId");
  get contentId() {
    return get(this.#contentId);
  }
  set contentId(value) {
    set(this.#contentId, value, true);
  }
  constructor(opts) {
    this.opts = opts;
    this.toggleOpen = this.toggleOpen.bind(this);
    this.attachment = attachRef(this.opts.ref);
    new OpenChangeComplete({
      ref: box.with(() => this.contentNode),
      open: this.opts.open,
      onComplete: () => {
        this.opts.onOpenChangeComplete.current(this.opts.open.current);
      }
    });
  }
  toggleOpen() {
    this.opts.open.current = !this.opts.open.current;
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "data-state": getDataOpenClosed(this.opts.open.current),
      "data-disabled": getDataDisabled(this.opts.disabled.current),
      [collapsibleAttrs.root]: "",
      ...this.attachment
    })),
    "CollapsibleRootState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var CollapsibleContentState = class _CollapsibleContentState {
  static create(opts) {
    return new _CollapsibleContentState(opts, CollapsibleRootContext.get());
  }
  opts;
  root;
  attachment;
  #present = tag(user_derived(() => this.opts.forceMount.current || this.root.opts.open.current), "CollapsibleContentState.present");
  get present() {
    return get(this.#present);
  }
  set present(value) {
    set(this.#present, value);
  }
  #originalStyles;
  #isMountAnimationPrevented = tag(state(false), "CollapsibleContentState.#isMountAnimationPrevented");
  #width = tag(state(0), "CollapsibleContentState.#width");
  #height = tag(state(0), "CollapsibleContentState.#height");
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    set(this.#isMountAnimationPrevented, root18.opts.open.current, true);
    this.root.contentId = this.opts.id.current;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.contentNode = v);
    watch.pre(() => this.opts.id.current, (id) => {
      this.root.contentId = id;
    });
    user_pre_effect(() => {
      const rAF = requestAnimationFrame(() => {
        set(this.#isMountAnimationPrevented, false);
      });
      return () => {
        cancelAnimationFrame(rAF);
      };
    });
    watch([() => this.opts.ref.current, () => this.present], ([node]) => {
      if (!node) return;
      afterTick(() => {
        if (!this.opts.ref.current) return;
        this.#originalStyles = this.#originalStyles || {
          transitionDuration: node.style.transitionDuration,
          animationName: node.style.animationName
        };
        node.style.transitionDuration = "0s";
        node.style.animationName = "none";
        const rect = node.getBoundingClientRect();
        set(this.#height, rect.height, true);
        set(this.#width, rect.width, true);
        if (!get(this.#isMountAnimationPrevented)) {
          const { animationName, transitionDuration } = this.#originalStyles;
          node.style.transitionDuration = transitionDuration;
          node.style.animationName = animationName;
        }
      });
    });
  }
  #snippetProps = tag(user_derived(() => ({ open: this.root.opts.open.current })), "CollapsibleContentState.snippetProps");
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      style: {
        "--bits-collapsible-content-height": get(this.#height) ? `${get(this.#height)}px` : void 0,
        "--bits-collapsible-content-width": get(this.#width) ? `${get(this.#width)}px` : void 0
      },
      "data-state": getDataOpenClosed(this.root.opts.open.current),
      "data-disabled": getDataDisabled(this.root.opts.disabled.current),
      [collapsibleAttrs.content]: "",
      ...this.attachment
    })),
    "CollapsibleContentState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var CollapsibleTriggerState = class _CollapsibleTriggerState {
  static create(opts) {
    return new _CollapsibleTriggerState(opts, CollapsibleRootContext.get());
  }
  opts;
  root;
  attachment;
  #isDisabled = tag(user_derived(() => this.opts.disabled.current || this.root.opts.disabled.current), "CollapsibleTriggerState.#isDisabled");
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  onclick(e) {
    if (get(this.#isDisabled)) return;
    if (strict_equals(e.button, 0, false)) return e.preventDefault();
    this.root.toggleOpen();
  }
  onkeydown(e) {
    if (get(this.#isDisabled)) return;
    if (strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ENTER)) {
      e.preventDefault();
      this.root.toggleOpen();
    }
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      type: "button",
      disabled: get(this.#isDisabled),
      "aria-controls": this.root.contentId,
      "aria-expanded": getAriaExpanded(this.root.opts.open.current),
      "data-state": getDataOpenClosed(this.root.opts.open.current),
      "data-disabled": getDataDisabled(get(this.#isDisabled)),
      [collapsibleAttrs.trigger]: "",
      //
      onclick: this.onclick,
      onkeydown: this.onkeydown,
      ...this.attachment
    })),
    "CollapsibleTriggerState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};

// node_modules/bits-ui/dist/bits/collapsible/components/collapsible.svelte
Collapsible[FILENAME] = "node_modules/bits-ui/dist/bits/collapsible/components/collapsible.svelte";
var root_232 = add_locations(from_html(`<div><!></div>`), Collapsible[FILENAME], [[45, 1]]);
function Collapsible($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Collapsible);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), open = prop($$props, "open", 15, false), disabled = prop($$props, "disabled", 3, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "open",
      "disabled",
      "onOpenChange",
      "onOpenChangeComplete"
    ],
    "restProps"
  );
  const rootState = CollapsibleRootState.create({
    open: box.with(() => open(), (v) => {
      open(v);
      onOpenChange()(v);
    }),
    disabled: box.with(() => disabled()),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onOpenChangeComplete: box.with(() => onOpenChangeComplete())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Collapsible, 43, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_232();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Collapsible, 46, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Collapsible,
      42,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Collapsible = hmr(Collapsible, () => Collapsible[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Collapsible[HMR].source;
    set(Collapsible[HMR].source, module.default[HMR].original);
  });
}
var collapsible_default = Collapsible;

// node_modules/bits-ui/dist/bits/collapsible/components/collapsible-content.svelte
Collapsible_content[FILENAME] = "node_modules/bits-ui/dist/bits/collapsible/components/collapsible-content.svelte";
var root_33 = add_locations(from_html(`<div><!></div>`), Collapsible_content[FILENAME], [[40, 3]]);
function Collapsible_content($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Collapsible_content);
  let ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "ref",
      "forceMount",
      "children",
      "id"
    ],
    "restProps"
  );
  const contentState = CollapsibleContentState.create({
    id: box.with(() => id()),
    forceMount: box.with(() => forceMount()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  var fragment = comment();
  var node = first_child(fragment);
  {
    const presence = wrap_snippet(Collapsible_content, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let present = () => $$arg0?.().present;
      present();
      var fragment_1 = comment();
      const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props, { hidden: forceMount() ? void 0 : !present() })), "mergedProps");
      get(mergedProps);
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          {
            let $0 = user_derived(() => ({ ...contentState.snippetProps, props: get(mergedProps) }));
            add_svelte_meta(() => snippet(node_2, () => $$props.child, () => get($0)), "render", Collapsible_content, 35, 3);
          }
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var div = root_33();
          attribute_effect(div, () => ({ ...get(mergedProps) }));
          var node_3 = child(div);
          add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop), "render", Collapsible_content, 41, 4);
          reset(div);
          append($$anchor3, div);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if ($$props.child) $$render(consequent);
            else $$render(alternate, false);
          }),
          "if",
          Collapsible_content,
          34,
          2
        );
      }
      append($$anchor2, fragment_1);
    });
    add_svelte_meta(
      () => presence_layer_default(node, {
        forceMount: true,
        get open() {
          return contentState.present;
        },
        get ref() {
          return contentState.opts.ref;
        },
        presence,
        $$slots: { presence: true }
      }),
      "component",
      Collapsible_content,
      29,
      0,
      { componentTag: "PresenceLayer" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Collapsible_content = hmr(Collapsible_content, () => Collapsible_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Collapsible_content[HMR].source;
    set(Collapsible_content[HMR].source, module.default[HMR].original);
  });
}
var collapsible_content_default = Collapsible_content;

// node_modules/bits-ui/dist/bits/collapsible/components/collapsible-trigger.svelte
Collapsible_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/collapsible/components/collapsible-trigger.svelte";
var root_233 = add_locations(from_html(`<button><!></button>`), Collapsible_trigger[FILENAME], [[33, 1]]);
function Collapsible_trigger($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Collapsible_trigger);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id",
      "disabled"
    ],
    "restProps"
  );
  const triggerState = CollapsibleTriggerState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => disabled())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, triggerState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Collapsible_trigger, 31, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_233();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Collapsible_trigger, 34, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Collapsible_trigger,
      30,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Collapsible_trigger = hmr(Collapsible_trigger, () => Collapsible_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Collapsible_trigger[HMR].source;
    set(Collapsible_trigger[HMR].source, module.default[HMR].original);
  });
}
var collapsible_trigger_default = Collapsible_trigger;

// node_modules/bits-ui/dist/bits/combobox/exports.js
var exports_exports9 = {};
__export(exports_exports9, {
  Arrow: () => arrow_default,
  Content: () => select_content_default,
  ContentStatic: () => select_content_static_default,
  Group: () => select_group_default,
  GroupHeading: () => select_group_heading_default,
  Input: () => combobox_input_default,
  Item: () => select_item_default,
  Portal: () => portal_default,
  Root: () => combobox_default,
  ScrollDownButton: () => select_scroll_down_button_default,
  ScrollUpButton: () => select_scroll_up_button_default,
  Separator: () => separator_default,
  Trigger: () => combobox_trigger_default,
  Viewport: () => select_viewport_default
});

// node_modules/bits-ui/dist/internal/floating-svelte/floating-utils.svelte.js
function get3(valueOrGetValue) {
  return strict_equals(typeof valueOrGetValue, "function") ? valueOrGetValue() : valueOrGetValue;
}
function getDPR(element2) {
  if (strict_equals(typeof window, "undefined")) return 1;
  const win = element2.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element2, value) {
  const dpr = getDPR(element2);
  return Math.round(value * dpr) / dpr;
}
function getFloatingContentCSSVars(name) {
  return {
    [`--bits-${name}-content-transform-origin`]: `var(--bits-floating-transform-origin)`,
    [`--bits-${name}-content-available-width`]: `var(--bits-floating-available-width)`,
    [`--bits-${name}-content-available-height`]: `var(--bits-floating-available-height)`,
    [`--bits-${name}-anchor-width`]: `var(--bits-floating-anchor-width)`,
    [`--bits-${name}-anchor-height`]: `var(--bits-floating-anchor-height)`
  };
}

// node_modules/bits-ui/dist/internal/floating-svelte/use-floating.svelte.js
function useFloating(options) {
  const whileElementsMountedOption = options.whileElementsMounted;
  const openOption = tag(user_derived(() => get3(options.open) ?? true), "openOption");
  const middlewareOption = tag(user_derived(() => get3(options.middleware)), "middlewareOption");
  const transformOption = tag(user_derived(() => get3(options.transform) ?? true), "transformOption");
  const placementOption = tag(user_derived(() => get3(options.placement) ?? "bottom"), "placementOption");
  const strategyOption = tag(user_derived(() => get3(options.strategy) ?? "absolute"), "strategyOption");
  const sideOffsetOption = tag(user_derived(() => get3(options.sideOffset) ?? 0), "sideOffsetOption");
  const alignOffsetOption = tag(user_derived(() => get3(options.alignOffset) ?? 0), "alignOffsetOption");
  const reference = options.reference;
  let x = tag(state(0), "x");
  let y = tag(state(0), "y");
  const floating = box(null);
  let strategy = tag(state(proxy(get(strategyOption))), "strategy");
  let placement = tag(state(proxy(get(placementOption))), "placement");
  let middlewareData = tag(state(proxy({})), "middlewareData");
  let isPositioned = tag(state(false), "isPositioned");
  const floatingStyles = tag(
    user_derived(() => {
      const xVal = floating.current ? roundByDPR(floating.current, get(x)) : get(x);
      const yVal = floating.current ? roundByDPR(floating.current, get(y)) : get(y);
      if (get(transformOption)) {
        return {
          position: get(strategy),
          left: "0",
          top: "0",
          transform: `translate(${xVal}px, ${yVal}px)`,
          ...floating.current && getDPR(floating.current) >= 1.5 && { willChange: "transform" }
        };
      }
      return {
        position: get(strategy),
        left: `${xVal}px`,
        top: `${yVal}px`
      };
    }),
    "floatingStyles"
  );
  let whileElementsMountedCleanup;
  function update() {
    if (strict_equals(reference.current, null) || strict_equals(floating.current, null)) return;
    computePosition(reference.current, floating.current, {
      middleware: get(middlewareOption),
      placement: get(placementOption),
      strategy: get(strategyOption)
    }).then((position) => {
      if (!get(openOption) && strict_equals(get(x), 0, false) && strict_equals(get(y), 0, false)) {
        const maxExpectedOffset = Math.max(Math.abs(get(sideOffsetOption)), Math.abs(get(alignOffsetOption)), 15);
        if (position.x <= maxExpectedOffset && position.y <= maxExpectedOffset) return;
      }
      set(x, position.x, true);
      set(y, position.y, true);
      set(strategy, position.strategy, true);
      set(placement, position.placement, true);
      set(middlewareData, position.middlewareData, true);
      set(isPositioned, true);
    });
  }
  function cleanup() {
    if (strict_equals(typeof whileElementsMountedCleanup, "function")) {
      whileElementsMountedCleanup();
      whileElementsMountedCleanup = void 0;
    }
  }
  function attach() {
    cleanup();
    if (strict_equals(whileElementsMountedOption, void 0)) {
      update();
      return;
    }
    if (strict_equals(reference.current, null) || strict_equals(floating.current, null)) return;
    whileElementsMountedCleanup = whileElementsMountedOption(reference.current, floating.current, update);
  }
  function reset2() {
    if (!get(openOption)) {
      set(isPositioned, false);
    }
  }
  user_effect(update);
  user_effect(attach);
  user_effect(reset2);
  user_effect(() => cleanup);
  return {
    floating,
    reference,
    get strategy() {
      return get(strategy);
    },
    get placement() {
      return get(placement);
    },
    get middlewareData() {
      return get(middlewareData);
    },
    get isPositioned() {
      return get(isPositioned);
    },
    get floatingStyles() {
      return get(floatingStyles);
    },
    get update() {
      return update;
    }
  };
}

// node_modules/bits-ui/dist/bits/utilities/floating-layer/use-floating-layer.svelte.js
var OPPOSITE_SIDE = { top: "bottom", right: "left", bottom: "top", left: "right" };
var FloatingRootContext = new Context("Floating.Root");
var FloatingContentContext = new Context("Floating.Content");
var FloatingTooltipRootContext = new Context("Floating.Root");
var FloatingRootState = class _FloatingRootState {
  static create(tooltip = false) {
    return tooltip ? FloatingTooltipRootContext.set(new _FloatingRootState()) : FloatingRootContext.set(new _FloatingRootState());
  }
  anchorNode = box(null);
  customAnchorNode = box(null);
  triggerNode = box(null);
  constructor() {
    user_effect(() => {
      if (this.customAnchorNode.current) {
        if (strict_equals(typeof this.customAnchorNode.current, "string")) {
          this.anchorNode.current = document.querySelector(this.customAnchorNode.current);
        } else {
          this.anchorNode.current = this.customAnchorNode.current;
        }
      } else {
        this.anchorNode.current = this.triggerNode.current;
      }
    });
  }
};
var FloatingContentState = class _FloatingContentState {
  static create(opts, tooltip = false) {
    return tooltip ? FloatingContentContext.set(new _FloatingContentState(opts, FloatingTooltipRootContext.get())) : FloatingContentContext.set(new _FloatingContentState(opts, FloatingRootContext.get()));
  }
  opts;
  root;
  // nodes
  contentRef = box(null);
  wrapperRef = box(null);
  arrowRef = box(null);
  contentAttachment = attachRef(this.contentRef);
  wrapperAttachment = attachRef(this.wrapperRef);
  arrowAttachment = attachRef(this.arrowRef);
  // ids
  arrowId = box(useId());
  #transformedStyle = tag(
    user_derived(() => {
      if (strict_equals(typeof this.opts.style, "string")) return cssToStyleObj(this.opts.style);
      if (!this.opts.style) return {};
    }),
    "FloatingContentState.#transformedStyle"
  );
  #updatePositionStrategy = void 0;
  #arrowSize = new ElementSize(() => this.arrowRef.current ?? void 0);
  #arrowWidth = tag(user_derived(() => this.#arrowSize?.width ?? 0), "FloatingContentState.#arrowWidth");
  #arrowHeight = tag(user_derived(() => this.#arrowSize?.height ?? 0), "FloatingContentState.#arrowHeight");
  #desiredPlacement = tag(user_derived(() => this.opts.side?.current + (strict_equals(this.opts.align.current, "center", false) ? `-${this.opts.align.current}` : "")), "FloatingContentState.#desiredPlacement");
  #boundary = tag(
    user_derived(() => Array.isArray(this.opts.collisionBoundary.current) ? this.opts.collisionBoundary.current : [this.opts.collisionBoundary.current]),
    "FloatingContentState.#boundary"
  );
  #hasExplicitBoundaries = tag(user_derived(() => get(this.#boundary).length > 0), "FloatingContentState.hasExplicitBoundaries");
  get hasExplicitBoundaries() {
    return get(this.#hasExplicitBoundaries);
  }
  set hasExplicitBoundaries(value) {
    set(this.#hasExplicitBoundaries, value);
  }
  #detectOverflowOptions = tag(
    user_derived(() => ({
      padding: this.opts.collisionPadding.current,
      boundary: get(this.#boundary).filter(isNotNull),
      altBoundary: this.hasExplicitBoundaries
    })),
    "FloatingContentState.detectOverflowOptions"
  );
  get detectOverflowOptions() {
    return get(this.#detectOverflowOptions);
  }
  set detectOverflowOptions(value) {
    set(this.#detectOverflowOptions, value);
  }
  #availableWidth = tag(state(void 0), "FloatingContentState.#availableWidth");
  #availableHeight = tag(state(void 0), "FloatingContentState.#availableHeight");
  #anchorWidth = tag(state(void 0), "FloatingContentState.#anchorWidth");
  #anchorHeight = tag(state(void 0), "FloatingContentState.#anchorHeight");
  #middleware = tag(
    user_derived(() => [
      offset({
        mainAxis: this.opts.sideOffset.current + get(this.#arrowHeight),
        alignmentAxis: this.opts.alignOffset.current
      }),
      this.opts.avoidCollisions.current && shift({
        mainAxis: true,
        crossAxis: false,
        limiter: strict_equals(this.opts.sticky.current, "partial") ? limitShift() : void 0,
        ...this.detectOverflowOptions
      }),
      this.opts.avoidCollisions.current && flip({ ...this.detectOverflowOptions }),
      size({
        ...this.detectOverflowOptions,
        apply: ({ rects, availableWidth, availableHeight }) => {
          const { width: anchorWidth, height: anchorHeight } = rects.reference;
          set(this.#availableWidth, availableWidth, true);
          set(this.#availableHeight, availableHeight, true);
          set(this.#anchorWidth, anchorWidth, true);
          set(this.#anchorHeight, anchorHeight, true);
        }
      }),
      this.arrowRef.current && arrow({
        element: this.arrowRef.current,
        padding: this.opts.arrowPadding.current
      }),
      transformOrigin({
        arrowWidth: get(this.#arrowWidth),
        arrowHeight: get(this.#arrowHeight)
      }),
      this.opts.hideWhenDetached.current && hide({ strategy: "referenceHidden", ...this.detectOverflowOptions })
    ].filter(Boolean)),
    "FloatingContentState.middleware"
  );
  get middleware() {
    return get(this.#middleware);
  }
  set middleware(value) {
    set(this.#middleware, value);
  }
  floating;
  #placedSide = tag(user_derived(() => getSideFromPlacement(this.floating.placement)), "FloatingContentState.placedSide");
  get placedSide() {
    return get(this.#placedSide);
  }
  set placedSide(value) {
    set(this.#placedSide, value);
  }
  #placedAlign = tag(user_derived(() => getAlignFromPlacement(this.floating.placement)), "FloatingContentState.placedAlign");
  get placedAlign() {
    return get(this.#placedAlign);
  }
  set placedAlign(value) {
    set(this.#placedAlign, value);
  }
  #arrowX = tag(user_derived(() => this.floating.middlewareData.arrow?.x ?? 0), "FloatingContentState.arrowX");
  get arrowX() {
    return get(this.#arrowX);
  }
  set arrowX(value) {
    set(this.#arrowX, value);
  }
  #arrowY = tag(user_derived(() => this.floating.middlewareData.arrow?.y ?? 0), "FloatingContentState.arrowY");
  get arrowY() {
    return get(this.#arrowY);
  }
  set arrowY(value) {
    set(this.#arrowY, value);
  }
  #cannotCenterArrow = tag(user_derived(() => strict_equals(this.floating.middlewareData.arrow?.centerOffset, 0, false)), "FloatingContentState.cannotCenterArrow");
  get cannotCenterArrow() {
    return get(this.#cannotCenterArrow);
  }
  set cannotCenterArrow(value) {
    set(this.#cannotCenterArrow, value);
  }
  #contentZIndex = tag(state(), "FloatingContentState.contentZIndex");
  get contentZIndex() {
    return get(this.#contentZIndex);
  }
  set contentZIndex(value) {
    set(this.#contentZIndex, value, true);
  }
  #arrowBaseSide = tag(user_derived(() => OPPOSITE_SIDE[this.placedSide]), "FloatingContentState.arrowBaseSide");
  get arrowBaseSide() {
    return get(this.#arrowBaseSide);
  }
  set arrowBaseSide(value) {
    set(this.#arrowBaseSide, value);
  }
  #wrapperProps = tag(
    user_derived(() => ({
      id: this.opts.wrapperId.current,
      "data-bits-floating-content-wrapper": "",
      style: {
        ...this.floating.floatingStyles,
        transform: this.floating.isPositioned ? this.floating.floatingStyles.transform : "translate(0, -200%)",
        minWidth: "max-content",
        zIndex: this.contentZIndex,
        "--bits-floating-transform-origin": `${this.floating.middlewareData.transformOrigin?.x} ${this.floating.middlewareData.transformOrigin?.y}`,
        "--bits-floating-available-width": `${get(this.#availableWidth)}px`,
        "--bits-floating-available-height": `${get(this.#availableHeight)}px`,
        "--bits-floating-anchor-width": `${get(this.#anchorWidth)}px`,
        "--bits-floating-anchor-height": `${get(this.#anchorHeight)}px`,
        ...this.floating.middlewareData.hide?.referenceHidden && { visibility: "hidden", "pointer-events": "none" },
        ...get(this.#transformedStyle)
      },
      dir: this.opts.dir.current,
      ...this.wrapperAttachment
    })),
    "FloatingContentState.wrapperProps"
  );
  get wrapperProps() {
    return get(this.#wrapperProps);
  }
  set wrapperProps(value) {
    set(this.#wrapperProps, value);
  }
  #props = tag(
    user_derived(() => ({
      "data-side": this.placedSide,
      "data-align": this.placedAlign,
      style: styleToString({ ...get(this.#transformedStyle) }),
      ...this.contentAttachment
    })),
    "FloatingContentState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
  #arrowStyle = tag(
    user_derived(() => ({
      position: "absolute",
      left: this.arrowX ? `${this.arrowX}px` : void 0,
      top: this.arrowY ? `${this.arrowY}px` : void 0,
      [this.arrowBaseSide]: 0,
      "transform-origin": { top: "", right: "0 0", bottom: "center 0", left: "100% 0" }[this.placedSide],
      transform: {
        top: "translateY(100%)",
        right: "translateY(50%) rotate(90deg) translateX(-50%)",
        bottom: "rotate(180deg)",
        left: "translateY(50%) rotate(-90deg) translateX(50%)"
      }[this.placedSide],
      visibility: this.cannotCenterArrow ? "hidden" : void 0
    })),
    "FloatingContentState.arrowStyle"
  );
  get arrowStyle() {
    return get(this.#arrowStyle);
  }
  set arrowStyle(value) {
    set(this.#arrowStyle, value);
  }
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    if (opts.customAnchor) {
      this.root.customAnchorNode.current = opts.customAnchor.current;
    }
    watch(() => opts.customAnchor.current, (customAnchor) => {
      this.root.customAnchorNode.current = customAnchor;
    });
    this.floating = useFloating({
      strategy: () => this.opts.strategy.current,
      placement: () => get(this.#desiredPlacement),
      middleware: () => this.middleware,
      reference: this.root.anchorNode,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: strict_equals(this.#updatePositionStrategy?.current, "always")
        });
        return cleanup;
      },
      open: () => this.opts.enabled.current,
      sideOffset: () => this.opts.sideOffset.current,
      alignOffset: () => this.opts.alignOffset.current
    });
    user_effect(() => {
      if (!this.floating.isPositioned) return;
      this.opts.onPlaced?.current();
    });
    watch(() => this.contentRef.current, (contentNode) => {
      if (!contentNode) return;
      const win = getWindow(contentNode);
      this.contentZIndex = win.getComputedStyle(contentNode).zIndex;
    });
    user_effect(() => {
      this.floating.floating.current = this.wrapperRef.current;
    });
  }
};
var FloatingArrowState = class _FloatingArrowState {
  static create(opts) {
    return new _FloatingArrowState(opts, FloatingContentContext.get());
  }
  opts;
  content;
  constructor(opts, content) {
    this.opts = opts;
    this.content = content;
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      style: this.content.arrowStyle,
      "data-side": this.content.placedSide,
      ...this.content.arrowAttachment
    })),
    "FloatingArrowState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var FloatingAnchorState = class _FloatingAnchorState {
  static create(opts, tooltip = false) {
    return tooltip ? new _FloatingAnchorState(opts, FloatingTooltipRootContext.get()) : new _FloatingAnchorState(opts, FloatingRootContext.get());
  }
  opts;
  root;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    if (opts.virtualEl && opts.virtualEl.current) {
      root18.triggerNode = box.from(opts.virtualEl.current);
    } else {
      root18.triggerNode = opts.ref;
    }
  }
};
function transformOrigin(options) {
  return {
    name: "transformOrigin",
    options,
    fn(data) {
      const { placement, rects, middlewareData } = data;
      const cannotCenterArrow = strict_equals(middlewareData.arrow?.centerOffset, 0, false);
      const isArrowHidden = cannotCenterArrow;
      const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
      const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
      const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
      const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
      const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;
      const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;
      let x = "";
      let y = "";
      if (strict_equals(placedSide, "bottom")) {
        x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y = `${-arrowHeight}px`;
      } else if (strict_equals(placedSide, "top")) {
        x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y = `${rects.floating.height + arrowHeight}px`;
      } else if (strict_equals(placedSide, "right")) {
        x = `${-arrowHeight}px`;
        y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      } else if (strict_equals(placedSide, "left")) {
        x = `${rects.floating.width + arrowHeight}px`;
        y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      }
      return { data: { x, y } };
    }
  };
}
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
function getSideFromPlacement(placement) {
  return getSideAndAlignFromPlacement(placement)[0];
}
function getAlignFromPlacement(placement) {
  return getSideAndAlignFromPlacement(placement)[1];
}

// node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer.svelte
Floating_layer[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer.svelte";
function Floating_layer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Floating_layer);
  let tooltip = prop($$props, "tooltip", 3, false);
  FloatingRootState.create(tooltip());
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop), "render", Floating_layer, 10, 0);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Floating_layer = hmr(Floating_layer, () => Floating_layer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Floating_layer[HMR].source;
    set(Floating_layer[HMR].source, module.default[HMR].original);
  });
}
var floating_layer_default = Floating_layer;

// node_modules/bits-ui/dist/internal/box-auto-reset.svelte.js
var defaultOptions = { afterMs: 1e4, onChange: noop3 };
function boxAutoReset(defaultValue, options) {
  const { afterMs, onChange, getWindow: getWindow2 } = { ...defaultOptions, ...options };
  let timeout = null;
  let value = tag(state(proxy(defaultValue)), "value");
  function resetAfter() {
    return getWindow2().setTimeout(
      () => {
        set(value, defaultValue, true);
        onChange?.(defaultValue);
      },
      afterMs
    );
  }
  user_effect(() => {
    return () => {
      if (timeout) getWindow2().clearTimeout(timeout);
    };
  });
  return box.with(() => get(value), (v) => {
    set(value, v, true);
    onChange?.(v);
    if (timeout) getWindow2().clearTimeout(timeout);
    timeout = resetAfter();
  });
}

// node_modules/bits-ui/dist/internal/data-typeahead.svelte.js
var DataTypeahead = class {
  #opts;
  #candidateValues = tag(user_derived(() => this.#opts.candidateValues()), "DataTypeahead.#candidateValues");
  #search;
  constructor(opts) {
    this.#opts = opts;
    this.#search = boxAutoReset("", { afterMs: 1e3, getWindow: this.#opts.getWindow });
    this.handleTypeaheadSearch = this.handleTypeaheadSearch.bind(this);
    this.resetTypeahead = this.resetTypeahead.bind(this);
  }
  handleTypeaheadSearch(key2) {
    if (!this.#opts.enabled() || !get(this.#candidateValues).length) return;
    this.#search.current = this.#search.current + key2;
    const currentItem = this.#opts.getCurrentItem();
    const currentMatch = get(this.#candidateValues).find((item) => strict_equals(item, currentItem)) ?? "";
    const values = get(this.#candidateValues).map((item) => item ?? "");
    const nextMatch = getNextMatch(values, this.#search.current, currentMatch);
    const newItem = get(this.#candidateValues).find((item) => strict_equals(item, nextMatch));
    if (newItem) {
      this.#opts.onMatch(newItem);
    }
    return newItem;
  }
  resetTypeahead() {
    this.#search.current = "";
  }
};

// node_modules/bits-ui/dist/internal/dom-typeahead.svelte.js
var DOMTypeahead = class {
  #opts;
  #search;
  #onMatch = tag(
    user_derived(() => {
      if (this.#opts.onMatch) return this.#opts.onMatch;
      return (node) => node.focus();
    }),
    "DOMTypeahead.#onMatch"
  );
  #getCurrentItem = tag(
    user_derived(() => {
      if (this.#opts.getCurrentItem) return this.#opts.getCurrentItem;
      return this.#opts.getActiveElement;
    }),
    "DOMTypeahead.#getCurrentItem"
  );
  constructor(opts) {
    this.#opts = opts;
    this.#search = boxAutoReset("", { afterMs: 1e3, getWindow: opts.getWindow });
    this.handleTypeaheadSearch = this.handleTypeaheadSearch.bind(this);
    this.resetTypeahead = this.resetTypeahead.bind(this);
  }
  handleTypeaheadSearch(key2, candidates) {
    if (!candidates.length) return;
    this.#search.current = this.#search.current + key2;
    const currentItem = get(this.#getCurrentItem)();
    const currentMatch = candidates.find((item) => strict_equals(item, currentItem))?.textContent?.trim() ?? "";
    const values = candidates.map((item) => item.textContent?.trim() ?? "");
    const nextMatch = getNextMatch(values, this.#search.current, currentMatch);
    const newItem = candidates.find((item) => strict_equals(item.textContent?.trim(), nextMatch));
    if (newItem) get(this.#onMatch)(newItem);
    return newItem;
  }
  resetTypeahead() {
    this.#search.current = "";
  }
  get search() {
    return this.#search.current;
  }
};

// node_modules/bits-ui/dist/bits/select/select.svelte.js
var INTERACTION_KEYS = [
  kbd_constants_exports.ARROW_LEFT,
  kbd_constants_exports.ESCAPE,
  kbd_constants_exports.ARROW_RIGHT,
  kbd_constants_exports.SHIFT,
  kbd_constants_exports.CAPS_LOCK,
  kbd_constants_exports.CONTROL,
  kbd_constants_exports.ALT,
  kbd_constants_exports.META,
  kbd_constants_exports.ENTER,
  kbd_constants_exports.F1,
  kbd_constants_exports.F2,
  kbd_constants_exports.F3,
  kbd_constants_exports.F4,
  kbd_constants_exports.F5,
  kbd_constants_exports.F6,
  kbd_constants_exports.F7,
  kbd_constants_exports.F8,
  kbd_constants_exports.F9,
  kbd_constants_exports.F10,
  kbd_constants_exports.F11,
  kbd_constants_exports.F12
];
var FIRST_KEYS2 = [kbd_constants_exports.ARROW_DOWN, kbd_constants_exports.PAGE_UP, kbd_constants_exports.HOME];
var LAST_KEYS2 = [kbd_constants_exports.ARROW_UP, kbd_constants_exports.PAGE_DOWN, kbd_constants_exports.END];
var FIRST_LAST_KEYS2 = [...FIRST_KEYS2, ...LAST_KEYS2];
var SELECTION_KEYS2 = [kbd_constants_exports.ENTER, kbd_constants_exports.SPACE];
var selectAttrs = createBitsAttrs({
  component: "select",
  parts: [
    "trigger",
    "content",
    "item",
    "viewport",
    "scroll-up-button",
    "scroll-down-button",
    "group",
    "group-label",
    "separator",
    "arrow",
    "input",
    "content-wrapper",
    "item-text",
    "value"
  ]
});
var SelectRootContext = new Context("Select.Root | Combobox.Root");
var SelectGroupContext = new Context("Select.Group | Combobox.Group");
var SelectContentContext = new Context("Select.Content | Combobox.Content");
var SelectBaseRootState = class {
  opts;
  #touchedInput = tag(state(false), "SelectBaseRootState.touchedInput");
  get touchedInput() {
    return get(this.#touchedInput);
  }
  set touchedInput(value) {
    set(this.#touchedInput, value, true);
  }
  #inputNode = tag(state(null), "SelectBaseRootState.inputNode");
  get inputNode() {
    return get(this.#inputNode);
  }
  set inputNode(value) {
    set(this.#inputNode, value, true);
  }
  #contentNode = tag(state(null), "SelectBaseRootState.contentNode");
  get contentNode() {
    return get(this.#contentNode);
  }
  set contentNode(value) {
    set(this.#contentNode, value, true);
  }
  #triggerNode = tag(state(null), "SelectBaseRootState.triggerNode");
  get triggerNode() {
    return get(this.#triggerNode);
  }
  set triggerNode(value) {
    set(this.#triggerNode, value, true);
  }
  #valueId = tag(state(""), "SelectBaseRootState.valueId");
  get valueId() {
    return get(this.#valueId);
  }
  set valueId(value) {
    set(this.#valueId, value, true);
  }
  #highlightedNode = tag(state(null), "SelectBaseRootState.highlightedNode");
  get highlightedNode() {
    return get(this.#highlightedNode);
  }
  set highlightedNode(value) {
    set(this.#highlightedNode, value, true);
  }
  #highlightedValue = tag(
    user_derived(() => {
      if (!this.highlightedNode) return null;
      return this.highlightedNode.getAttribute("data-value");
    }),
    "SelectBaseRootState.highlightedValue"
  );
  get highlightedValue() {
    return get(this.#highlightedValue);
  }
  set highlightedValue(value) {
    set(this.#highlightedValue, value);
  }
  #highlightedId = tag(
    user_derived(() => {
      if (!this.highlightedNode) return void 0;
      return this.highlightedNode.id;
    }),
    "SelectBaseRootState.highlightedId"
  );
  get highlightedId() {
    return get(this.#highlightedId);
  }
  set highlightedId(value) {
    set(this.#highlightedId, value);
  }
  #highlightedLabel = tag(
    user_derived(() => {
      if (!this.highlightedNode) return null;
      return this.highlightedNode.getAttribute("data-label");
    }),
    "SelectBaseRootState.highlightedLabel"
  );
  get highlightedLabel() {
    return get(this.#highlightedLabel);
  }
  set highlightedLabel(value) {
    set(this.#highlightedLabel, value);
  }
  isUsingKeyboard = false;
  isCombobox = false;
  domContext = new DOMContext(() => null);
  constructor(opts) {
    this.opts = opts;
    this.isCombobox = opts.isCombobox;
    new OpenChangeComplete({
      ref: box.with(() => this.contentNode),
      open: this.opts.open,
      onComplete: () => {
        this.opts.onOpenChangeComplete.current(this.opts.open.current);
      }
    });
    user_pre_effect(() => {
      if (!this.opts.open.current) {
        this.setHighlightedNode(null);
      }
    });
  }
  #debouncedSetHighlightedToFirstCandidate = debounce2(this.setHighlightedToFirstCandidate.bind(this), 20);
  setHighlightedNode(node, initial = false) {
    this.highlightedNode = node;
    if (node && (this.isUsingKeyboard || initial)) {
      node.scrollIntoView({ block: this.opts.scrollAlignment.current });
    }
  }
  getCandidateNodes() {
    const node = this.contentNode;
    if (!node) return [];
    return Array.from(node.querySelectorAll(`[${this.getBitsAttr("item")}]:not([data-disabled])`));
  }
  setHighlightedToFirstCandidate(options = { debounced: false }) {
    if (options.debounced) {
      this.#debouncedSetHighlightedToFirstCandidate();
      return;
    }
    this.setHighlightedNode(null);
    const candidateNodes = this.getCandidateNodes();
    if (!candidateNodes.length) return;
    this.setHighlightedNode(candidateNodes[0]);
  }
  getNodeByValue(value) {
    const candidateNodes = this.getCandidateNodes();
    return candidateNodes.find((node) => strict_equals(node.dataset.value, value)) ?? null;
  }
  setOpen(open) {
    this.opts.open.current = open;
  }
  toggleOpen() {
    this.opts.open.current = !this.opts.open.current;
  }
  handleOpen() {
    this.setOpen(true);
  }
  handleClose() {
    this.setHighlightedNode(null);
    this.setOpen(false);
  }
  toggleMenu() {
    this.toggleOpen();
  }
  getBitsAttr = (part) => {
    return selectAttrs.getAttr(part, this.isCombobox ? "combobox" : void 0);
  };
};
var SelectSingleRootState = class extends SelectBaseRootState {
  opts;
  isMulti = false;
  #hasValue = tag(user_derived(() => strict_equals(this.opts.value.current, "", false)), "SelectSingleRootState.hasValue");
  get hasValue() {
    return get(this.#hasValue);
  }
  set hasValue(value) {
    set(this.#hasValue, value);
  }
  #currentLabel = tag(
    user_derived(() => {
      if (!this.opts.items.current.length) return "";
      const match = this.opts.items.current.find((item) => strict_equals(item.value, this.opts.value.current))?.label;
      return match ?? "";
    }),
    "SelectSingleRootState.currentLabel"
  );
  get currentLabel() {
    return get(this.#currentLabel);
  }
  set currentLabel(value) {
    set(this.#currentLabel, value);
  }
  #candidateLabels = tag(
    user_derived(() => {
      if (!this.opts.items.current.length) return [];
      const filteredItems = this.opts.items.current.filter((item) => !item.disabled);
      return filteredItems.map((item) => item.label);
    }),
    "SelectSingleRootState.candidateLabels"
  );
  get candidateLabels() {
    return get(this.#candidateLabels);
  }
  set candidateLabels(value) {
    set(this.#candidateLabels, value);
  }
  #dataTypeaheadEnabled = tag(
    user_derived(() => {
      if (this.isMulti) return false;
      if (strict_equals(this.opts.items.current.length, 0)) return false;
      return true;
    }),
    "SelectSingleRootState.dataTypeaheadEnabled"
  );
  get dataTypeaheadEnabled() {
    return get(this.#dataTypeaheadEnabled);
  }
  set dataTypeaheadEnabled(value) {
    set(this.#dataTypeaheadEnabled, value);
  }
  constructor(opts) {
    super(opts);
    this.opts = opts;
    user_effect(() => {
      if (!this.opts.open.current && this.highlightedNode) {
        this.setHighlightedNode(null);
      }
    });
    watch(() => this.opts.open.current, () => {
      if (!this.opts.open.current) return;
      this.setInitialHighlightedNode();
    });
  }
  includesItem(itemValue) {
    return strict_equals(this.opts.value.current, itemValue);
  }
  toggleItem(itemValue, itemLabel = itemValue) {
    this.opts.value.current = this.includesItem(itemValue) ? "" : itemValue;
    this.opts.inputValue.current = itemLabel;
  }
  setInitialHighlightedNode() {
    afterTick(() => {
      if (this.highlightedNode && this.domContext.getDocument().contains(this.highlightedNode)) return;
      if (strict_equals(this.opts.value.current, "", false)) {
        const node = this.getNodeByValue(this.opts.value.current);
        if (node) {
          this.setHighlightedNode(node, true);
          return;
        }
      }
      const firstCandidate = this.getCandidateNodes()[0];
      if (!firstCandidate) return;
      this.setHighlightedNode(firstCandidate, true);
    });
  }
};
var SelectMultipleRootState = class extends SelectBaseRootState {
  opts;
  isMulti = true;
  #hasValue = tag(user_derived(() => this.opts.value.current.length > 0), "SelectMultipleRootState.hasValue");
  get hasValue() {
    return get(this.#hasValue);
  }
  set hasValue(value) {
    set(this.#hasValue, value);
  }
  constructor(opts) {
    super(opts);
    this.opts = opts;
    user_effect(() => {
      if (!this.opts.open.current && this.highlightedNode) {
        this.setHighlightedNode(null);
      }
    });
    watch(() => this.opts.open.current, () => {
      if (!this.opts.open.current) return;
      this.setInitialHighlightedNode();
    });
  }
  includesItem(itemValue) {
    return this.opts.value.current.includes(itemValue);
  }
  toggleItem(itemValue, itemLabel = itemValue) {
    if (this.includesItem(itemValue)) {
      this.opts.value.current = this.opts.value.current.filter((v) => strict_equals(v, itemValue, false));
    } else {
      this.opts.value.current = [...this.opts.value.current, itemValue];
    }
    this.opts.inputValue.current = itemLabel;
  }
  setInitialHighlightedNode() {
    afterTick(() => {
      if (!this.domContext) return;
      if (this.highlightedNode && this.domContext.getDocument().contains(this.highlightedNode)) return;
      if (this.opts.value.current.length && strict_equals(this.opts.value.current[0], "", false)) {
        const node = this.getNodeByValue(this.opts.value.current[0]);
        if (node) {
          this.setHighlightedNode(node, true);
          return;
        }
      }
      const firstCandidate = this.getCandidateNodes()[0];
      if (!firstCandidate) return;
      this.setHighlightedNode(firstCandidate, true);
    });
  }
};
var SelectRootState = class {
  static create(props) {
    const { type, ...rest } = props;
    const rootState = strict_equals(type, "single") ? new SelectSingleRootState(rest) : new SelectMultipleRootState(rest);
    return SelectRootContext.set(rootState);
  }
};
var SelectInputState = class _SelectInputState {
  static create(opts) {
    return new _SelectInputState(opts, SelectRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref, (v) => this.root.inputNode = v);
    this.root.domContext = new DOMContext(opts.ref);
    this.onkeydown = this.onkeydown.bind(this);
    this.oninput = this.oninput.bind(this);
    watch(
      [
        () => this.root.opts.value.current,
        () => this.opts.clearOnDeselect.current
      ],
      ([value, clearOnDeselect], [prevValue]) => {
        if (!clearOnDeselect) return;
        if (Array.isArray(value) && Array.isArray(prevValue)) {
          if (strict_equals(value.length, 0) && strict_equals(prevValue.length, 0, false)) {
            this.root.opts.inputValue.current = "";
          }
        } else if (strict_equals(value, "") && strict_equals(prevValue, "", false)) {
          this.root.opts.inputValue.current = "";
        }
      }
    );
  }
  onkeydown(e) {
    this.root.isUsingKeyboard = true;
    if (strict_equals(e.key, kbd_constants_exports.ESCAPE)) return;
    if (strict_equals(e.key, kbd_constants_exports.ARROW_UP) || strict_equals(e.key, kbd_constants_exports.ARROW_DOWN)) e.preventDefault();
    if (!this.root.opts.open.current) {
      if (INTERACTION_KEYS.includes(e.key)) return;
      if (strict_equals(e.key, kbd_constants_exports.TAB)) return;
      if (strict_equals(e.key, kbd_constants_exports.BACKSPACE) && strict_equals(this.root.opts.inputValue.current, "")) return;
      this.root.handleOpen();
      if (this.root.hasValue) return;
      const candidateNodes = this.root.getCandidateNodes();
      if (!candidateNodes.length) return;
      if (strict_equals(e.key, kbd_constants_exports.ARROW_DOWN)) {
        const firstCandidate = candidateNodes[0];
        this.root.setHighlightedNode(firstCandidate);
      } else if (strict_equals(e.key, kbd_constants_exports.ARROW_UP)) {
        const lastCandidate = candidateNodes[candidateNodes.length - 1];
        this.root.setHighlightedNode(lastCandidate);
      }
      return;
    }
    if (strict_equals(e.key, kbd_constants_exports.TAB)) {
      this.root.handleClose();
      return;
    }
    if (strict_equals(e.key, kbd_constants_exports.ENTER) && !e.isComposing) {
      e.preventDefault();
      const isCurrentSelectedValue = strict_equals(this.root.highlightedValue, this.root.opts.value.current);
      if (!this.root.opts.allowDeselect.current && isCurrentSelectedValue && !this.root.isMulti) {
        this.root.handleClose();
        return;
      }
      if (this.root.highlightedValue) {
        this.root.toggleItem(this.root.highlightedValue, this.root.highlightedLabel ?? void 0);
      }
      if (!this.root.isMulti && !isCurrentSelectedValue) {
        this.root.handleClose();
      }
    }
    if (strict_equals(e.key, kbd_constants_exports.ARROW_UP) && e.altKey) {
      this.root.handleClose();
    }
    if (FIRST_LAST_KEYS2.includes(e.key)) {
      e.preventDefault();
      const candidateNodes = this.root.getCandidateNodes();
      const currHighlightedNode = this.root.highlightedNode;
      const currIndex = currHighlightedNode ? candidateNodes.indexOf(currHighlightedNode) : -1;
      const loop = this.root.opts.loop.current;
      let nextItem;
      if (strict_equals(e.key, kbd_constants_exports.ARROW_DOWN)) {
        nextItem = next2(candidateNodes, currIndex, loop);
      } else if (strict_equals(e.key, kbd_constants_exports.ARROW_UP)) {
        nextItem = prev(candidateNodes, currIndex, loop);
      } else if (strict_equals(e.key, kbd_constants_exports.PAGE_DOWN)) {
        nextItem = forward(candidateNodes, currIndex, 10, loop);
      } else if (strict_equals(e.key, kbd_constants_exports.PAGE_UP)) {
        nextItem = backward(candidateNodes, currIndex, 10, loop);
      } else if (strict_equals(e.key, kbd_constants_exports.HOME)) {
        nextItem = candidateNodes[0];
      } else if (strict_equals(e.key, kbd_constants_exports.END)) {
        nextItem = candidateNodes[candidateNodes.length - 1];
      }
      if (!nextItem) return;
      this.root.setHighlightedNode(nextItem);
      return;
    }
    if (INTERACTION_KEYS.includes(e.key)) return;
    if (!this.root.highlightedNode) {
      this.root.setHighlightedToFirstCandidate();
    }
  }
  oninput(e) {
    this.root.opts.inputValue.current = e.currentTarget.value;
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "combobox",
      disabled: this.root.opts.disabled.current ? true : void 0,
      "aria-activedescendant": this.root.highlightedId,
      "aria-autocomplete": "list",
      "aria-expanded": getAriaExpanded(this.root.opts.open.current),
      "data-state": getDataOpenClosed(this.root.opts.open.current),
      "data-disabled": getDataDisabled(this.root.opts.disabled.current),
      onkeydown: this.onkeydown,
      oninput: this.oninput,
      [this.root.getBitsAttr("input")]: "",
      ...this.attachment
    })),
    "SelectInputState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var SelectComboTriggerState = class _SelectComboTriggerState {
  static create(opts) {
    return new _SelectComboTriggerState(opts, SelectRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
    this.onkeydown = this.onkeydown.bind(this);
    this.onpointerdown = this.onpointerdown.bind(this);
  }
  onkeydown(e) {
    if (!this.root.domContext) return;
    if (strict_equals(e.key, kbd_constants_exports.ENTER) || strict_equals(e.key, kbd_constants_exports.SPACE)) {
      e.preventDefault();
      if (strict_equals(this.root.domContext.getActiveElement(), this.root.inputNode, false)) {
        this.root.inputNode?.focus();
      }
      this.root.toggleMenu();
    }
  }
  /**
   * `pointerdown` fires before the `focus` event, so we can prevent the default
   * behavior of focusing the button and keep focus on the input.
   */
  onpointerdown(e) {
    if (this.root.opts.disabled.current || !this.root.domContext) return;
    e.preventDefault();
    if (strict_equals(this.root.domContext.getActiveElement(), this.root.inputNode, false)) {
      this.root.inputNode?.focus();
    }
    this.root.toggleMenu();
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      disabled: this.root.opts.disabled.current ? true : void 0,
      "aria-haspopup": "listbox",
      "data-state": getDataOpenClosed(this.root.opts.open.current),
      "data-disabled": getDataDisabled(this.root.opts.disabled.current),
      [this.root.getBitsAttr("trigger")]: "",
      onpointerdown: this.onpointerdown,
      onkeydown: this.onkeydown,
      ...this.attachment
    })),
    "SelectComboTriggerState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var SelectTriggerState = class _SelectTriggerState {
  static create(opts) {
    return new _SelectTriggerState(opts, SelectRootContext.get());
  }
  opts;
  root;
  attachment;
  #domTypeahead;
  #dataTypeahead;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref, (v) => this.root.triggerNode = v);
    this.root.domContext = new DOMContext(opts.ref);
    this.#domTypeahead = new DOMTypeahead({
      getCurrentItem: () => this.root.highlightedNode,
      onMatch: (node) => {
        this.root.setHighlightedNode(node);
      },
      getActiveElement: () => this.root.domContext.getActiveElement(),
      getWindow: () => this.root.domContext.getWindow()
    });
    this.#dataTypeahead = new DataTypeahead({
      getCurrentItem: () => {
        if (this.root.isMulti) return "";
        return this.root.currentLabel;
      },
      onMatch: (label) => {
        if (this.root.isMulti) return;
        if (!this.root.opts.items.current) return;
        const matchedItem = this.root.opts.items.current.find((item) => strict_equals(item.label, label));
        if (!matchedItem) return;
        this.root.opts.value.current = matchedItem.value;
      },
      enabled: () => !this.root.isMulti && this.root.dataTypeaheadEnabled,
      candidateValues: () => this.root.isMulti ? [] : this.root.candidateLabels,
      getWindow: () => this.root.domContext.getWindow()
    });
    this.onkeydown = this.onkeydown.bind(this);
    this.onpointerdown = this.onpointerdown.bind(this);
    this.onpointerup = this.onpointerup.bind(this);
    this.onclick = this.onclick.bind(this);
  }
  #handleOpen() {
    this.root.opts.open.current = true;
    this.#dataTypeahead.resetTypeahead();
    this.#domTypeahead.resetTypeahead();
  }
  #handlePointerOpen(_) {
    this.#handleOpen();
  }
  /**
   * Logic used to handle keyboard selection/deselection.
   *
   * If it returns true, it means the item was selected and whatever is calling
   * this function should return early
   *
   */
  #handleKeyboardSelection() {
    const isCurrentSelectedValue = strict_equals(this.root.highlightedValue, this.root.opts.value.current);
    if (!this.root.opts.allowDeselect.current && isCurrentSelectedValue && !this.root.isMulti) {
      this.root.handleClose();
      return true;
    }
    if (strict_equals(this.root.highlightedValue, null, false)) {
      this.root.toggleItem(this.root.highlightedValue, this.root.highlightedLabel ?? void 0);
    }
    if (!this.root.isMulti && !isCurrentSelectedValue) {
      this.root.handleClose();
      return true;
    }
    return false;
  }
  onkeydown(e) {
    this.root.isUsingKeyboard = true;
    if (strict_equals(e.key, kbd_constants_exports.ARROW_UP) || strict_equals(e.key, kbd_constants_exports.ARROW_DOWN)) e.preventDefault();
    if (!this.root.opts.open.current) {
      if (strict_equals(e.key, kbd_constants_exports.ENTER) || strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ARROW_DOWN) || strict_equals(e.key, kbd_constants_exports.ARROW_UP)) {
        e.preventDefault();
        this.root.handleOpen();
      } else if (!this.root.isMulti && this.root.dataTypeaheadEnabled) {
        this.#dataTypeahead.handleTypeaheadSearch(e.key);
        return;
      }
      if (this.root.hasValue) return;
      const candidateNodes2 = this.root.getCandidateNodes();
      if (!candidateNodes2.length) return;
      if (strict_equals(e.key, kbd_constants_exports.ARROW_DOWN)) {
        const firstCandidate = candidateNodes2[0];
        this.root.setHighlightedNode(firstCandidate);
      } else if (strict_equals(e.key, kbd_constants_exports.ARROW_UP)) {
        const lastCandidate = candidateNodes2[candidateNodes2.length - 1];
        this.root.setHighlightedNode(lastCandidate);
      }
      return;
    }
    if (strict_equals(e.key, kbd_constants_exports.TAB)) {
      this.root.handleClose();
      return;
    }
    if ((strict_equals(e.key, kbd_constants_exports.ENTER) || // if we're currently "typing ahead", we don't want to select the item
    // just yet as the item the user is trying to get to may have a space in it,
    // so we defer handling the close for this case until further down
    strict_equals(e.key, kbd_constants_exports.SPACE) && strict_equals(this.#domTypeahead.search, "")) && !e.isComposing) {
      e.preventDefault();
      const shouldReturn = this.#handleKeyboardSelection();
      if (shouldReturn) return;
    }
    if (strict_equals(e.key, kbd_constants_exports.ARROW_UP) && e.altKey) {
      this.root.handleClose();
    }
    if (FIRST_LAST_KEYS2.includes(e.key)) {
      e.preventDefault();
      const candidateNodes2 = this.root.getCandidateNodes();
      const currHighlightedNode = this.root.highlightedNode;
      const currIndex = currHighlightedNode ? candidateNodes2.indexOf(currHighlightedNode) : -1;
      const loop = this.root.opts.loop.current;
      let nextItem;
      if (strict_equals(e.key, kbd_constants_exports.ARROW_DOWN)) {
        nextItem = next2(candidateNodes2, currIndex, loop);
      } else if (strict_equals(e.key, kbd_constants_exports.ARROW_UP)) {
        nextItem = prev(candidateNodes2, currIndex, loop);
      } else if (strict_equals(e.key, kbd_constants_exports.PAGE_DOWN)) {
        nextItem = forward(candidateNodes2, currIndex, 10, loop);
      } else if (strict_equals(e.key, kbd_constants_exports.PAGE_UP)) {
        nextItem = backward(candidateNodes2, currIndex, 10, loop);
      } else if (strict_equals(e.key, kbd_constants_exports.HOME)) {
        nextItem = candidateNodes2[0];
      } else if (strict_equals(e.key, kbd_constants_exports.END)) {
        nextItem = candidateNodes2[candidateNodes2.length - 1];
      }
      if (!nextItem) return;
      this.root.setHighlightedNode(nextItem);
      return;
    }
    const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;
    const isCharacterKey = strict_equals(e.key.length, 1);
    const isSpaceKey = strict_equals(e.key, kbd_constants_exports.SPACE);
    const candidateNodes = this.root.getCandidateNodes();
    if (strict_equals(e.key, kbd_constants_exports.TAB)) return;
    if (!isModifierKey && (isCharacterKey || isSpaceKey)) {
      const matchedNode = this.#domTypeahead.handleTypeaheadSearch(e.key, candidateNodes);
      if (!matchedNode && isSpaceKey) {
        e.preventDefault();
        this.#handleKeyboardSelection();
      }
      return;
    }
    if (!this.root.highlightedNode) {
      this.root.setHighlightedToFirstCandidate();
    }
  }
  onclick(e) {
    const currTarget = e.currentTarget;
    currTarget.focus();
  }
  onpointerdown(e) {
    if (this.root.opts.disabled.current) return;
    if (strict_equals(e.pointerType, "touch")) return e.preventDefault();
    const target = e.target;
    if (target?.hasPointerCapture(e.pointerId)) {
      target?.releasePointerCapture(e.pointerId);
    }
    if (strict_equals(e.button, 0) && strict_equals(e.ctrlKey, false)) {
      if (strict_equals(this.root.opts.open.current, false)) {
        this.#handlePointerOpen(e);
      } else {
        this.root.handleClose();
      }
    }
  }
  onpointerup(e) {
    if (this.root.opts.disabled.current) return;
    e.preventDefault();
    if (strict_equals(e.pointerType, "touch")) {
      if (strict_equals(this.root.opts.open.current, false)) {
        this.#handlePointerOpen(e);
      } else {
        this.root.handleClose();
      }
    }
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      disabled: this.root.opts.disabled.current ? true : void 0,
      "aria-haspopup": "listbox",
      "aria-expanded": getAriaExpanded(this.root.opts.open.current),
      "aria-activedescendant": this.root.highlightedId,
      "data-state": getDataOpenClosed(this.root.opts.open.current),
      "data-disabled": getDataDisabled(this.root.opts.disabled.current),
      "data-placeholder": this.root.hasValue ? void 0 : "",
      [this.root.getBitsAttr("trigger")]: "",
      onpointerdown: this.onpointerdown,
      onkeydown: this.onkeydown,
      onclick: this.onclick,
      onpointerup: this.onpointerup,
      ...this.attachment
    })),
    "SelectTriggerState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var SelectContentState = class _SelectContentState {
  static create(opts) {
    return SelectContentContext.set(new _SelectContentState(opts, SelectRootContext.get()));
  }
  opts;
  root;
  attachment;
  #viewportNode = tag(state(null), "SelectContentState.viewportNode");
  get viewportNode() {
    return get(this.#viewportNode);
  }
  set viewportNode(value) {
    set(this.#viewportNode, value, true);
  }
  #isPositioned = tag(state(false), "SelectContentState.isPositioned");
  get isPositioned() {
    return get(this.#isPositioned);
  }
  set isPositioned(value) {
    set(this.#isPositioned, value, true);
  }
  domContext;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref, (v) => this.root.contentNode = v);
    this.domContext = new DOMContext(this.opts.ref);
    if (strict_equals(this.root.domContext, null)) {
      this.root.domContext = this.domContext;
    }
    onDestroyEffect(() => {
      this.root.contentNode = null;
      this.isPositioned = false;
    });
    watch(() => this.root.opts.open.current, () => {
      if (this.root.opts.open.current) return;
      this.isPositioned = false;
    });
    this.onpointermove = this.onpointermove.bind(this);
  }
  onpointermove(_) {
    this.root.isUsingKeyboard = false;
  }
  #styles = tag(
    user_derived(() => {
      return getFloatingContentCSSVars(this.root.isCombobox ? "combobox" : "select");
    }),
    "SelectContentState.#styles"
  );
  onInteractOutside = (e) => {
    if (strict_equals(e.target, this.root.triggerNode) || strict_equals(e.target, this.root.inputNode)) {
      e.preventDefault();
      return;
    }
    this.opts.onInteractOutside.current(e);
    if (e.defaultPrevented) return;
    this.root.handleClose();
  };
  onEscapeKeydown = (e) => {
    this.opts.onEscapeKeydown.current(e);
    if (e.defaultPrevented) return;
    this.root.handleClose();
  };
  onOpenAutoFocus = (e) => {
    e.preventDefault();
  };
  onCloseAutoFocus = (e) => {
    e.preventDefault();
  };
  #snippetProps = tag(user_derived(() => ({ open: this.root.opts.open.current })), "SelectContentState.snippetProps");
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "listbox",
      "aria-multiselectable": this.root.isMulti ? "true" : void 0,
      "data-state": getDataOpenClosed(this.root.opts.open.current),
      [this.root.getBitsAttr("content")]: "",
      style: {
        display: "flex",
        flexDirection: "column",
        outline: "none",
        boxSizing: "border-box",
        pointerEvents: "auto",
        ...get(this.#styles)
      },
      onpointermove: this.onpointermove,
      ...this.attachment
    })),
    "SelectContentState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
  popperProps = {
    onInteractOutside: this.onInteractOutside,
    onEscapeKeydown: this.onEscapeKeydown,
    onOpenAutoFocus: this.onOpenAutoFocus,
    onCloseAutoFocus: this.onCloseAutoFocus,
    trapFocus: false,
    loop: false,
    onPlaced: () => {
      if (this.root.opts.open.current) {
        this.isPositioned = true;
      }
    }
  };
};
var SelectItemState = class _SelectItemState {
  static create(opts) {
    return new _SelectItemState(opts, SelectRootContext.get());
  }
  opts;
  root;
  attachment;
  #isSelected = tag(user_derived(() => this.root.includesItem(this.opts.value.current)), "SelectItemState.isSelected");
  get isSelected() {
    return get(this.#isSelected);
  }
  set isSelected(value) {
    set(this.#isSelected, value);
  }
  #isHighlighted = tag(user_derived(() => strict_equals(this.root.highlightedValue, this.opts.value.current)), "SelectItemState.isHighlighted");
  get isHighlighted() {
    return get(this.#isHighlighted);
  }
  set isHighlighted(value) {
    set(this.#isHighlighted, value);
  }
  prevHighlighted = new Previous(() => this.isHighlighted);
  #mounted = tag(state(false), "SelectItemState.mounted");
  get mounted() {
    return get(this.#mounted);
  }
  set mounted(value) {
    set(this.#mounted, value, true);
  }
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
    onMountEffect(() => {
      this.root.setHighlightedToFirstCandidate({ debounced: true });
    });
    onDestroyEffect(() => {
      this.root.setHighlightedToFirstCandidate({ debounced: true });
    });
    watch([() => this.isHighlighted, () => this.prevHighlighted.current], () => {
      if (this.isHighlighted) {
        this.opts.onHighlight.current();
      } else if (this.prevHighlighted.current) {
        this.opts.onUnhighlight.current();
      }
    });
    watch(() => this.mounted, () => {
      if (!this.mounted) return;
      this.root.setInitialHighlightedNode();
    });
    this.onpointerdown = this.onpointerdown.bind(this);
    this.onpointerup = this.onpointerup.bind(this);
    this.onpointermove = this.onpointermove.bind(this);
  }
  handleSelect() {
    if (this.opts.disabled.current) return;
    const isCurrentSelectedValue = strict_equals(this.opts.value.current, this.root.opts.value.current);
    if (!this.root.opts.allowDeselect.current && isCurrentSelectedValue && !this.root.isMulti) {
      this.root.handleClose();
      return;
    }
    this.root.toggleItem(this.opts.value.current, this.opts.label.current);
    if (!this.root.isMulti && !isCurrentSelectedValue) {
      this.root.handleClose();
    }
  }
  #snippetProps = tag(user_derived(() => ({ selected: this.isSelected, highlighted: this.isHighlighted })), "SelectItemState.snippetProps");
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
  onpointerdown(e) {
    e.preventDefault();
  }
  /**
   * Using `pointerup` instead of `click` allows power users to pointerdown
   * the trigger, then release pointerup on an item to select it vs having to do
   * multiple clicks.
   */
  onpointerup(e) {
    if (e.defaultPrevented || !this.opts.ref.current) return;
    if (strict_equals(e.pointerType, "touch") && !isIOS) {
      on(
        this.opts.ref.current,
        "click",
        () => {
          this.handleSelect();
          this.root.setHighlightedNode(this.opts.ref.current);
        },
        { once: true }
      );
      return;
    }
    e.preventDefault();
    this.handleSelect();
    if (strict_equals(e.pointerType, "touch")) {
      this.root.setHighlightedNode(this.opts.ref.current);
    }
  }
  onpointermove(e) {
    if (strict_equals(e.pointerType, "touch")) return;
    if (strict_equals(this.root.highlightedNode, this.opts.ref.current, false)) {
      this.root.setHighlightedNode(this.opts.ref.current);
    }
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "option",
      "aria-selected": this.root.includesItem(this.opts.value.current) ? "true" : void 0,
      "data-value": this.opts.value.current,
      "data-disabled": getDataDisabled(this.opts.disabled.current),
      "data-highlighted": strict_equals(this.root.highlightedValue, this.opts.value.current) && !this.opts.disabled.current ? "" : void 0,
      "data-selected": this.root.includesItem(this.opts.value.current) ? "" : void 0,
      "data-label": this.opts.label.current,
      [this.root.getBitsAttr("item")]: "",
      onpointermove: this.onpointermove,
      onpointerdown: this.onpointerdown,
      onpointerup: this.onpointerup,
      ...this.attachment
    })),
    "SelectItemState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var SelectGroupState = class _SelectGroupState {
  static create(opts) {
    return SelectGroupContext.set(new _SelectGroupState(opts, SelectRootContext.get()));
  }
  opts;
  root;
  #labelNode = tag(state(null), "SelectGroupState.labelNode");
  get labelNode() {
    return get(this.#labelNode);
  }
  set labelNode(value) {
    set(this.#labelNode, value, true);
  }
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "group",
      [this.root.getBitsAttr("group")]: "",
      "aria-labelledby": this.labelNode?.id ?? void 0,
      ...this.attachment
    })),
    "SelectGroupState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var SelectGroupHeadingState = class _SelectGroupHeadingState {
  static create(opts) {
    return new _SelectGroupHeadingState(opts, SelectGroupContext.get());
  }
  opts;
  group;
  attachment;
  constructor(opts, group) {
    this.opts = opts;
    this.group = group;
    this.attachment = attachRef(opts.ref, (v) => this.group.labelNode = v);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      [this.group.root.getBitsAttr("group-label")]: "",
      ...this.attachment
    })),
    "SelectGroupHeadingState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var SelectHiddenInputState = class _SelectHiddenInputState {
  static create(opts) {
    return new _SelectHiddenInputState(opts, SelectRootContext.get());
  }
  opts;
  root;
  #shouldRender = tag(user_derived(() => strict_equals(this.root.opts.name.current, "", false)), "SelectHiddenInputState.shouldRender");
  get shouldRender() {
    return get(this.#shouldRender);
  }
  set shouldRender(value) {
    set(this.#shouldRender, value);
  }
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.onfocus = this.onfocus.bind(this);
  }
  onfocus(e) {
    e.preventDefault();
    if (!this.root.isCombobox) {
      this.root.triggerNode?.focus();
    } else {
      this.root.inputNode?.focus();
    }
  }
  #props = tag(
    user_derived(() => ({
      disabled: getDisabled(this.root.opts.disabled.current),
      required: getRequired(this.root.opts.required.current),
      name: this.root.opts.name.current,
      value: this.opts.value.current,
      onfocus: this.onfocus
    })),
    "SelectHiddenInputState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var SelectViewportState = class _SelectViewportState {
  static create(opts) {
    return new _SelectViewportState(opts, SelectContentContext.get());
  }
  opts;
  content;
  root;
  attachment;
  #prevScrollTop = tag(state(0), "SelectViewportState.prevScrollTop");
  get prevScrollTop() {
    return get(this.#prevScrollTop);
  }
  set prevScrollTop(value) {
    set(this.#prevScrollTop, value, true);
  }
  constructor(opts, content) {
    this.opts = opts;
    this.content = content;
    this.root = content.root;
    this.attachment = attachRef(opts.ref, (v) => this.content.viewportNode = v);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "presentation",
      [this.root.getBitsAttr("viewport")]: "",
      style: {
        // we use position: 'relative' here on the `viewport` so that when we call
        // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
        // (independent of the scrollUpButton).
        position: "relative",
        flex: 1,
        overflow: "auto"
      },
      ...this.attachment
    })),
    "SelectViewportState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var SelectScrollButtonImplState = class {
  opts;
  content;
  root;
  attachment;
  autoScrollTimer = null;
  userScrollTimer = -1;
  isUserScrolling = false;
  onAutoScroll = noop3;
  #mounted = tag(state(false), "SelectScrollButtonImplState.mounted");
  get mounted() {
    return get(this.#mounted);
  }
  set mounted(value) {
    set(this.#mounted, value, true);
  }
  constructor(opts, content) {
    this.opts = opts;
    this.content = content;
    this.root = content.root;
    this.attachment = attachRef(opts.ref);
    watch([() => this.mounted], () => {
      if (!this.mounted) {
        this.isUserScrolling = false;
        return;
      }
      if (this.isUserScrolling) return;
    });
    user_effect(() => {
      if (this.mounted) return;
      this.clearAutoScrollInterval();
    });
    this.onpointerdown = this.onpointerdown.bind(this);
    this.onpointermove = this.onpointermove.bind(this);
    this.onpointerleave = this.onpointerleave.bind(this);
  }
  handleUserScroll() {
    this.content.domContext.clearTimeout(this.userScrollTimer);
    this.isUserScrolling = true;
    this.userScrollTimer = this.content.domContext.setTimeout(
      () => {
        this.isUserScrolling = false;
      },
      200
    );
  }
  clearAutoScrollInterval() {
    if (strict_equals(this.autoScrollTimer, null)) return;
    this.content.domContext.clearTimeout(this.autoScrollTimer);
    this.autoScrollTimer = null;
  }
  onpointerdown(_) {
    if (strict_equals(this.autoScrollTimer, null, false)) return;
    const autoScroll = (tick2) => {
      this.onAutoScroll();
      this.autoScrollTimer = this.content.domContext.setTimeout(() => autoScroll(tick2 + 1), this.opts.delay.current(tick2));
    };
    this.autoScrollTimer = this.content.domContext.setTimeout(() => autoScroll(1), this.opts.delay.current(0));
  }
  onpointermove(e) {
    this.onpointerdown(e);
  }
  onpointerleave(_) {
    this.clearAutoScrollInterval();
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "aria-hidden": getAriaHidden(true),
      style: { flexShrink: 0 },
      onpointerdown: this.onpointerdown,
      onpointermove: this.onpointermove,
      onpointerleave: this.onpointerleave,
      ...this.attachment
    })),
    "SelectScrollButtonImplState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var SelectScrollDownButtonState = class _SelectScrollDownButtonState {
  static create(opts) {
    return new _SelectScrollDownButtonState(new SelectScrollButtonImplState(opts, SelectContentContext.get()));
  }
  scrollButtonState;
  content;
  root;
  #canScrollDown = tag(state(false), "SelectScrollDownButtonState.canScrollDown");
  get canScrollDown() {
    return get(this.#canScrollDown);
  }
  set canScrollDown(value) {
    set(this.#canScrollDown, value, true);
  }
  scrollIntoViewTimer = null;
  constructor(scrollButtonState) {
    this.scrollButtonState = scrollButtonState;
    this.content = scrollButtonState.content;
    this.root = scrollButtonState.root;
    this.scrollButtonState.onAutoScroll = this.handleAutoScroll;
    watch(
      [
        () => this.content.viewportNode,
        () => this.content.isPositioned
      ],
      () => {
        if (!this.content.viewportNode || !this.content.isPositioned) return;
        this.handleScroll(true);
        return on(this.content.viewportNode, "scroll", () => this.handleScroll());
      }
    );
    watch(() => this.scrollButtonState.mounted, () => {
      if (!this.scrollButtonState.mounted) return;
      if (this.scrollIntoViewTimer) {
        clearTimeout(this.scrollIntoViewTimer);
      }
      this.scrollIntoViewTimer = afterSleep(5, () => {
        const activeItem = this.root.highlightedNode;
        activeItem?.scrollIntoView({ block: this.root.opts.scrollAlignment.current });
      });
    });
  }
  /**
   * @param manual - if true, it means the function was invoked manually outside of an event
   * listener, so we don't call `handleUserScroll` to prevent the auto scroll from kicking in.
   */
  handleScroll = (manual = false) => {
    if (!manual) {
      this.scrollButtonState.handleUserScroll();
    }
    if (!this.content.viewportNode) return;
    const maxScroll = this.content.viewportNode.scrollHeight - this.content.viewportNode.clientHeight;
    const paddingTop = Number.parseInt(getComputedStyle(this.content.viewportNode).paddingTop, 10);
    this.canScrollDown = Math.ceil(this.content.viewportNode.scrollTop) < maxScroll - paddingTop;
  };
  handleAutoScroll = () => {
    const viewport = this.content.viewportNode;
    const selectedItem = this.root.highlightedNode;
    if (!viewport || !selectedItem) return;
    viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;
  };
  #props = tag(
    user_derived(() => ({
      ...this.scrollButtonState.props,
      [this.root.getBitsAttr("scroll-down-button")]: ""
    })),
    "SelectScrollDownButtonState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var SelectScrollUpButtonState = class _SelectScrollUpButtonState {
  static create(opts) {
    return new _SelectScrollUpButtonState(new SelectScrollButtonImplState(opts, SelectContentContext.get()));
  }
  scrollButtonState;
  content;
  root;
  #canScrollUp = tag(state(false), "SelectScrollUpButtonState.canScrollUp");
  get canScrollUp() {
    return get(this.#canScrollUp);
  }
  set canScrollUp(value) {
    set(this.#canScrollUp, value, true);
  }
  constructor(scrollButtonState) {
    this.scrollButtonState = scrollButtonState;
    this.content = scrollButtonState.content;
    this.root = scrollButtonState.root;
    this.scrollButtonState.onAutoScroll = this.handleAutoScroll;
    watch(
      [
        () => this.content.viewportNode,
        () => this.content.isPositioned
      ],
      () => {
        if (!this.content.viewportNode || !this.content.isPositioned) return;
        this.handleScroll(true);
        return on(this.content.viewportNode, "scroll", () => this.handleScroll());
      }
    );
  }
  /**
   * @param manual - if true, it means the function was invoked manually outside of an event
   * listener, so we don't call `handleUserScroll` to prevent the auto scroll from kicking in.
   */
  handleScroll = (manual = false) => {
    if (!manual) {
      this.scrollButtonState.handleUserScroll();
    }
    if (!this.content.viewportNode) return;
    const paddingTop = Number.parseInt(getComputedStyle(this.content.viewportNode).paddingTop, 10);
    this.canScrollUp = this.content.viewportNode.scrollTop - paddingTop > 0.1;
  };
  handleAutoScroll = () => {
    if (!this.content.viewportNode || !this.root.highlightedNode) return;
    this.content.viewportNode.scrollTop = this.content.viewportNode.scrollTop - this.root.highlightedNode.offsetHeight;
  };
  #props = tag(
    user_derived(() => ({
      ...this.scrollButtonState.props,
      [this.root.getBitsAttr("scroll-up-button")]: ""
    })),
    "SelectScrollUpButtonState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};

// node_modules/bits-ui/dist/bits/select/components/select-hidden-input.svelte
Select_hidden_input[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-hidden-input.svelte";
function Select_hidden_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Select_hidden_input);
  var $$ownership_validator = create_ownership_validator($$props);
  let value = prop($$props, "value", 15, "");
  const hiddenInputState = SelectHiddenInputState.create({ value: box.with(() => value()) });
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        $$ownership_validator.binding("value", hidden_input_default, value);
        add_svelte_meta(
          () => hidden_input_default(node_1, spread_props(() => hiddenInputState.props, {
            get autocomplete() {
              return $$props.autocomplete;
            },
            get value() {
              return value();
            },
            set value($$value) {
              value($$value);
            }
          })),
          "component",
          Select_hidden_input,
          18,
          1,
          { componentTag: "HiddenInput" }
        );
      }
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (hiddenInputState.shouldRender) $$render(consequent);
      }),
      "if",
      Select_hidden_input,
      17,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select_hidden_input = hmr(Select_hidden_input, () => Select_hidden_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select_hidden_input[HMR].source;
    set(Select_hidden_input[HMR].source, module.default[HMR].original);
  });
}
var select_hidden_input_default = Select_hidden_input;

// node_modules/bits-ui/dist/bits/combobox/components/combobox.svelte
Combobox[FILENAME] = "node_modules/bits-ui/dist/bits/combobox/components/combobox.svelte";
var root3 = add_locations(from_html(`<!> <!>`, 1), Combobox[FILENAME], []);
function Combobox($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Combobox);
  let value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop3), name = prop($$props, "name", 3, ""), disabled = prop($$props, "disabled", 3, false), open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3), loop = prop($$props, "loop", 3, false), scrollAlignment = prop($$props, "scrollAlignment", 3, "nearest"), required = prop($$props, "required", 3, false), items = prop($$props, "items", 19, () => []), allowDeselect = prop($$props, "allowDeselect", 3, true), inputValue = prop($$props, "inputValue", 7, "");
  if (strict_equals(value(), void 0)) {
    const defaultValue = strict_equals($$props.type, "single") ? "" : [];
    value(defaultValue);
  }
  watch.pre(() => value(), () => {
    if (strict_equals(value(), void 0, false)) return;
    value(strict_equals($$props.type, "single") ? "" : []);
  });
  const rootState = SelectRootState.create({
    type: $$props.type,
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    disabled: box.with(() => disabled()),
    required: box.with(() => required()),
    open: box.with(() => open(), (v) => {
      open(v);
      onOpenChange()(v);
    }),
    loop: box.with(() => loop()),
    scrollAlignment: box.with(() => scrollAlignment()),
    name: box.with(() => name()),
    isCombobox: true,
    items: box.with(() => items()),
    allowDeselect: box.with(() => allowDeselect()),
    inputValue: box.with(() => inputValue(), (v) => inputValue(v)),
    onOpenChangeComplete: box.with(() => onOpenChangeComplete())
  });
  var fragment = root3();
  var node = first_child(fragment);
  add_svelte_meta(
    () => floating_layer_default(node, {
      children: wrap_snippet(Combobox, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop), "render", Combobox, 75, 1);
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }),
    "component",
    Combobox,
    74,
    0,
    { componentTag: "FloatingLayer" }
  );
  var node_2 = sibling(node, 2);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_2 = comment();
      var node_3 = first_child(fragment_2);
      {
        var consequent = ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          validate_each_keys(() => rootState.opts.value.current, (item) => item);
          add_svelte_meta(
            () => each(node_4, 16, () => rootState.opts.value.current, (item) => item, ($$anchor4, item) => {
              var fragment_4 = comment();
              var node_5 = first_child(fragment_4);
              add_svelte_meta(
                () => select_hidden_input_default(node_5, {
                  get value() {
                    return item;
                  }
                }),
                "component",
                Combobox,
                81,
                3,
                { componentTag: "ListboxHiddenInput" }
              );
              append($$anchor4, fragment_4);
            }),
            "each",
            Combobox,
            80,
            2
          );
          append($$anchor3, fragment_3);
        };
        add_svelte_meta(
          () => if_block(node_3, ($$render) => {
            if (rootState.opts.value.current.length) $$render(consequent);
          }),
          "if",
          Combobox,
          79,
          1
        );
      }
      append($$anchor2, fragment_2);
    };
    var alternate = ($$anchor2) => {
      var fragment_5 = comment();
      var node_6 = first_child(fragment_5);
      validate_binding("bind:value={rootState.opts.value.current as string}", () => rootState.opts.value, () => "current", 85, 21);
      add_svelte_meta(
        () => select_hidden_input_default(node_6, {
          get value() {
            return rootState.opts.value.current;
          },
          set value($$value) {
            rootState.opts.value.current = $$value;
          }
        }),
        "component",
        Combobox,
        85,
        1,
        { componentTag: "ListboxHiddenInput" }
      );
      append($$anchor2, fragment_5);
    };
    add_svelte_meta(
      () => if_block(node_2, ($$render) => {
        if (Array.isArray(rootState.opts.value.current)) $$render(consequent_1);
        else $$render(alternate, false);
      }),
      "if",
      Combobox,
      78,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Combobox = hmr(Combobox, () => Combobox[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Combobox[HMR].source;
    set(Combobox[HMR].source, module.default[HMR].original);
  });
}
var combobox_default = Combobox;

// node_modules/bits-ui/dist/bits/utilities/floating-layer/components/index.js
var components_exports = {};
__export(components_exports, {
  Anchor: () => floating_layer_anchor_default,
  Arrow: () => floating_layer_arrow_default,
  Content: () => floating_layer_content_default,
  ContentStatic: () => floating_layer_content_static_default,
  Root: () => floating_layer_default
});

// node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-anchor.svelte
Floating_layer_anchor[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-anchor.svelte";
function Floating_layer_anchor($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Floating_layer_anchor);
  let tooltip = prop($$props, "tooltip", 3, false);
  FloatingAnchorState.create(
    {
      id: box.with(() => $$props.id),
      virtualEl: box.with(() => $$props.virtualEl),
      ref: $$props.ref
    },
    tooltip()
  );
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop), "render", Floating_layer_anchor, 19, 0);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Floating_layer_anchor = hmr(Floating_layer_anchor, () => Floating_layer_anchor[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Floating_layer_anchor[HMR].source;
    set(Floating_layer_anchor[HMR].source, module.default[HMR].original);
  });
}
var floating_layer_anchor_default = Floating_layer_anchor;

// node_modules/bits-ui/dist/bits/utilities/arrow/arrow.svelte
Arrow[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/arrow/arrow.svelte";
var root_4 = add_locations(from_svg(`<svg viewBox="0 0 30 10" preserveAspectRatio="none" data-arrow=""><polygon points="0,0 30,0 15,10" fill="currentColor"></polygon></svg>`), Arrow[FILENAME], [[25, 3, [[26, 4]]]]);
var root_234 = add_locations(from_html(`<span><!></span>`), Arrow[FILENAME], [[21, 1]]);
function Arrow($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Arrow);
  let id = prop($$props, "id", 19, useId), width = prop($$props, "width", 3, 10), height = prop($$props, "height", 3, 5), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "children",
      "child",
      "width",
      "height"
    ],
    "restProps"
  );
  const mergedProps = tag(user_derived(() => mergeProps(restProps, { id: id() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Arrow, 19, 1);
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2) => {
      var span = root_234();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop), "render", Arrow, 23, 3);
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var svg = root_4();
          template_effect(() => {
            set_attribute(svg, "width", width());
            set_attribute(svg, "height", height());
          });
          append($$anchor3, svg);
        };
        add_svelte_meta(
          () => if_block(node_2, ($$render) => {
            if ($$props.children) $$render(consequent_1);
            else $$render(alternate, false);
          }),
          "if",
          Arrow,
          22,
          2
        );
      }
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate_1, false);
      }),
      "if",
      Arrow,
      18,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Arrow = hmr(Arrow, () => Arrow[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Arrow[HMR].source;
    set(Arrow[HMR].source, module.default[HMR].original);
  });
}
var arrow_default = Arrow;

// node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-arrow.svelte
Floating_layer_arrow[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-arrow.svelte";
function Floating_layer_arrow($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Floating_layer_arrow);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "id", "ref"], "restProps");
  const arrowState = FloatingArrowState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, arrowState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => arrow_default(node, spread_props(() => get(mergedProps))), "component", Floating_layer_arrow, 20, 0, { componentTag: "Arrow" });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Floating_layer_arrow = hmr(Floating_layer_arrow, () => Floating_layer_arrow[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Floating_layer_arrow[HMR].source;
    set(Floating_layer_arrow[HMR].source, module.default[HMR].original);
  });
}
var floating_layer_arrow_default = Floating_layer_arrow;

// node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-content.svelte
Floating_layer_content[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-content.svelte";
function Floating_layer_content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Floating_layer_content);
  let side = prop($$props, "side", 3, "bottom"), sideOffset = prop($$props, "sideOffset", 3, 0), align = prop($$props, "align", 3, "center"), alignOffset = prop($$props, "alignOffset", 3, 0), arrowPadding = prop($$props, "arrowPadding", 3, 0), avoidCollisions = prop($$props, "avoidCollisions", 3, true), collisionBoundary = prop($$props, "collisionBoundary", 19, () => []), collisionPadding = prop($$props, "collisionPadding", 3, 0), hideWhenDetached = prop($$props, "hideWhenDetached", 3, false), onPlaced = prop($$props, "onPlaced", 3, () => {
  }), sticky = prop($$props, "sticky", 3, "partial"), updatePositionStrategy = prop($$props, "updatePositionStrategy", 3, "optimized"), strategy = prop($$props, "strategy", 3, "fixed"), dir = prop($$props, "dir", 3, "ltr"), style = prop($$props, "style", 19, () => ({})), wrapperId = prop($$props, "wrapperId", 19, useId), customAnchor = prop($$props, "customAnchor", 3, null), tooltip = prop($$props, "tooltip", 3, false);
  const contentState = FloatingContentState.create(
    {
      side: box.with(() => side()),
      sideOffset: box.with(() => sideOffset()),
      align: box.with(() => align()),
      alignOffset: box.with(() => alignOffset()),
      id: box.with(() => $$props.id),
      arrowPadding: box.with(() => arrowPadding()),
      avoidCollisions: box.with(() => avoidCollisions()),
      collisionBoundary: box.with(() => collisionBoundary()),
      collisionPadding: box.with(() => collisionPadding()),
      hideWhenDetached: box.with(() => hideWhenDetached()),
      onPlaced: box.with(() => onPlaced()),
      sticky: box.with(() => sticky()),
      updatePositionStrategy: box.with(() => updatePositionStrategy()),
      strategy: box.with(() => strategy()),
      dir: box.with(() => dir()),
      style: box.with(() => style()),
      enabled: box.with(() => $$props.enabled),
      wrapperId: box.with(() => wrapperId()),
      customAnchor: box.with(() => customAnchor())
    },
    tooltip()
  );
  const mergedProps = tag(user_derived(() => mergeProps(contentState.wrapperProps, { style: { pointerEvents: "auto" } })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => $$props.content ?? noop, () => ({ props: contentState.props, wrapperProps: get(mergedProps) })), "render", Floating_layer_content, 65, 0);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Floating_layer_content = hmr(Floating_layer_content, () => Floating_layer_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Floating_layer_content[HMR].source;
    set(Floating_layer_content[HMR].source, module.default[HMR].original);
  });
}
var floating_layer_content_default = Floating_layer_content;

// node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-content-static.svelte
Floating_layer_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/floating-layer/components/floating-layer-content-static.svelte";
function Floating_layer_content_static($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Floating_layer_content_static);
  onMount(() => {
    $$props.onPlaced?.();
  });
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => $$props.content ?? noop, () => ({ props: {}, wrapperProps: {} })), "render", Floating_layer_content_static, 19, 0);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Floating_layer_content_static = hmr(Floating_layer_content_static, () => Floating_layer_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Floating_layer_content_static[HMR].source;
    set(Floating_layer_content_static[HMR].source, module.default[HMR].original);
  });
}
var floating_layer_content_static_default = Floating_layer_content_static;

// node_modules/bits-ui/dist/bits/combobox/components/combobox-input.svelte
Combobox_input[FILENAME] = "node_modules/bits-ui/dist/bits/combobox/components/combobox-input.svelte";
var root_34 = add_locations(from_html(`<input/>`), Combobox_input[FILENAME], [[39, 2]]);
function Combobox_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Combobox_input);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), clearOnDeselect = prop($$props, "clearOnDeselect", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "defaultValue",
      "clearOnDeselect"
    ],
    "restProps"
  );
  const inputState = SelectInputState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    clearOnDeselect: box.with(() => clearOnDeselect())
  });
  if ($$props.defaultValue) {
    inputState.root.opts.inputValue.current = $$props.defaultValue;
  }
  const mergedProps = tag(user_derived(() => mergeProps(restProps, inputState.props, { value: inputState.root.opts.inputValue.current })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => component(node, () => components_exports.Anchor, ($$anchor2, FloatingLayer_Anchor) => {
      FloatingLayer_Anchor($$anchor2, {
        get id() {
          return id();
        },
        get ref() {
          return inputState.opts.ref;
        },
        children: wrap_snippet(Combobox_input, ($$anchor3, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          {
            var consequent = ($$anchor4) => {
              var fragment_2 = comment();
              var node_2 = first_child(fragment_2);
              add_svelte_meta(() => snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Combobox_input, 37, 2);
              append($$anchor4, fragment_2);
            };
            var alternate = ($$anchor4) => {
              var input = root_34();
              remove_input_defaults(input);
              attribute_effect(input, () => ({ ...get(mergedProps) }));
              append($$anchor4, input);
            };
            add_svelte_meta(
              () => if_block(node_1, ($$render) => {
                if ($$props.child) $$render(consequent);
                else $$render(alternate, false);
              }),
              "if",
              Combobox_input,
              36,
              1
            );
          }
          append($$anchor3, fragment_1);
        }),
        $$slots: { default: true }
      });
    }),
    "component",
    Combobox_input,
    35,
    0,
    { componentTag: "FloatingLayer.Anchor" }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Combobox_input = hmr(Combobox_input, () => Combobox_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Combobox_input[HMR].source;
    set(Combobox_input[HMR].source, module.default[HMR].original);
  });
}
var combobox_input_default = Combobox_input;

// node_modules/bits-ui/dist/bits/separator/separator.svelte.js
var separatorAttrs = createBitsAttrs({ component: "separator", parts: ["root"] });
var SeparatorRootState = class _SeparatorRootState {
  static create(opts) {
    return new _SeparatorRootState(opts);
  }
  opts;
  attachment;
  constructor(opts) {
    this.opts = opts;
    this.attachment = attachRef(opts.ref);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: this.opts.decorative.current ? "none" : "separator",
      "aria-orientation": getAriaOrientation(this.opts.orientation.current),
      "aria-hidden": getAriaHidden(this.opts.decorative.current),
      "data-orientation": getDataOrientation(this.opts.orientation.current),
      [separatorAttrs.root]: "",
      ...this.attachment
    })),
    "SeparatorRootState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};

// node_modules/bits-ui/dist/bits/separator/components/separator.svelte
Separator[FILENAME] = "node_modules/bits-ui/dist/bits/separator/components/separator.svelte";
var root_235 = add_locations(from_html(`<div><!></div>`), Separator[FILENAME], [[35, 1]]);
function Separator($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Separator);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), decorative = prop($$props, "decorative", 3, false), orientation = prop($$props, "orientation", 3, "horizontal"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "children",
      "decorative",
      "orientation"
    ],
    "restProps"
  );
  const rootState = SeparatorRootState.create({
    ref: box.with(() => ref(), (v) => ref(v)),
    id: box.with(() => id()),
    decorative: box.with(() => decorative()),
    orientation: box.with(() => orientation())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Separator, 33, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_235();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Separator, 36, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Separator,
      32,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Separator = hmr(Separator, () => Separator[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Separator[HMR].source;
    set(Separator[HMR].source, module.default[HMR].original);
  });
}
var separator_default = Separator;

// node_modules/bits-ui/dist/bits/combobox/components/combobox-trigger.svelte
Combobox_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/combobox/components/combobox-trigger.svelte";
var root_236 = add_locations(from_html(`<button><!></button>`), Combobox_trigger[FILENAME], [[30, 1]]);
function Combobox_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Combobox_trigger);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), type = prop($$props, "type", 3, "button"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "children",
      "type"
    ],
    "restProps"
  );
  const triggerState = SelectComboTriggerState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, triggerState.props, { type: type() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Combobox_trigger, 28, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_236();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Combobox_trigger, 31, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Combobox_trigger,
      27,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Combobox_trigger = hmr(Combobox_trigger, () => Combobox_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Combobox_trigger[HMR].source;
    set(Combobox_trigger[HMR].source, module.default[HMR].original);
  });
}
var combobox_trigger_default = Combobox_trigger;

// node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-content.svelte
Popper_content[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-content.svelte";
function Popper_content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Popper_content);
  let isStatic = prop($$props, "isStatic", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "content",
      "isStatic",
      "onPlaced"
    ],
    "restProps"
  );
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => floating_layer_content_static_default(node_1, {
          get content() {
            return $$props.content;
          },
          get onPlaced() {
            return $$props.onPlaced;
          }
        }),
        "component",
        Popper_content,
        15,
        1,
        { componentTag: "FloatingLayerContentStatic" }
      );
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      add_svelte_meta(
        () => floating_layer_content_default(node_2, spread_props(
          {
            get content() {
              return $$props.content;
            },
            get onPlaced() {
              return $$props.onPlaced;
            }
          },
          () => restProps
        )),
        "component",
        Popper_content,
        17,
        1,
        { componentTag: "FloatingLayerContent" }
      );
      append($$anchor2, fragment_2);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (isStatic()) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Popper_content,
      14,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popper_content = hmr(Popper_content, () => Popper_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popper_content[HMR].source;
    set(Popper_content[HMR].source, module.default[HMR].original);
  });
}
var popper_content_default = Popper_content;

// node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-layer-inner.svelte
Popper_layer_inner[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-layer-inner.svelte";
var root_12 = add_locations(from_html(`<!> <!>`, 1), Popper_layer_inner[FILENAME], []);
function Popper_layer_inner($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Popper_layer_inner);
  let interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), trapFocus = prop($$props, "trapFocus", 3, true), isValidEvent2 = prop($$props, "isValidEvent", 3, () => false), customAnchor = prop($$props, "customAnchor", 3, null), isStatic = prop($$props, "isStatic", 3, false), tooltip = prop($$props, "tooltip", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "popper",
      "onEscapeKeydown",
      "escapeKeydownBehavior",
      "preventOverflowTextSelection",
      "id",
      "onPointerDown",
      "onPointerUp",
      "side",
      "sideOffset",
      "align",
      "alignOffset",
      "arrowPadding",
      "avoidCollisions",
      "collisionBoundary",
      "collisionPadding",
      "sticky",
      "hideWhenDetached",
      "updatePositionStrategy",
      "strategy",
      "dir",
      "preventScroll",
      "wrapperId",
      "style",
      "onPlaced",
      "onInteractOutside",
      "onCloseAutoFocus",
      "onOpenAutoFocus",
      "onFocusOutside",
      "interactOutsideBehavior",
      "loop",
      "trapFocus",
      "isValidEvent",
      "customAnchor",
      "isStatic",
      "enabled",
      "ref",
      "tooltip"
    ],
    "restProps"
  );
  var fragment = comment();
  var node = first_child(fragment);
  {
    const content = wrap_snippet(Popper_layer_inner, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let floatingProps = () => $$arg0?.().props;
      floatingProps();
      let wrapperProps = () => $$arg0?.().wrapperProps;
      wrapperProps();
      var fragment_1 = root_12();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          add_svelte_meta(
            () => scroll_lock_default(node_2, {
              get preventScroll() {
                return $$props.preventScroll;
              }
            }),
            "component",
            Popper_layer_inner,
            80,
            3,
            { componentTag: "ScrollLock" }
          );
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var fragment_3 = comment();
          var node_3 = first_child(fragment_3);
          {
            var consequent_1 = ($$anchor4) => {
              var fragment_4 = comment();
              var node_4 = first_child(fragment_4);
              add_svelte_meta(
                () => scroll_lock_default(node_4, {
                  get preventScroll() {
                    return $$props.preventScroll;
                  }
                }),
                "component",
                Popper_layer_inner,
                82,
                3,
                { componentTag: "ScrollLock" }
              );
              append($$anchor4, fragment_4);
            };
            add_svelte_meta(
              () => if_block(
                node_3,
                ($$render) => {
                  if (!$$props.forceMount) $$render(consequent_1);
                },
                true
              ),
              "if",
              Popper_layer_inner,
              81,
              2
            );
          }
          append($$anchor3, fragment_3);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if ($$props.forceMount && $$props.enabled) $$render(consequent);
            else $$render(alternate, false);
          }),
          "if",
          Popper_layer_inner,
          79,
          2
        );
      }
      var node_5 = sibling(node_1, 2);
      {
        const focusScope = wrap_snippet(Popper_layer_inner, function($$anchor3, $$arg02) {
          validate_snippet_args(...arguments);
          let focusScopeProps = () => $$arg02?.().props;
          focusScopeProps();
          var fragment_5 = comment();
          var node_6 = first_child(fragment_5);
          add_svelte_meta(
            () => escape_layer_default(node_6, {
              get onEscapeKeydown() {
                return $$props.onEscapeKeydown;
              },
              get escapeKeydownBehavior() {
                return $$props.escapeKeydownBehavior;
              },
              get enabled() {
                return $$props.enabled;
              },
              get ref() {
                return $$props.ref;
              },
              children: wrap_snippet(Popper_layer_inner, ($$anchor4, $$slotProps) => {
                var fragment_6 = comment();
                var node_7 = first_child(fragment_6);
                {
                  const children = wrap_snippet(Popper_layer_inner, function($$anchor5, $$arg03) {
                    validate_snippet_args(...arguments);
                    let dismissibleProps = () => $$arg03?.().props;
                    dismissibleProps();
                    var fragment_7 = comment();
                    var node_8 = first_child(fragment_7);
                    add_svelte_meta(
                      () => text_selection_layer_default(node_8, {
                        get id() {
                          return $$props.id;
                        },
                        get preventOverflowTextSelection() {
                          return $$props.preventOverflowTextSelection;
                        },
                        get onPointerDown() {
                          return $$props.onPointerDown;
                        },
                        get onPointerUp() {
                          return $$props.onPointerUp;
                        },
                        get enabled() {
                          return $$props.enabled;
                        },
                        get ref() {
                          return $$props.ref;
                        },
                        children: wrap_snippet(Popper_layer_inner, ($$anchor6, $$slotProps2) => {
                          var fragment_8 = comment();
                          var node_9 = first_child(fragment_8);
                          {
                            let $0 = user_derived(() => ({
                              props: mergeProps(restProps, floatingProps(), dismissibleProps(), focusScopeProps(), { style: { pointerEvents: "auto" } }),
                              wrapperProps: wrapperProps()
                            }));
                            add_svelte_meta(() => snippet(node_9, () => $$props.popper ?? noop, () => get($0)), "render", Popper_layer_inner, 113, 8);
                          }
                          append($$anchor6, fragment_8);
                        }),
                        $$slots: { default: true }
                      }),
                      "component",
                      Popper_layer_inner,
                      105,
                      7,
                      { componentTag: "TextSelectionLayer" }
                    );
                    append($$anchor5, fragment_7);
                  });
                  add_svelte_meta(
                    () => dismissible_layer_default(node_7, {
                      get id() {
                        return $$props.id;
                      },
                      get onInteractOutside() {
                        return $$props.onInteractOutside;
                      },
                      get onFocusOutside() {
                        return $$props.onFocusOutside;
                      },
                      get interactOutsideBehavior() {
                        return interactOutsideBehavior();
                      },
                      get isValidEvent() {
                        return isValidEvent2();
                      },
                      get enabled() {
                        return $$props.enabled;
                      },
                      get ref() {
                        return $$props.ref;
                      },
                      children,
                      $$slots: { default: true }
                    }),
                    "component",
                    Popper_layer_inner,
                    95,
                    5,
                    { componentTag: "DismissibleLayer" }
                  );
                }
                append($$anchor4, fragment_6);
              }),
              $$slots: { default: true }
            }),
            "component",
            Popper_layer_inner,
            94,
            4,
            { componentTag: "EscapeLayer" }
          );
          append($$anchor3, fragment_5);
        });
        add_svelte_meta(
          () => focus_scope_default(node_5, {
            get onOpenAutoFocus() {
              return $$props.onOpenAutoFocus;
            },
            get onCloseAutoFocus() {
              return $$props.onCloseAutoFocus;
            },
            get loop() {
              return $$props.loop;
            },
            get enabled() {
              return $$props.enabled;
            },
            get trapFocus() {
              return trapFocus();
            },
            get forceMount() {
              return $$props.forceMount;
            },
            get ref() {
              return $$props.ref;
            },
            focusScope,
            $$slots: { focusScope: true }
          }),
          "component",
          Popper_layer_inner,
          84,
          2,
          { componentTag: "FocusScope" }
        );
      }
      append($$anchor2, fragment_1);
    });
    add_svelte_meta(
      () => popper_content_default(node, {
        get isStatic() {
          return isStatic();
        },
        get id() {
          return $$props.id;
        },
        get side() {
          return $$props.side;
        },
        get sideOffset() {
          return $$props.sideOffset;
        },
        get align() {
          return $$props.align;
        },
        get alignOffset() {
          return $$props.alignOffset;
        },
        get arrowPadding() {
          return $$props.arrowPadding;
        },
        get avoidCollisions() {
          return $$props.avoidCollisions;
        },
        get collisionBoundary() {
          return $$props.collisionBoundary;
        },
        get collisionPadding() {
          return $$props.collisionPadding;
        },
        get sticky() {
          return $$props.sticky;
        },
        get hideWhenDetached() {
          return $$props.hideWhenDetached;
        },
        get updatePositionStrategy() {
          return $$props.updatePositionStrategy;
        },
        get strategy() {
          return $$props.strategy;
        },
        get dir() {
          return $$props.dir;
        },
        get wrapperId() {
          return $$props.wrapperId;
        },
        get style() {
          return $$props.style;
        },
        get onPlaced() {
          return $$props.onPlaced;
        },
        get customAnchor() {
          return customAnchor();
        },
        get enabled() {
          return $$props.enabled;
        },
        get tooltip() {
          return tooltip();
        },
        content,
        $$slots: { content: true }
      }),
      "component",
      Popper_layer_inner,
      55,
      0,
      { componentTag: "PopperContent" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popper_layer_inner = hmr(Popper_layer_inner, () => Popper_layer_inner[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popper_layer_inner[HMR].source;
    set(Popper_layer_inner[HMR].source, module.default[HMR].original);
  });
}
var popper_layer_inner_default = Popper_layer_inner;

// node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-layer.svelte
Popper_layer[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-layer.svelte";
function Popper_layer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Popper_layer);
  let interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), trapFocus = prop($$props, "trapFocus", 3, true), isValidEvent2 = prop($$props, "isValidEvent", 3, () => false), customAnchor = prop($$props, "customAnchor", 3, null), isStatic = prop($$props, "isStatic", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "popper",
      "open",
      "onEscapeKeydown",
      "escapeKeydownBehavior",
      "preventOverflowTextSelection",
      "id",
      "onPointerDown",
      "onPointerUp",
      "side",
      "sideOffset",
      "align",
      "alignOffset",
      "arrowPadding",
      "avoidCollisions",
      "collisionBoundary",
      "collisionPadding",
      "sticky",
      "hideWhenDetached",
      "updatePositionStrategy",
      "strategy",
      "dir",
      "preventScroll",
      "wrapperId",
      "style",
      "onPlaced",
      "onInteractOutside",
      "onCloseAutoFocus",
      "onOpenAutoFocus",
      "onFocusOutside",
      "interactOutsideBehavior",
      "loop",
      "trapFocus",
      "isValidEvent",
      "customAnchor",
      "isStatic",
      "ref"
    ],
    "restProps"
  );
  var fragment = comment();
  var node = first_child(fragment);
  {
    const presence = wrap_snippet(Popper_layer, function($$anchor2) {
      validate_snippet_args(...arguments);
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => popper_layer_inner_default(node_1, spread_props(
          {
            get popper() {
              return $$props.popper;
            },
            get onEscapeKeydown() {
              return $$props.onEscapeKeydown;
            },
            get escapeKeydownBehavior() {
              return $$props.escapeKeydownBehavior;
            },
            get preventOverflowTextSelection() {
              return $$props.preventOverflowTextSelection;
            },
            get id() {
              return $$props.id;
            },
            get onPointerDown() {
              return $$props.onPointerDown;
            },
            get onPointerUp() {
              return $$props.onPointerUp;
            },
            get side() {
              return $$props.side;
            },
            get sideOffset() {
              return $$props.sideOffset;
            },
            get align() {
              return $$props.align;
            },
            get alignOffset() {
              return $$props.alignOffset;
            },
            get arrowPadding() {
              return $$props.arrowPadding;
            },
            get avoidCollisions() {
              return $$props.avoidCollisions;
            },
            get collisionBoundary() {
              return $$props.collisionBoundary;
            },
            get collisionPadding() {
              return $$props.collisionPadding;
            },
            get sticky() {
              return $$props.sticky;
            },
            get hideWhenDetached() {
              return $$props.hideWhenDetached;
            },
            get updatePositionStrategy() {
              return $$props.updatePositionStrategy;
            },
            get strategy() {
              return $$props.strategy;
            },
            get dir() {
              return $$props.dir;
            },
            get preventScroll() {
              return $$props.preventScroll;
            },
            get wrapperId() {
              return $$props.wrapperId;
            },
            get style() {
              return $$props.style;
            },
            get onPlaced() {
              return $$props.onPlaced;
            },
            get customAnchor() {
              return customAnchor();
            },
            get isStatic() {
              return isStatic();
            },
            get enabled() {
              return $$props.open;
            },
            get onInteractOutside() {
              return $$props.onInteractOutside;
            },
            get onCloseAutoFocus() {
              return $$props.onCloseAutoFocus;
            },
            get onOpenAutoFocus() {
              return $$props.onOpenAutoFocus;
            },
            get interactOutsideBehavior() {
              return interactOutsideBehavior();
            },
            get loop() {
              return $$props.loop;
            },
            get trapFocus() {
              return trapFocus();
            },
            get isValidEvent() {
              return isValidEvent2();
            },
            get onFocusOutside() {
              return $$props.onFocusOutside;
            },
            forceMount: false,
            get ref() {
              return $$props.ref;
            }
          },
          () => restProps
        )),
        "component",
        Popper_layer,
        49,
        2,
        { componentTag: "PopperLayerInner" }
      );
      append($$anchor2, fragment_1);
    });
    add_svelte_meta(
      () => presence_layer_default(node, {
        get open() {
          return $$props.open;
        },
        get ref() {
          return $$props.ref;
        },
        presence,
        $$slots: { presence: true }
      }),
      "component",
      Popper_layer,
      47,
      0,
      { componentTag: "PresenceLayer" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popper_layer = hmr(Popper_layer, () => Popper_layer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popper_layer[HMR].source;
    set(Popper_layer[HMR].source, module.default[HMR].original);
  });
}
var popper_layer_default = Popper_layer;

// node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-layer-force-mount.svelte
Popper_layer_force_mount[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/popper-layer/popper-layer-force-mount.svelte";
function Popper_layer_force_mount($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Popper_layer_force_mount);
  let interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), trapFocus = prop($$props, "trapFocus", 3, true), isValidEvent2 = prop($$props, "isValidEvent", 3, () => false), customAnchor = prop($$props, "customAnchor", 3, null), isStatic = prop($$props, "isStatic", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "popper",
      "onEscapeKeydown",
      "escapeKeydownBehavior",
      "preventOverflowTextSelection",
      "id",
      "onPointerDown",
      "onPointerUp",
      "side",
      "sideOffset",
      "align",
      "alignOffset",
      "arrowPadding",
      "avoidCollisions",
      "collisionBoundary",
      "collisionPadding",
      "sticky",
      "hideWhenDetached",
      "updatePositionStrategy",
      "strategy",
      "dir",
      "preventScroll",
      "wrapperId",
      "style",
      "onPlaced",
      "onInteractOutside",
      "onCloseAutoFocus",
      "onOpenAutoFocus",
      "onFocusOutside",
      "interactOutsideBehavior",
      "loop",
      "trapFocus",
      "isValidEvent",
      "customAnchor",
      "isStatic",
      "enabled"
    ],
    "restProps"
  );
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => popper_layer_inner_default(node, spread_props(
      {
        get popper() {
          return $$props.popper;
        },
        get onEscapeKeydown() {
          return $$props.onEscapeKeydown;
        },
        get escapeKeydownBehavior() {
          return $$props.escapeKeydownBehavior;
        },
        get preventOverflowTextSelection() {
          return $$props.preventOverflowTextSelection;
        },
        get id() {
          return $$props.id;
        },
        get onPointerDown() {
          return $$props.onPointerDown;
        },
        get onPointerUp() {
          return $$props.onPointerUp;
        },
        get side() {
          return $$props.side;
        },
        get sideOffset() {
          return $$props.sideOffset;
        },
        get align() {
          return $$props.align;
        },
        get alignOffset() {
          return $$props.alignOffset;
        },
        get arrowPadding() {
          return $$props.arrowPadding;
        },
        get avoidCollisions() {
          return $$props.avoidCollisions;
        },
        get collisionBoundary() {
          return $$props.collisionBoundary;
        },
        get collisionPadding() {
          return $$props.collisionPadding;
        },
        get sticky() {
          return $$props.sticky;
        },
        get hideWhenDetached() {
          return $$props.hideWhenDetached;
        },
        get updatePositionStrategy() {
          return $$props.updatePositionStrategy;
        },
        get strategy() {
          return $$props.strategy;
        },
        get dir() {
          return $$props.dir;
        },
        get preventScroll() {
          return $$props.preventScroll;
        },
        get wrapperId() {
          return $$props.wrapperId;
        },
        get style() {
          return $$props.style;
        },
        get onPlaced() {
          return $$props.onPlaced;
        },
        get customAnchor() {
          return customAnchor();
        },
        get isStatic() {
          return isStatic();
        },
        get enabled() {
          return $$props.enabled;
        },
        get onInteractOutside() {
          return $$props.onInteractOutside;
        },
        get onCloseAutoFocus() {
          return $$props.onCloseAutoFocus;
        },
        get onOpenAutoFocus() {
          return $$props.onOpenAutoFocus;
        },
        get interactOutsideBehavior() {
          return interactOutsideBehavior();
        },
        get loop() {
          return $$props.loop;
        },
        get trapFocus() {
          return trapFocus();
        },
        get isValidEvent() {
          return isValidEvent2();
        },
        get onFocusOutside() {
          return $$props.onFocusOutside;
        }
      },
      () => restProps,
      { forceMount: true }
    )),
    "component",
    Popper_layer_force_mount,
    47,
    0,
    { componentTag: "PopperLayerInner" }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popper_layer_force_mount = hmr(Popper_layer_force_mount, () => Popper_layer_force_mount[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popper_layer_force_mount[HMR].source;
    set(Popper_layer_force_mount[HMR].source, module.default[HMR].original);
  });
}
var popper_layer_force_mount_default = Popper_layer_force_mount;

// node_modules/bits-ui/dist/bits/select/components/select-content.svelte
Select_content[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-content.svelte";
var root_42 = add_locations(from_html(`<div><div><!></div></div>`), Select_content[FILENAME], [[54, 4, [[55, 5]]]]);
var root_9 = add_locations(from_html(`<div><div><!></div></div>`), Select_content[FILENAME], [[78, 4, [[79, 5]]]]);
function Select_content($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Select_content);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), side = prop($$props, "side", 3, "bottom"), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), preventScroll = prop($$props, "preventScroll", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "forceMount",
      "side",
      "onInteractOutside",
      "onEscapeKeydown",
      "children",
      "child",
      "preventScroll"
    ],
    "restProps"
  );
  const contentState = SelectContentState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onInteractOutside: box.with(() => onInteractOutside()),
    onEscapeKeydown: box.with(() => onEscapeKeydown())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Select_content, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0?.().props;
          props();
          let wrapperProps = () => $$arg0?.().wrapperProps;
          wrapperProps();
          var fragment_2 = comment();
          const finalProps = tag(user_derived(() => mergeProps(props(), { style: contentState.props.style })), "finalProps");
          get(finalProps);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              {
                let $0 = user_derived(() => ({
                  props: get(finalProps),
                  wrapperProps: wrapperProps(),
                  ...contentState.snippetProps
                }));
                add_svelte_meta(() => snippet(node_3, () => $$props.child, () => get($0)), "render", Select_content, 52, 4);
              }
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_42();
              attribute_effect(div, () => ({ ...wrapperProps() }));
              var div_1 = child(div);
              attribute_effect(div_1, () => ({ ...get(finalProps) }));
              var node_4 = child(div_1);
              add_svelte_meta(() => snippet(node_4, () => $$props.children ?? noop), "render", Select_content, 56, 6);
              reset(div_1);
              reset(div);
              append($$anchor4, div);
            };
            add_svelte_meta(
              () => if_block(node_2, ($$render) => {
                if ($$props.child) $$render(consequent);
                else $$render(alternate, false);
              }),
              "if",
              Select_content,
              51,
              3
            );
          }
          append($$anchor3, fragment_2);
        });
        add_svelte_meta(
          () => popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), () => contentState.popperProps, {
            get ref() {
              return contentState.opts.ref;
            },
            get side() {
              return side();
            },
            get enabled() {
              return contentState.root.opts.open.current;
            },
            get id() {
              return id();
            },
            get preventScroll() {
              return preventScroll();
            },
            forceMount: true,
            popper,
            $$slots: { popper: true }
          })),
          "component",
          Select_content,
          39,
          1,
          { componentTag: "PopperLayerForceMount" }
        );
      }
      append($$anchor2, fragment_1);
    };
    var alternate_2 = ($$anchor2) => {
      var fragment_4 = comment();
      var node_5 = first_child(fragment_4);
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_5 = comment();
          var node_6 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Select_content, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0?.().props;
              props();
              let wrapperProps = () => $$arg0?.().wrapperProps;
              wrapperProps();
              var fragment_6 = comment();
              const finalProps = tag(user_derived(() => mergeProps(props(), { style: contentState.props.style })), "finalProps");
              get(finalProps);
              var node_7 = first_child(fragment_6);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_8 = first_child(fragment_7);
                  {
                    let $0 = user_derived(() => ({
                      props: get(finalProps),
                      wrapperProps: wrapperProps(),
                      ...contentState.snippetProps
                    }));
                    add_svelte_meta(() => snippet(node_8, () => $$props.child, () => get($0)), "render", Select_content, 76, 4);
                  }
                  append($$anchor5, fragment_7);
                };
                var alternate_1 = ($$anchor5) => {
                  var div_2 = root_9();
                  attribute_effect(div_2, () => ({ ...wrapperProps() }));
                  var div_3 = child(div_2);
                  attribute_effect(div_3, () => ({ ...get(finalProps) }));
                  var node_9 = child(div_3);
                  add_svelte_meta(() => snippet(node_9, () => $$props.children ?? noop), "render", Select_content, 80, 6);
                  reset(div_3);
                  reset(div_2);
                  append($$anchor5, div_2);
                };
                add_svelte_meta(
                  () => if_block(node_7, ($$render) => {
                    if ($$props.child) $$render(consequent_2);
                    else $$render(alternate_1, false);
                  }),
                  "if",
                  Select_content,
                  75,
                  3
                );
              }
              append($$anchor4, fragment_6);
            });
            add_svelte_meta(
              () => popper_layer_default(node_6, spread_props(() => get(mergedProps), () => contentState.popperProps, {
                get ref() {
                  return contentState.opts.ref;
                },
                get side() {
                  return side();
                },
                get open() {
                  return contentState.root.opts.open.current;
                },
                get id() {
                  return id();
                },
                get preventScroll() {
                  return preventScroll();
                },
                forceMount: false,
                popper,
                $$slots: { popper: true }
              })),
              "component",
              Select_content,
              63,
              1,
              { componentTag: "PopperLayer" }
            );
          }
          append($$anchor3, fragment_5);
        };
        add_svelte_meta(
          () => if_block(
            node_5,
            ($$render) => {
              if (!forceMount()) $$render(consequent_3);
            },
            true
          ),
          "if",
          Select_content,
          62,
          0
        );
      }
      append($$anchor2, fragment_4);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (forceMount()) $$render(consequent_1);
        else $$render(alternate_2, false);
      }),
      "if",
      Select_content,
      38,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select_content = hmr(Select_content, () => Select_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select_content[HMR].source;
    set(Select_content[HMR].source, module.default[HMR].original);
  });
}
var select_content_default = Select_content;

// node_modules/bits-ui/dist/bits/select/components/select-content-static.svelte
Select_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-content-static.svelte";
var root_43 = add_locations(from_html(`<div><!></div>`), Select_content_static[FILENAME], [[53, 4]]);
var root_92 = add_locations(from_html(`<div><!></div>`), Select_content_static[FILENAME], [[75, 4]]);
function Select_content_static($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Select_content_static);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), preventScroll = prop($$props, "preventScroll", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "forceMount",
      "onInteractOutside",
      "onEscapeKeydown",
      "children",
      "child",
      "preventScroll"
    ],
    "restProps"
  );
  const contentState = SelectContentState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onInteractOutside: box.with(() => onInteractOutside()),
    onEscapeKeydown: box.with(() => onEscapeKeydown())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Select_content_static, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0?.().props;
          props();
          var fragment_2 = comment();
          const finalProps = tag(user_derived(() => mergeProps(props(), { style: contentState.props.style })), "finalProps");
          get(finalProps);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              {
                let $0 = user_derived(() => ({ props: get(finalProps), ...contentState.snippetProps }));
                add_svelte_meta(() => snippet(node_3, () => $$props.child, () => get($0)), "render", Select_content_static, 51, 4);
              }
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_43();
              attribute_effect(div, () => ({ ...get(finalProps) }));
              var node_4 = child(div);
              add_svelte_meta(() => snippet(node_4, () => $$props.children ?? noop), "render", Select_content_static, 54, 5);
              reset(div);
              append($$anchor4, div);
            };
            add_svelte_meta(
              () => if_block(node_2, ($$render) => {
                if ($$props.child) $$render(consequent);
                else $$render(alternate, false);
              }),
              "if",
              Select_content_static,
              50,
              3
            );
          }
          append($$anchor3, fragment_2);
        });
        add_svelte_meta(
          () => popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), () => contentState.popperProps, {
            get ref() {
              return contentState.opts.ref;
            },
            isStatic: true,
            get enabled() {
              return contentState.root.opts.open.current;
            },
            get id() {
              return id();
            },
            get preventScroll() {
              return preventScroll();
            },
            forceMount: true,
            popper,
            $$slots: { popper: true }
          })),
          "component",
          Select_content_static,
          38,
          1,
          { componentTag: "PopperLayerForceMount" }
        );
      }
      append($$anchor2, fragment_1);
    };
    var alternate_2 = ($$anchor2) => {
      var fragment_4 = comment();
      var node_5 = first_child(fragment_4);
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_5 = comment();
          var node_6 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Select_content_static, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0?.().props;
              props();
              var fragment_6 = comment();
              const finalProps = tag(user_derived(() => mergeProps(props(), { style: contentState.props.style })), "finalProps");
              get(finalProps);
              var node_7 = first_child(fragment_6);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_8 = first_child(fragment_7);
                  {
                    let $0 = user_derived(() => ({ props: get(finalProps), ...contentState.snippetProps }));
                    add_svelte_meta(() => snippet(node_8, () => $$props.child, () => get($0)), "render", Select_content_static, 73, 4);
                  }
                  append($$anchor5, fragment_7);
                };
                var alternate_1 = ($$anchor5) => {
                  var div_1 = root_92();
                  attribute_effect(div_1, () => ({ ...get(finalProps) }));
                  var node_9 = child(div_1);
                  add_svelte_meta(() => snippet(node_9, () => $$props.children ?? noop), "render", Select_content_static, 76, 5);
                  reset(div_1);
                  append($$anchor5, div_1);
                };
                add_svelte_meta(
                  () => if_block(node_7, ($$render) => {
                    if ($$props.child) $$render(consequent_2);
                    else $$render(alternate_1, false);
                  }),
                  "if",
                  Select_content_static,
                  72,
                  3
                );
              }
              append($$anchor4, fragment_6);
            });
            add_svelte_meta(
              () => popper_layer_default(node_6, spread_props(() => get(mergedProps), () => contentState.popperProps, {
                get ref() {
                  return contentState.opts.ref;
                },
                isStatic: true,
                get open() {
                  return contentState.root.opts.open.current;
                },
                get id() {
                  return id();
                },
                get preventScroll() {
                  return preventScroll();
                },
                forceMount: false,
                popper,
                $$slots: { popper: true }
              })),
              "component",
              Select_content_static,
              60,
              1,
              { componentTag: "PopperLayer" }
            );
          }
          append($$anchor3, fragment_5);
        };
        add_svelte_meta(
          () => if_block(
            node_5,
            ($$render) => {
              if (!forceMount()) $$render(consequent_3);
            },
            true
          ),
          "if",
          Select_content_static,
          59,
          0
        );
      }
      append($$anchor2, fragment_4);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (forceMount()) $$render(consequent_1);
        else $$render(alternate_2, false);
      }),
      "if",
      Select_content_static,
      37,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select_content_static = hmr(Select_content_static, () => Select_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select_content_static[HMR].source;
    set(Select_content_static[HMR].source, module.default[HMR].original);
  });
}
var select_content_static_default = Select_content_static;

// node_modules/bits-ui/dist/bits/utilities/mounted.svelte
Mounted[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/mounted.svelte";
function Mounted($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Mounted);
  let mounted = prop($$props, "mounted", 15, false), onMountedChange = prop($$props, "onMountedChange", 3, noop3);
  onMountEffect(() => {
    mounted(true);
    onMountedChange()(true);
    return () => {
      mounted(false);
      onMountedChange()(false);
    };
  });
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Mounted = hmr(Mounted, () => Mounted[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Mounted[HMR].source;
    set(Mounted[HMR].source, module.default[HMR].original);
  });
}
var mounted_default = Mounted;

// node_modules/bits-ui/dist/bits/select/components/select-item.svelte
Select_item[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-item.svelte";
var root_237 = add_locations(from_html(`<div><!></div>`), Select_item[FILENAME], [[43, 1]]);
var root4 = add_locations(from_html(`<!> <!>`, 1), Select_item[FILENAME], []);
function Select_item($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Select_item);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), label = prop($$props, "label", 19, () => $$props.value), disabled = prop($$props, "disabled", 3, false), onHighlight = prop($$props, "onHighlight", 3, noop3), onUnhighlight = prop($$props, "onUnhighlight", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "label",
      "disabled",
      "children",
      "child",
      "onHighlight",
      "onUnhighlight"
    ],
    "restProps"
  );
  const itemState = SelectItemState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    value: box.with(() => $$props.value),
    disabled: box.with(() => disabled()),
    label: box.with(() => label()),
    onHighlight: box.with(() => onHighlight()),
    onUnhighlight: box.with(() => onUnhighlight())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, itemState.props)), "mergedProps");
  var fragment = root4();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => ({ props: get(mergedProps), ...itemState.snippetProps }));
        add_svelte_meta(() => snippet(node_1, () => $$props.child, () => get($0)), "render", Select_item, 41, 1);
      }
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_237();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => itemState.snippetProps), "render", Select_item, 44, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Select_item,
      40,
      0
    );
  }
  var node_3 = sibling(node, 2);
  validate_binding("bind:mounted={itemState.mounted}", () => itemState, () => "mounted", 48, 9);
  add_svelte_meta(
    () => mounted_default(node_3, {
      get mounted() {
        return itemState.mounted;
      },
      set mounted($$value) {
        itemState.mounted = $$value;
      }
    }),
    "component",
    Select_item,
    48,
    0,
    { componentTag: "Mounted" }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select_item = hmr(Select_item, () => Select_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select_item[HMR].source;
    set(Select_item[HMR].source, module.default[HMR].original);
  });
}
var select_item_default = Select_item;

// node_modules/bits-ui/dist/bits/select/components/select-group.svelte
Select_group[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-group.svelte";
var root_238 = add_locations(from_html(`<div><!></div>`), Select_group[FILENAME], [[31, 1]]);
function Select_group($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Select_group);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const groupState = SelectGroupState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, groupState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Select_group, 29, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_238();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Select_group, 32, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Select_group,
      28,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select_group = hmr(Select_group, () => Select_group[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select_group[HMR].source;
    set(Select_group[HMR].source, module.default[HMR].original);
  });
}
var select_group_default = Select_group;

// node_modules/bits-ui/dist/bits/select/components/select-group-heading.svelte
Select_group_heading[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-group-heading.svelte";
var root_239 = add_locations(from_html(`<div><!></div>`), Select_group_heading[FILENAME], [[30, 1]]);
function Select_group_heading($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Select_group_heading);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "children"
    ],
    "restProps"
  );
  const groupHeadingState = SelectGroupHeadingState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, groupHeadingState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Select_group_heading, 28, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_239();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Select_group_heading, 31, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Select_group_heading,
      27,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select_group_heading = hmr(Select_group_heading, () => Select_group_heading[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select_group_heading[HMR].source;
    set(Select_group_heading[HMR].source, module.default[HMR].original);
  });
}
var select_group_heading_default = Select_group_heading;

// node_modules/bits-ui/dist/bits/select/components/select-viewport.svelte
Select_viewport[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-viewport.svelte";
var root_240 = add_locations(from_html(`<div><!></div>`), Select_viewport[FILENAME], [[31, 1]]);
var $$css = {
  hash: "s-h2z5b8x4s9UG",
  code: "\n	/* Hide scrollbars cross browser and enable momentum scroll for touch devices */\n	[data-select-viewport] {\n		scrollbar-width: none !important;\n		-ms-overflow-style: none !important;\n		-webkit-overflow-scrolling: touch !important;\n	}\n\n	[data-combobox-viewport] {\n		scrollbar-width: none !important;\n		-ms-overflow-style: none !important;\n		-webkit-overflow-scrolling: touch !important;\n	}\n\n	[data-combobox-viewport]::-webkit-scrollbar {\n		display: none !important;\n	}\n	[data-select-viewport]::-webkit-scrollbar {\n		display: none !important;\n	}\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0LXZpZXdwb3J0LnN2ZWx0ZSIsInNvdXJjZXMiOlsic2VsZWN0LXZpZXdwb3J0LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuXHRpbXBvcnQgeyBib3gsIG1lcmdlUHJvcHMgfSBmcm9tIFwic3ZlbHRlLXRvb2xiZWx0XCI7XG5cdGltcG9ydCB0eXBlIHsgU2VsZWN0Vmlld3BvcnRQcm9wcyB9IGZyb20gXCIuLi90eXBlcy5qc1wiO1xuXHRpbXBvcnQgeyBTZWxlY3RWaWV3cG9ydFN0YXRlIH0gZnJvbSBcIi4uL3NlbGVjdC5zdmVsdGUuanNcIjtcblx0aW1wb3J0IHsgY3JlYXRlSWQgfSBmcm9tIFwiLi4vLi4vLi4vaW50ZXJuYWwvY3JlYXRlLWlkLmpzXCI7XG5cblx0Y29uc3QgdWlkID0gJHByb3BzLmlkKCk7XG5cblx0bGV0IHtcblx0XHRpZCA9IGNyZWF0ZUlkKHVpZCksXG5cdFx0cmVmID0gJGJpbmRhYmxlKG51bGwpLFxuXHRcdGNoaWxkcmVuLFxuXHRcdGNoaWxkLFxuXHRcdC4uLnJlc3RQcm9wc1xuXHR9OiBTZWxlY3RWaWV3cG9ydFByb3BzID0gJHByb3BzKCk7XG5cblx0Y29uc3Qgdmlld3BvcnRTdGF0ZSA9IFNlbGVjdFZpZXdwb3J0U3RhdGUuY3JlYXRlKHtcblx0XHRpZDogYm94LndpdGgoKCkgPT4gaWQpLFxuXHRcdHJlZjogYm94LndpdGgoXG5cdFx0XHQoKSA9PiByZWYsXG5cdFx0XHQodikgPT4gKHJlZiA9IHYpXG5cdFx0KSxcblx0fSk7XG5cblx0Y29uc3QgbWVyZ2VkUHJvcHMgPSAkZGVyaXZlZChtZXJnZVByb3BzKHJlc3RQcm9wcywgdmlld3BvcnRTdGF0ZS5wcm9wcykpO1xuPC9zY3JpcHQ+XG5cbnsjaWYgY2hpbGR9XG5cdHtAcmVuZGVyIGNoaWxkKHsgcHJvcHM6IG1lcmdlZFByb3BzIH0pfVxuezplbHNlfVxuXHQ8ZGl2IHsuLi5tZXJnZWRQcm9wc30+XG5cdFx0e0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuXHQ8L2Rpdj5cbnsvaWZ9XG5cbjxzdHlsZT5cblx0LyogSGlkZSBzY3JvbGxiYXJzIGNyb3NzIGJyb3dzZXIgYW5kIGVuYWJsZSBtb21lbnR1bSBzY3JvbGwgZm9yIHRvdWNoIGRldmljZXMgKi9cblx0Omdsb2JhbChbZGF0YS1zZWxlY3Qtdmlld3BvcnRdKSB7XG5cdFx0c2Nyb2xsYmFyLXdpZHRoOiBub25lICFpbXBvcnRhbnQ7XG5cdFx0LW1zLW92ZXJmbG93LXN0eWxlOiBub25lICFpbXBvcnRhbnQ7XG5cdFx0LXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoICFpbXBvcnRhbnQ7XG5cdH1cblxuXHQ6Z2xvYmFsKFtkYXRhLWNvbWJvYm94LXZpZXdwb3J0XSkge1xuXHRcdHNjcm9sbGJhci13aWR0aDogbm9uZSAhaW1wb3J0YW50O1xuXHRcdC1tcy1vdmVyZmxvdy1zdHlsZTogbm9uZSAhaW1wb3J0YW50O1xuXHRcdC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaCAhaW1wb3J0YW50O1xuXHR9XG5cblx0Omdsb2JhbChbZGF0YS1jb21ib2JveC12aWV3cG9ydF0pOjotd2Via2l0LXNjcm9sbGJhciB7XG5cdFx0ZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xuXHR9XG5cdDpnbG9iYWwoW2RhdGEtc2VsZWN0LXZpZXdwb3J0XSk6Oi13ZWJraXQtc2Nyb2xsYmFyIHtcblx0XHRkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XG5cdH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImlnbm9yZUxpc3QiOltdfQ== */"
};
function Select_viewport($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Select_viewport);
  append_styles($$anchor, $$css);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const viewportState = SelectViewportState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, viewportState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Select_viewport, 29, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_240();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Select_viewport, 32, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Select_viewport,
      28,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select_viewport = hmr(Select_viewport, () => Select_viewport[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-h2z5b8x4s9UG");
    module.default[HMR].source = Select_viewport[HMR].source;
    set(Select_viewport[HMR].source, module.default[HMR].original);
  });
}
var select_viewport_default = Select_viewport;

// node_modules/bits-ui/dist/bits/select/components/select-scroll-down-button.svelte
Select_scroll_down_button[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-scroll-down-button.svelte";
var root_35 = add_locations(from_html(`<div><!></div>`), Select_scroll_down_button[FILENAME], [[36, 2]]);
var root_13 = add_locations(from_html(`<!> <!>`, 1), Select_scroll_down_button[FILENAME], []);
function Select_scroll_down_button($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Select_scroll_down_button);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), delay = prop($$props, "delay", 3, () => 50), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "delay",
      "child",
      "children"
    ],
    "restProps"
  );
  const scrollButtonState = SelectScrollDownButtonState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    delay: box.with(() => delay())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, scrollButtonState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = root_13();
      var node_1 = first_child(fragment_1);
      validate_binding("bind:mounted={scrollButtonState.scrollButtonState.mounted}", () => scrollButtonState.scrollButtonState, () => "mounted", 32, 10);
      add_svelte_meta(
        () => mounted_default(node_1, {
          get mounted() {
            return scrollButtonState.scrollButtonState.mounted;
          },
          set mounted($$value) {
            scrollButtonState.scrollButtonState.mounted = $$value;
          }
        }),
        "component",
        Select_scroll_down_button,
        32,
        1,
        { componentTag: "Mounted" }
      );
      var node_2 = sibling(node_1, 2);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          add_svelte_meta(() => snippet(node_3, () => $$props.child, () => ({ props: restProps })), "render", Select_scroll_down_button, 34, 2);
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var div = root_35();
          attribute_effect(div, () => ({ ...get(mergedProps) }));
          var node_4 = child(div);
          add_svelte_meta(() => snippet(node_4, () => $$props.children ?? noop), "render", Select_scroll_down_button, 37, 3);
          reset(div);
          append($$anchor3, div);
        };
        add_svelte_meta(
          () => if_block(node_2, ($$render) => {
            if ($$props.child) $$render(consequent);
            else $$render(alternate, false);
          }),
          "if",
          Select_scroll_down_button,
          33,
          1
        );
      }
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (scrollButtonState.canScrollDown) $$render(consequent_1);
      }),
      "if",
      Select_scroll_down_button,
      31,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select_scroll_down_button = hmr(Select_scroll_down_button, () => Select_scroll_down_button[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select_scroll_down_button[HMR].source;
    set(Select_scroll_down_button[HMR].source, module.default[HMR].original);
  });
}
var select_scroll_down_button_default = Select_scroll_down_button;

// node_modules/bits-ui/dist/bits/select/components/select-scroll-up-button.svelte
Select_scroll_up_button[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-scroll-up-button.svelte";
var root_36 = add_locations(from_html(`<div><!></div>`), Select_scroll_up_button[FILENAME], [[36, 2]]);
var root_14 = add_locations(from_html(`<!> <!>`, 1), Select_scroll_up_button[FILENAME], []);
function Select_scroll_up_button($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Select_scroll_up_button);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), delay = prop($$props, "delay", 3, () => 50), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "delay",
      "child",
      "children"
    ],
    "restProps"
  );
  const scrollButtonState = SelectScrollUpButtonState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    delay: box.with(() => delay())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, scrollButtonState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = root_14();
      var node_1 = first_child(fragment_1);
      validate_binding("bind:mounted={scrollButtonState.scrollButtonState.mounted}", () => scrollButtonState.scrollButtonState, () => "mounted", 32, 10);
      add_svelte_meta(
        () => mounted_default(node_1, {
          get mounted() {
            return scrollButtonState.scrollButtonState.mounted;
          },
          set mounted($$value) {
            scrollButtonState.scrollButtonState.mounted = $$value;
          }
        }),
        "component",
        Select_scroll_up_button,
        32,
        1,
        { componentTag: "Mounted" }
      );
      var node_2 = sibling(node_1, 2);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          add_svelte_meta(() => snippet(node_3, () => $$props.child, () => ({ props: restProps })), "render", Select_scroll_up_button, 34, 2);
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var div = root_36();
          attribute_effect(div, () => ({ ...get(mergedProps) }));
          var node_4 = child(div);
          add_svelte_meta(() => snippet(node_4, () => $$props.children ?? noop), "render", Select_scroll_up_button, 37, 3);
          reset(div);
          append($$anchor3, div);
        };
        add_svelte_meta(
          () => if_block(node_2, ($$render) => {
            if ($$props.child) $$render(consequent);
            else $$render(alternate, false);
          }),
          "if",
          Select_scroll_up_button,
          33,
          1
        );
      }
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (scrollButtonState.canScrollUp) $$render(consequent_1);
      }),
      "if",
      Select_scroll_up_button,
      31,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select_scroll_up_button = hmr(Select_scroll_up_button, () => Select_scroll_up_button[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select_scroll_up_button[HMR].source;
    set(Select_scroll_up_button[HMR].source, module.default[HMR].original);
  });
}
var select_scroll_up_button_default = Select_scroll_up_button;

// node_modules/bits-ui/dist/bits/command/exports.js
var exports_exports10 = {};
__export(exports_exports10, {
  Empty: () => command_empty_default,
  Group: () => command_group_default,
  GroupHeading: () => command_group_heading_default,
  GroupItems: () => command_group_items_default,
  Input: () => command_input_default,
  Item: () => command_item_default,
  LinkItem: () => command_link_item_default,
  List: () => command_list_default,
  Loading: () => command_loading_default,
  Root: () => command_default,
  Separator: () => command_separator_default,
  Viewport: () => command_viewport_default
});

// node_modules/bits-ui/dist/bits/command/utils.js
function findNextSibling(el, selector) {
  let sibling2 = el.nextElementSibling;
  while (sibling2) {
    if (sibling2.matches(selector))
      return sibling2;
    sibling2 = sibling2.nextElementSibling;
  }
}
function findPreviousSibling(el, selector) {
  let sibling2 = el.previousElementSibling;
  while (sibling2) {
    if (sibling2.matches(selector))
      return sibling2;
    sibling2 = sibling2.previousElementSibling;
  }
}

// node_modules/bits-ui/dist/internal/css-escape.js
function cssEscape(value) {
  if (typeof CSS !== "undefined" && typeof CSS.escape === "function") {
    return CSS.escape(value);
  }
  const length = value.length;
  let index = -1;
  let codeUnit;
  let result = "";
  const firstCodeUnit = value.charCodeAt(0);
  if (length === 1 && firstCodeUnit === 45)
    return "\\" + value;
  while (++index < length) {
    codeUnit = value.charCodeAt(index);
    if (codeUnit === 0) {
      result += "";
      continue;
    }
    if (
      // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is U+007F
      codeUnit >= 1 && codeUnit <= 31 || codeUnit === 127 || // If the character is the first character and is in the range [0-9] (U+0030 to U+0039)
      index === 0 && codeUnit >= 48 && codeUnit <= 57 || // If the character is the second character and is in the range [0-9] (U+0030 to U+0039)
      // and the first character is a `-` (U+002D)
      index === 1 && codeUnit >= 48 && codeUnit <= 57 && firstCodeUnit === 45
    ) {
      result += "\\" + codeUnit.toString(16) + " ";
      continue;
    }
    if (codeUnit >= 128 || codeUnit === 45 || codeUnit === 95 || codeUnit >= 48 && codeUnit <= 57 || codeUnit >= 65 && codeUnit <= 90 || codeUnit >= 97 && codeUnit <= 122) {
      result += value.charAt(index);
      continue;
    }
    result += "\\" + value.charAt(index);
  }
  return result;
}

// node_modules/bits-ui/dist/bits/command/command.svelte.js
var COMMAND_VALUE_ATTR = "data-value";
var commandAttrs = createBitsAttrs({
  component: "command",
  parts: [
    "root",
    "list",
    "input",
    "separator",
    "loading",
    "empty",
    "group",
    "group-items",
    "group-heading",
    "item",
    "viewport",
    "input-label"
  ]
});
var COMMAND_GROUP_SELECTOR = commandAttrs.selector("group");
var COMMAND_GROUP_ITEMS_SELECTOR = commandAttrs.selector("group-items");
var COMMAND_GROUP_HEADING_SELECTOR = commandAttrs.selector("group-heading");
var COMMAND_ITEM_SELECTOR = commandAttrs.selector("item");
var COMMAND_VALID_ITEM_SELECTOR = `${commandAttrs.selector("item")}:not([aria-disabled="true"])`;
var CommandRootContext = new Context("Command.Root");
var CommandListContext = new Context("Command.List");
var CommandGroupContainerContext = new Context("Command.Group");
var defaultState = {
  search: "",
  value: "",
  filtered: { count: 0, items: /* @__PURE__ */ new Map(), groups: /* @__PURE__ */ new Set() }
};
var CommandRootState = class _CommandRootState {
  static create(opts) {
    return CommandRootContext.set(new _CommandRootState(opts));
  }
  opts;
  attachment;
  #updateScheduled = false;
  #isInitialMount = true;
  sortAfterTick = false;
  sortAndFilterAfterTick = false;
  allItems = /* @__PURE__ */ new Set();
  allGroups = /* @__PURE__ */ new Map();
  allIds = /* @__PURE__ */ new Map();
  #key = tag(
    state(
      // attempt to prevent the harsh delay when user is typing fast
      0
    ),
    "CommandRootState.key"
  );
  get key() {
    return get(this.#key);
  }
  set key(value) {
    set(this.#key, value, true);
  }
  #viewportNode = tag(state(null), "CommandRootState.viewportNode");
  get viewportNode() {
    return get(this.#viewportNode);
  }
  set viewportNode(value) {
    set(this.#viewportNode, value, true);
  }
  #inputNode = tag(state(null), "CommandRootState.inputNode");
  get inputNode() {
    return get(this.#inputNode);
  }
  set inputNode(value) {
    set(this.#inputNode, value, true);
  }
  #labelNode = tag(state(null), "CommandRootState.labelNode");
  get labelNode() {
    return get(this.#labelNode);
  }
  set labelNode(value) {
    set(this.#labelNode, value, true);
  }
  #commandState = tag(state(defaultState), "CommandRootState.commandState");
  get commandState() {
    return get(this.#commandState);
  }
  set commandState(value) {
    set(this.#commandState, value);
  }
  #_commandState = tag(state(proxy(defaultState)), "CommandRootState._commandState");
  get _commandState() {
    return get(this.#_commandState);
  }
  set _commandState(value) {
    set(this.#_commandState, value, true);
  }
  #snapshot() {
    return snapshot(this._commandState);
  }
  #scheduleUpdate() {
    if (this.#updateScheduled) return;
    this.#updateScheduled = true;
    afterTick(() => {
      this.#updateScheduled = false;
      const currentState = this.#snapshot();
      const hasStateChanged = !Object.is(this.commandState, currentState);
      if (hasStateChanged) {
        this.commandState = currentState;
        this.opts.onStateChange?.current?.(currentState);
      }
    });
  }
  setState(key2, value, preventScroll) {
    if (Object.is(this._commandState[key2], value)) return;
    this._commandState[key2] = value;
    if (strict_equals(key2, "search")) {
      this.#filterItems();
      this.#sort();
    } else if (strict_equals(key2, "value")) {
      if (!preventScroll) this.#scrollSelectedIntoView();
    }
    this.#scheduleUpdate();
  }
  constructor(opts) {
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    const defaults = { ...this._commandState, value: this.opts.value.current ?? "" };
    this._commandState = defaults;
    this.commandState = defaults;
    this.onkeydown = this.onkeydown.bind(this);
  }
  /**
   * Calculates score for an item based on search text and keywords.
   * Higher score = better match.
   *
   * @param value - Item's display text
   * @param keywords - Optional keywords to boost scoring
   * @returns Score from 0-1, where 0 = no match
   */
  #score(value, keywords) {
    const filter = this.opts.filter.current ?? computeCommandScore;
    const score = value ? filter(value, this._commandState.search, keywords) : 0;
    return score;
  }
  /**
   * Sorts items and groups based on search scores.
   * Groups are sorted by their highest scoring item.
   * When no search active, selects first item.
   */
  #sort() {
    if (!this._commandState.search || strict_equals(this.opts.shouldFilter.current, false)) {
      this.#selectFirstItem();
      return;
    }
    const scores = this._commandState.filtered.items;
    const groups = [];
    for (const value of this._commandState.filtered.groups) {
      const items = this.allGroups.get(value);
      let max = 0;
      if (!items) {
        groups.push([value, max]);
        continue;
      }
      for (const item of items) {
        const score = scores.get(item);
        max = Math.max(score ?? 0, max);
      }
      groups.push([value, max]);
    }
    const listInsertionElement = this.viewportNode;
    const sorted = this.getValidItems().sort((a2, b) => {
      const valueA = a2.getAttribute("data-value");
      const valueB = b.getAttribute("data-value");
      const scoresA = scores.get(valueA) ?? 0;
      const scoresB = scores.get(valueB) ?? 0;
      return scoresB - scoresA;
    });
    for (const item of sorted) {
      const group = item.closest(COMMAND_GROUP_ITEMS_SELECTOR);
      if (group) {
        const itemToAppend = strict_equals(item.parentElement, group) ? item : item.closest(`${COMMAND_GROUP_ITEMS_SELECTOR} > *`);
        if (itemToAppend) {
          group.appendChild(itemToAppend);
        }
      } else {
        const itemToAppend = strict_equals(item.parentElement, listInsertionElement) ? item : item.closest(`${COMMAND_GROUP_ITEMS_SELECTOR} > *`);
        if (itemToAppend) {
          listInsertionElement?.appendChild(itemToAppend);
        }
      }
    }
    const sortedGroups = groups.sort((a2, b) => b[1] - a2[1]);
    for (const group of sortedGroups) {
      const element2 = listInsertionElement?.querySelector(`${COMMAND_GROUP_SELECTOR}[${COMMAND_VALUE_ATTR}="${cssEscape(group[0])}"]`);
      element2?.parentElement?.appendChild(element2);
    }
    this.#selectFirstItem();
  }
  /**
   * Sets current value and triggers re-render if cleared.
   *
   * @param value - New value to set
   */
  setValue(value, opts) {
    if (strict_equals(value, this.opts.value.current, false) && strict_equals(value, "")) {
      afterTick(() => {
        this.key++;
      });
    }
    this.setState("value", value, opts);
    this.opts.value.current = value;
  }
  /**
   * Selects first non-disabled item on next tick.
   */
  #selectFirstItem() {
    afterTick(() => {
      const item = this.getValidItems().find((item2) => strict_equals(item2.getAttribute("aria-disabled"), "true", false));
      const value = item?.getAttribute(COMMAND_VALUE_ATTR);
      const shouldPreventScroll = this.#isInitialMount && this.opts.disableInitialScroll.current;
      this.setValue(value ?? "", shouldPreventScroll);
      this.#isInitialMount = false;
    });
  }
  /**
   * Updates filtered items/groups based on search.
   * Recalculates scores and filtered count.
   */
  #filterItems() {
    if (!this._commandState.search || strict_equals(this.opts.shouldFilter.current, false)) {
      this._commandState.filtered.count = this.allItems.size;
      return;
    }
    this._commandState.filtered.groups = /* @__PURE__ */ new Set();
    let itemCount = 0;
    for (const id of this.allItems) {
      const value = this.allIds.get(id)?.value ?? "";
      const keywords = this.allIds.get(id)?.keywords ?? [];
      const rank = this.#score(value, keywords);
      this._commandState.filtered.items.set(id, rank);
      if (rank > 0) itemCount++;
    }
    for (const [groupId, group] of this.allGroups) {
      for (const itemId of group) {
        const currItem = this._commandState.filtered.items.get(itemId);
        if (currItem && currItem > 0) {
          this._commandState.filtered.groups.add(groupId);
          break;
        }
      }
    }
    this._commandState.filtered.count = itemCount;
  }
  /**
   * Gets all non-disabled, visible command items.
   *
   * @returns Array of valid item elements
   * @remarks Exposed for direct item access and bound checking
   */
  getValidItems() {
    const node = this.opts.ref.current;
    if (!node) return [];
    const validItems = Array.from(node.querySelectorAll(COMMAND_VALID_ITEM_SELECTOR)).filter((el) => !!el);
    return validItems;
  }
  /**
   * Gets all visible command items.
   *
   * @returns Array of valid item elements
   * @remarks Exposed for direct item access and bound checking
   */
  getVisibleItems() {
    const node = this.opts.ref.current;
    if (!node) return [];
    const visibleItems = Array.from(node.querySelectorAll(COMMAND_ITEM_SELECTOR)).filter((el) => !!el);
    return visibleItems;
  }
  /** Returns all visible items in a matrix structure
   *
   * @remarks Returns empty if the command isn't configured as a grid
   *
   * @returns
   */
  get itemsGrid() {
    if (!this.isGrid) return [];
    const columns = this.opts.columns.current ?? 1;
    const items = this.getVisibleItems();
    const grid = [[]];
    let currentGroup = items[0]?.getAttribute("data-group");
    let column = 0;
    let row = 0;
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      const itemGroup = item?.getAttribute("data-group");
      if (strict_equals(currentGroup, itemGroup, false)) {
        currentGroup = itemGroup;
        column = 1;
        row++;
        grid.push([{ index: i, firstRowOfGroup: true, ref: item }]);
      } else {
        column++;
        if (column > columns) {
          row++;
          column = 1;
          grid.push([]);
        }
        grid[row]?.push({
          index: i,
          firstRowOfGroup: grid[row]?.[0]?.firstRowOfGroup ?? strict_equals(i, 0),
          ref: item
        });
      }
    }
    return grid;
  }
  /**
   * Gets currently selected command item.
   *
   * @returns Selected element or undefined
   */
  #getSelectedItem() {
    const node = this.opts.ref.current;
    if (!node) return;
    const selectedNode = node.querySelector(`${COMMAND_VALID_ITEM_SELECTOR}[data-selected]`);
    if (!selectedNode) return;
    return selectedNode;
  }
  /**
   * Scrolls selected item into view.
   * Special handling for first items in groups.
   */
  #scrollSelectedIntoView() {
    afterTick(() => {
      const item = this.#getSelectedItem();
      if (!item) return;
      const grandparent = item.parentElement?.parentElement;
      if (!grandparent) return;
      if (this.isGrid) {
        const isFirstRowOfGroup = this.#itemIsFirstRowOfGroup(item);
        item.scrollIntoView({ block: "nearest" });
        if (isFirstRowOfGroup) {
          const closestGroupHeader = item?.closest(COMMAND_GROUP_SELECTOR)?.querySelector(COMMAND_GROUP_HEADING_SELECTOR);
          closestGroupHeader?.scrollIntoView({ block: "nearest" });
          return;
        }
      } else {
        const firstChildOfParent = getFirstNonCommentChild(grandparent);
        if (firstChildOfParent && strict_equals(firstChildOfParent.dataset?.value, item.dataset?.value)) {
          const closestGroupHeader = item?.closest(COMMAND_GROUP_SELECTOR)?.querySelector(COMMAND_GROUP_HEADING_SELECTOR);
          closestGroupHeader?.scrollIntoView({ block: "nearest" });
          return;
        }
      }
      item.scrollIntoView({ block: "nearest" });
    });
  }
  #itemIsFirstRowOfGroup(item) {
    const grid = this.itemsGrid;
    if (strict_equals(grid.length, 0)) return false;
    for (let r = 0; r < grid.length; r++) {
      const row = grid[r];
      if (strict_equals(row, void 0)) continue;
      for (let c = 0; c < row.length; c++) {
        const column = row[c];
        if (strict_equals(column, void 0) || strict_equals(column.ref, item, false)) continue;
        return column.firstRowOfGroup;
      }
    }
    return false;
  }
  /**
   * Sets selection to item at specified index in valid items array.
   * If index is out of bounds, does nothing.
   *
   * @param index - Zero-based index of item to select
   * @remarks
   * Uses `getValidItems()` to get selectable items, filtering out disabled/hidden ones.
   * Access valid items directly via `getValidItems()` to check bounds before calling.
   *
   * @example
   * // get valid items length for bounds check
   * const items = getValidItems()
   * if (index < items.length) {
   *   updateSelectedToIndex(index)
   * }
   */
  updateSelectedToIndex(index) {
    const item = this.getValidItems()[index];
    if (!item) return;
    this.setValue(item.getAttribute(COMMAND_VALUE_ATTR) ?? "");
  }
  /**
   * Updates selected item by moving up/down relative to current selection.
   * Handles wrapping when loop option is enabled.
   *
   * @param change - Direction to move: 1 for next item, -1 for previous item
   * @remarks
   * The loop behavior wraps:
   * - From last item to first when moving next
   * - From first item to last when moving previous
   *
   * Uses `getValidItems()` to get all selectable items, which filters out disabled/hidden items.
   * You can call `getValidItems()` directly to get the current valid items array.
   *
   * @example
   * // select next item
   * updateSelectedByItem(1)
   *
   * // get all valid items
   * const items = getValidItems()
   */
  updateSelectedByItem(change) {
    const selected = this.#getSelectedItem();
    const items = this.getValidItems();
    const index = items.findIndex((item) => strict_equals(item, selected));
    let newSelected = items[index + change];
    if (this.opts.loop.current) {
      newSelected = index + change < 0 ? items[items.length - 1] : strict_equals(index + change, items.length) ? items[0] : items[index + change];
    }
    if (newSelected) {
      this.setValue(newSelected.getAttribute(COMMAND_VALUE_ATTR) ?? "");
    }
  }
  /**
   * Moves selection to the first valid item in the next/previous group.
   * If no group is found, falls back to selecting the next/previous item globally.
   *
   * @param change - Direction to move: 1 for next group, -1 for previous group
   * @example
   * // move to first item in next group
   * updateSelectedByGroup(1)
   *
   * // move to first item in previous group
   * updateSelectedByGroup(-1)
   */
  updateSelectedByGroup(change) {
    const selected = this.#getSelectedItem();
    let group = selected?.closest(COMMAND_GROUP_SELECTOR);
    let item;
    while (group && !item) {
      group = change > 0 ? findNextSibling(group, COMMAND_GROUP_SELECTOR) : findPreviousSibling(group, COMMAND_GROUP_SELECTOR);
      item = group?.querySelector(COMMAND_VALID_ITEM_SELECTOR);
    }
    if (item) {
      this.setValue(item.getAttribute(COMMAND_VALUE_ATTR) ?? "");
    } else {
      this.updateSelectedByItem(change);
    }
  }
  /**
   * Maps item id to display value and search keywords.
   * Returns cleanup function to remove mapping.
   *
   * @param id - Unique item identifier
   * @param value - Display text
   * @param keywords - Optional search boost terms
   * @returns Cleanup function
   */
  registerValue(value, keywords) {
    if (!(value && strict_equals(value, this.allIds.get(value)?.value))) {
      this.allIds.set(value, { value, keywords });
    }
    this._commandState.filtered.items.set(value, this.#score(value, keywords));
    if (!this.sortAfterTick) {
      this.sortAfterTick = true;
      afterTick(() => {
        this.#sort();
        this.sortAfterTick = false;
      });
    }
    return () => {
      this.allIds.delete(value);
    };
  }
  /**
   * Registers item in command list and its group.
   * Handles filtering, sorting and selection updates.
   *
   * @param id - Item identifier
   * @param groupId - Optional group to add item to
   * @returns Cleanup function that handles selection
   */
  registerItem(id, groupId) {
    this.allItems.add(id);
    if (groupId) {
      if (!this.allGroups.has(groupId)) {
        this.allGroups.set(groupId, /* @__PURE__ */ new Set([id]));
      } else {
        this.allGroups.get(groupId).add(id);
      }
    }
    if (!this.sortAndFilterAfterTick) {
      this.sortAndFilterAfterTick = true;
      afterTick(() => {
        this.#filterItems();
        this.#sort();
        this.sortAndFilterAfterTick = false;
      });
    }
    this.#scheduleUpdate();
    return () => {
      const selectedItem = this.#getSelectedItem();
      this.allIds.delete(id);
      this.allItems.delete(id);
      this.commandState.filtered.items.delete(id);
      this.#filterItems();
      if (strict_equals(selectedItem?.getAttribute("id"), id)) {
        this.#selectFirstItem();
      }
      this.#scheduleUpdate();
    };
  }
  /**
   * Creates empty group if not exists.
   *
   * @param id - Group identifier
   * @returns Cleanup function
   */
  registerGroup(id) {
    if (!this.allGroups.has(id)) {
      this.allGroups.set(id, /* @__PURE__ */ new Set());
    }
    return () => {
      this.allIds.delete(id);
      this.allGroups.delete(id);
    };
  }
  get isGrid() {
    return strict_equals(this.opts.columns.current, null, false);
  }
  /**
   * Selects last valid item.
   */
  #last() {
    return this.updateSelectedToIndex(this.getValidItems().length - 1);
  }
  /**
   * Handles next item selection:
   * - Meta: Jump to last
   * - Alt: Next group
   * - Default: Next item
   *
   * @param e - Keyboard event
   */
  #next(e) {
    e.preventDefault();
    if (e.metaKey) {
      this.#last();
    } else if (e.altKey) {
      this.updateSelectedByGroup(1);
    } else {
      this.updateSelectedByItem(1);
    }
  }
  #down(e) {
    if (strict_equals(this.opts.columns.current, null)) return;
    e.preventDefault();
    if (e.metaKey) {
      this.updateSelectedByGroup(1);
    } else {
      this.updateSelectedByItem(this.#nextRowColumnOffset(e));
    }
  }
  #getColumn(item, grid) {
    if (strict_equals(grid.length, 0)) return null;
    for (let r = 0; r < grid.length; r++) {
      const row = grid[r];
      if (strict_equals(row, void 0)) continue;
      for (let c = 0; c < row.length; c++) {
        const column = row[c];
        if (strict_equals(column, void 0) || strict_equals(column.ref, item, false)) continue;
        return { columnIndex: c, rowIndex: r };
      }
    }
    return null;
  }
  #nextRowColumnOffset(e) {
    const grid = this.itemsGrid;
    const selected = this.#getSelectedItem();
    if (!selected) return 0;
    const column = this.#getColumn(selected, grid);
    if (!column) return 0;
    let newItem = null;
    const skipRows = e.altKey ? 1 : 0;
    if (e.altKey && strict_equals(column.rowIndex, grid.length - 2) && !this.opts.loop.current) {
      newItem = this.#findNextNonDisabledItem({
        start: grid.length - 1,
        end: grid.length,
        expectedColumnIndex: column.columnIndex,
        grid
      });
    } else if (strict_equals(column.rowIndex, grid.length - 1)) {
      if (!this.opts.loop.current) return 0;
      newItem = this.#findNextNonDisabledItem({
        start: 0 + skipRows,
        end: column.rowIndex,
        expectedColumnIndex: column.columnIndex,
        grid
      });
    } else {
      newItem = this.#findNextNonDisabledItem({
        start: column.rowIndex + 1 + skipRows,
        end: grid.length,
        expectedColumnIndex: column.columnIndex,
        grid
      });
      if (strict_equals(newItem, null) && this.opts.loop.current) {
        newItem = this.#findNextNonDisabledItem({
          start: 0,
          end: column.rowIndex,
          expectedColumnIndex: column.columnIndex,
          grid
        });
      }
    }
    return this.#calculateOffset(selected, newItem);
  }
  /** Attempts to find the next non-disabled column that matches the expected column.
   *
   * @remarks
   * - Skips over disabled columns
   * - When a row is shorter than the expected column it defaults to the last item in the row
   *
   * @param param0
   * @returns
   */
  #findNextNonDisabledItem({ start, end, grid, expectedColumnIndex }) {
    let newItem = null;
    for (let r = start; r < end; r++) {
      const row = grid[r];
      newItem = row[expectedColumnIndex]?.ref ?? null;
      if (strict_equals(newItem, null, false) && itemIsDisabled(newItem)) {
        newItem = null;
        continue;
      }
      if (strict_equals(newItem, null)) {
        for (let i = row.length - 1; i >= 0; i--) {
          const item = row[row.length - 1];
          if (strict_equals(item, void 0) || itemIsDisabled(item.ref)) continue;
          newItem = item.ref;
          break;
        }
      }
      break;
    }
    return newItem;
  }
  #calculateOffset(selected, newSelected) {
    if (strict_equals(newSelected, null)) return 0;
    const items = this.getValidItems();
    const ogIndex = items.findIndex((item) => strict_equals(item, selected));
    const newIndex = items.findIndex((item) => strict_equals(item, newSelected));
    return newIndex - ogIndex;
  }
  #up(e) {
    if (strict_equals(this.opts.columns.current, null)) return;
    e.preventDefault();
    if (e.metaKey) {
      this.updateSelectedByGroup(-1);
    } else {
      this.updateSelectedByItem(this.#previousRowColumnOffset(e));
    }
  }
  #previousRowColumnOffset(e) {
    const grid = this.itemsGrid;
    const selected = this.#getSelectedItem();
    if (strict_equals(selected, void 0)) return 0;
    const column = this.#getColumn(selected, grid);
    if (strict_equals(column, null)) return 0;
    let newItem = null;
    const skipRows = e.altKey ? 1 : 0;
    if (e.altKey && strict_equals(column.rowIndex, 1) && strict_equals(this.opts.loop.current, false)) {
      newItem = this.#findNextNonDisabledItemDesc({
        start: 0,
        end: 0,
        expectedColumnIndex: column.columnIndex,
        grid
      });
    } else if (strict_equals(column.rowIndex, 0)) {
      if (strict_equals(this.opts.loop.current, false)) return 0;
      newItem = this.#findNextNonDisabledItemDesc({
        start: grid.length - 1 - skipRows,
        end: column.rowIndex + 1,
        expectedColumnIndex: column.columnIndex,
        grid
      });
    } else {
      newItem = this.#findNextNonDisabledItemDesc({
        start: column.rowIndex - 1 - skipRows,
        end: 0,
        expectedColumnIndex: column.columnIndex,
        grid
      });
      if (strict_equals(newItem, null) && this.opts.loop.current) {
        newItem = this.#findNextNonDisabledItemDesc({
          start: grid.length - 1,
          end: column.rowIndex + 1,
          expectedColumnIndex: column.columnIndex,
          grid
        });
      }
    }
    return this.#calculateOffset(selected, newItem);
  }
  /**
   * Attempts to find the next non-disabled column that matches the expected column.
   *
   * @remarks
   * - Skips over disabled columns
   * - When a row is shorter than the expected column it defaults to the last item in the row
   */
  #findNextNonDisabledItemDesc({ start, end, grid, expectedColumnIndex }) {
    let newItem = null;
    for (let r = start; r >= end; r--) {
      const row = grid[r];
      if (strict_equals(row, void 0)) continue;
      newItem = row[expectedColumnIndex]?.ref ?? null;
      if (strict_equals(newItem, null, false) && itemIsDisabled(newItem)) {
        newItem = null;
        continue;
      }
      if (strict_equals(newItem, null)) {
        for (let i = row.length - 1; i >= 0; i--) {
          const item = row[row.length - 1];
          if (strict_equals(item, void 0) || itemIsDisabled(item.ref)) continue;
          newItem = item.ref;
          break;
        }
      }
      break;
    }
    return newItem;
  }
  /**
   * Handles previous item selection:
   * - Meta: Jump to first
   * - Alt: Previous group
   * - Default: Previous item
   *
   * @param e - Keyboard event
   */
  #prev(e) {
    e.preventDefault();
    if (e.metaKey) {
      this.updateSelectedToIndex(0);
    } else if (e.altKey) {
      this.updateSelectedByGroup(-1);
    } else {
      this.updateSelectedByItem(-1);
    }
  }
  onkeydown(e) {
    const isVim = this.opts.vimBindings.current && e.ctrlKey;
    switch (e.key) {
      case kbd_constants_exports.n:
      case kbd_constants_exports.j: {
        if (isVim) {
          if (this.isGrid) {
            this.#down(e);
          } else {
            this.#next(e);
          }
        }
        break;
      }
      case kbd_constants_exports.l: {
        if (isVim) {
          if (this.isGrid) {
            this.#next(e);
          }
        }
        break;
      }
      case kbd_constants_exports.ARROW_DOWN:
        if (this.isGrid) {
          this.#down(e);
        } else {
          this.#next(e);
        }
        break;
      case kbd_constants_exports.ARROW_RIGHT:
        if (!this.isGrid) break;
        this.#next(e);
        break;
      case kbd_constants_exports.p:
      case kbd_constants_exports.k: {
        if (isVim) {
          if (this.isGrid) {
            this.#up(e);
          } else {
            this.#prev(e);
          }
        }
        break;
      }
      case kbd_constants_exports.h: {
        if (isVim && this.isGrid) {
          this.#prev(e);
        }
        break;
      }
      case kbd_constants_exports.ARROW_UP:
        if (this.isGrid) {
          this.#up(e);
        } else {
          this.#prev(e);
        }
        break;
      case kbd_constants_exports.ARROW_LEFT:
        if (!this.isGrid) break;
        this.#prev(e);
        break;
      case kbd_constants_exports.HOME:
        e.preventDefault();
        this.updateSelectedToIndex(0);
        break;
      case kbd_constants_exports.END:
        e.preventDefault();
        this.#last();
        break;
      case kbd_constants_exports.ENTER: {
        if (!e.isComposing && strict_equals(e.keyCode, 229, false)) {
          e.preventDefault();
          const item = this.#getSelectedItem();
          if (item) {
            item?.click();
          }
        }
      }
    }
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "application",
      [commandAttrs.root]: "",
      tabindex: -1,
      onkeydown: this.onkeydown,
      ...this.attachment
    })),
    "CommandRootState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
function itemIsDisabled(item) {
  return strict_equals(item.getAttribute("aria-disabled"), "true");
}
var CommandEmptyState = class _CommandEmptyState {
  static create(opts) {
    return new _CommandEmptyState(opts, CommandRootContext.get());
  }
  opts;
  root;
  attachment;
  #shouldRender = tag(
    user_derived(() => {
      return strict_equals(this.root._commandState.filtered.count, 0) && strict_equals(this.#isInitialRender, false) || this.opts.forceMount.current;
    }),
    "CommandEmptyState.shouldRender"
  );
  get shouldRender() {
    return get(this.#shouldRender);
  }
  set shouldRender(value) {
    set(this.#shouldRender, value);
  }
  #isInitialRender = true;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    user_pre_effect(() => {
      this.#isInitialRender = false;
    });
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "presentation",
      [commandAttrs.empty]: "",
      ...this.attachment
    })),
    "CommandEmptyState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var CommandGroupContainerState = class _CommandGroupContainerState {
  static create(opts) {
    return CommandGroupContainerContext.set(new _CommandGroupContainerState(opts, CommandRootContext.get()));
  }
  opts;
  root;
  attachment;
  #shouldRender = tag(
    user_derived(() => {
      if (this.opts.forceMount.current) return true;
      if (strict_equals(this.root.opts.shouldFilter.current, false)) return true;
      if (!this.root.commandState.search) return true;
      return this.root._commandState.filtered.groups.has(this.trueValue);
    }),
    "CommandGroupContainerState.shouldRender"
  );
  get shouldRender() {
    return get(this.#shouldRender);
  }
  set shouldRender(value) {
    set(this.#shouldRender, value);
  }
  #headingNode = tag(state(null), "CommandGroupContainerState.headingNode");
  get headingNode() {
    return get(this.#headingNode);
  }
  set headingNode(value) {
    set(this.#headingNode, value, true);
  }
  #trueValue = tag(state(""), "CommandGroupContainerState.trueValue");
  get trueValue() {
    return get(this.#trueValue);
  }
  set trueValue(value) {
    set(this.#trueValue, value, true);
  }
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    this.trueValue = opts.value.current ?? opts.id.current;
    watch(() => this.trueValue, () => {
      return this.root.registerGroup(this.trueValue);
    });
    user_effect(() => {
      if (this.opts.value.current) {
        this.trueValue = this.opts.value.current;
        return this.root.registerValue(this.opts.value.current);
      } else if (this.headingNode && this.headingNode.textContent) {
        this.trueValue = this.headingNode.textContent.trim().toLowerCase();
        return this.root.registerValue(this.trueValue);
      } else {
        this.trueValue = `-----${this.opts.id.current}`;
        return this.root.registerValue(this.trueValue);
      }
    });
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "presentation",
      hidden: this.shouldRender ? void 0 : true,
      "data-value": this.trueValue,
      [commandAttrs.group]: "",
      ...this.attachment
    })),
    "CommandGroupContainerState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var CommandGroupHeadingState = class _CommandGroupHeadingState {
  static create(opts) {
    return new _CommandGroupHeadingState(opts, CommandGroupContainerContext.get());
  }
  opts;
  group;
  attachment;
  constructor(opts, group) {
    this.opts = opts;
    this.group = group;
    this.attachment = attachRef(this.opts.ref, (v) => this.group.headingNode = v);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      [commandAttrs["group-heading"]]: "",
      ...this.attachment
    })),
    "CommandGroupHeadingState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var CommandGroupItemsState = class _CommandGroupItemsState {
  static create(opts) {
    return new _CommandGroupItemsState(opts, CommandGroupContainerContext.get());
  }
  opts;
  group;
  attachment;
  constructor(opts, group) {
    this.opts = opts;
    this.group = group;
    this.attachment = attachRef(this.opts.ref);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "group",
      [commandAttrs["group-items"]]: "",
      "aria-labelledby": this.group.headingNode?.id ?? void 0,
      ...this.attachment
    })),
    "CommandGroupItemsState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var CommandInputState = class _CommandInputState {
  static create(opts) {
    return new _CommandInputState(opts, CommandRootContext.get());
  }
  opts;
  root;
  attachment;
  #selectedItemId = tag(
    user_derived(() => {
      const item = this.root.viewportNode?.querySelector(`${COMMAND_ITEM_SELECTOR}[${COMMAND_VALUE_ATTR}="${cssEscape(this.root.opts.value.current)}"]`);
      if (strict_equals(item, void 0) || strict_equals(item, null)) return;
      return item.getAttribute("id") ?? void 0;
    }),
    "CommandInputState.#selectedItemId"
  );
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.inputNode = v);
    watch(() => this.opts.ref.current, () => {
      const node = this.opts.ref.current;
      if (node && this.opts.autofocus.current) {
        afterSleep(10, () => node.focus());
      }
    });
    watch(() => this.opts.value.current, () => {
      if (strict_equals(this.root.commandState.search, this.opts.value.current, false)) {
        this.root.setState("search", this.opts.value.current);
      }
    });
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      type: "text",
      [commandAttrs.input]: "",
      autocomplete: "off",
      autocorrect: "off",
      spellcheck: false,
      "aria-autocomplete": "list",
      role: "combobox",
      "aria-expanded": getAriaExpanded(true),
      "aria-controls": this.root.viewportNode?.id ?? void 0,
      "aria-labelledby": this.root.labelNode?.id ?? void 0,
      "aria-activedescendant": get(this.#selectedItemId),
      ...this.attachment
    })),
    "CommandInputState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var CommandItemState = class _CommandItemState {
  static create(opts) {
    const group = CommandGroupContainerContext.getOr(null);
    return new _CommandItemState({ ...opts, group }, CommandRootContext.get());
  }
  opts;
  root;
  attachment;
  #group = null;
  #trueForceMount = tag(
    user_derived(() => {
      return this.opts.forceMount.current || strict_equals(this.#group?.opts.forceMount.current, true);
    }),
    "CommandItemState.#trueForceMount"
  );
  #shouldRender = tag(
    user_derived(() => {
      this.opts.ref.current;
      if (get(this.#trueForceMount) || strict_equals(this.root.opts.shouldFilter.current, false) || !this.root.commandState.search) {
        return true;
      }
      const currentScore = this.root.commandState.filtered.items.get(this.trueValue);
      if (strict_equals(currentScore, void 0)) return false;
      return currentScore > 0;
    }),
    "CommandItemState.shouldRender"
  );
  get shouldRender() {
    return get(this.#shouldRender);
  }
  set shouldRender(value) {
    set(this.#shouldRender, value);
  }
  #isSelected = tag(user_derived(() => strict_equals(this.root.opts.value.current, this.trueValue) && strict_equals(this.trueValue, "", false)), "CommandItemState.isSelected");
  get isSelected() {
    return get(this.#isSelected);
  }
  set isSelected(value) {
    set(this.#isSelected, value);
  }
  #trueValue = tag(state(""), "CommandItemState.trueValue");
  get trueValue() {
    return get(this.#trueValue);
  }
  set trueValue(value) {
    set(this.#trueValue, value, true);
  }
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.#group = CommandGroupContainerContext.getOr(null);
    this.trueValue = opts.value.current;
    this.attachment = attachRef(this.opts.ref);
    watch(
      [
        () => this.trueValue,
        () => this.#group?.trueValue,
        () => this.opts.forceMount.current
      ],
      () => {
        if (this.opts.forceMount.current) return;
        return this.root.registerItem(this.trueValue, this.#group?.trueValue);
      }
    );
    watch([() => this.opts.value.current, () => this.opts.ref.current], () => {
      if (!this.opts.value.current && this.opts.ref.current?.textContent) {
        this.trueValue = this.opts.ref.current.textContent.trim();
      }
      this.root.registerValue(this.trueValue, opts.keywords.current.map((kw) => kw.trim()));
      this.opts.ref.current?.setAttribute(COMMAND_VALUE_ATTR, this.trueValue);
    });
    this.onclick = this.onclick.bind(this);
    this.onpointermove = this.onpointermove.bind(this);
  }
  #onSelect() {
    if (this.opts.disabled.current) return;
    this.#select();
    this.opts.onSelect?.current();
  }
  #select() {
    if (this.opts.disabled.current) return;
    this.root.setValue(this.trueValue, true);
  }
  onpointermove(_) {
    if (this.opts.disabled.current || this.root.opts.disablePointerSelection.current) return;
    this.#select();
  }
  onclick(_) {
    if (this.opts.disabled.current) return;
    this.#onSelect();
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "aria-disabled": getAriaDisabled(this.opts.disabled.current),
      "aria-selected": getAriaSelected(this.isSelected),
      "data-disabled": getDataDisabled(this.opts.disabled.current),
      "data-selected": getDataSelected(this.isSelected),
      "data-value": this.trueValue,
      "data-group": this.#group?.trueValue,
      [commandAttrs.item]: "",
      role: "option",
      onpointermove: this.onpointermove,
      onclick: this.onclick,
      ...this.attachment
    })),
    "CommandItemState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var CommandLoadingState = class _CommandLoadingState {
  static create(opts) {
    return new _CommandLoadingState(opts);
  }
  opts;
  attachment;
  constructor(opts) {
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "progressbar",
      "aria-valuenow": this.opts.progress.current,
      "aria-valuemin": 0,
      "aria-valuemax": 100,
      "aria-label": "Loading...",
      [commandAttrs.loading]: "",
      ...this.attachment
    })),
    "CommandLoadingState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var CommandSeparatorState = class _CommandSeparatorState {
  static create(opts) {
    return new _CommandSeparatorState(opts, CommandRootContext.get());
  }
  opts;
  root;
  attachment;
  #shouldRender = tag(user_derived(() => !this.root._commandState.search || this.opts.forceMount.current), "CommandSeparatorState.shouldRender");
  get shouldRender() {
    return get(this.#shouldRender);
  }
  set shouldRender(value) {
    set(this.#shouldRender, value);
  }
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      // role="separator" cannot belong to a role="listbox"
      "aria-hidden": "true",
      [commandAttrs.separator]: "",
      ...this.attachment
    })),
    "CommandSeparatorState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var CommandListState = class _CommandListState {
  static create(opts) {
    return CommandListContext.set(new _CommandListState(opts, CommandRootContext.get()));
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "listbox",
      "aria-label": this.opts.ariaLabel.current,
      [commandAttrs.list]: "",
      ...this.attachment
    })),
    "CommandListState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var CommandLabelState = class _CommandLabelState {
  static create(opts) {
    return new _CommandLabelState(opts, CommandRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.labelNode = v);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      [commandAttrs["input-label"]]: "",
      for: this.opts.for?.current,
      style: srOnlyStyles,
      ...this.attachment
    })),
    "CommandLabelState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var CommandViewportState = class _CommandViewportState {
  static create(opts) {
    return new _CommandViewportState(opts, CommandListContext.get());
  }
  opts;
  list;
  attachment;
  constructor(opts, list) {
    this.opts = opts;
    this.list = list;
    this.attachment = attachRef(this.opts.ref, (v) => this.list.root.viewportNode = v);
    watch(
      [
        () => this.opts.ref.current,
        () => this.list.opts.ref.current
      ],
      ([node, listNode]) => {
        if (strict_equals(node, null) || strict_equals(listNode, null)) return;
        let aF;
        const observer = new ResizeObserver(() => {
          aF = requestAnimationFrame(() => {
            const height = node.offsetHeight;
            listNode.style.setProperty("--bits-command-list-height", `${height.toFixed(1)}px`);
          });
        });
        observer.observe(node);
        return () => {
          cancelAnimationFrame(aF);
          observer.unobserve(node);
        };
      }
    );
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      [commandAttrs.viewport]: "",
      ...this.attachment
    })),
    "CommandViewportState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};

// node_modules/bits-ui/dist/bits/command/components/_command-label.svelte
_command_label[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/_command-label.svelte";
var root5 = add_locations(from_html(`<label><!></label>`), _command_label[FILENAME], [[29, 0]]);
function _command_label($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, _command_label);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "id", "ref", "children"], "restProps");
  const labelState = CommandLabelState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, labelState.props)), "mergedProps");
  var label = root5();
  attribute_effect(label, () => ({ ...get(mergedProps) }));
  var node = child(label);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop), "render", _command_label, 30, 1);
  reset(label);
  append($$anchor, label);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  _command_label = hmr(_command_label, () => _command_label[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = _command_label[HMR].source;
    set(_command_label[HMR].source, module.default[HMR].original);
  });
}
var command_label_default = _command_label;

// node_modules/bits-ui/dist/bits/command/components/command.svelte
Command[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command.svelte";
var root_37 = add_locations(from_html(`<!> <!>`, 1), Command[FILENAME], []);
var root_44 = add_locations(from_html(`<div><!> <!></div>`), Command[FILENAME], [[133, 1]]);
function Command($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Command);
  const Label2 = wrap_snippet(Command, function($$anchor2) {
    validate_snippet_args(...arguments);
    var fragment = comment();
    var node = first_child(fragment);
    add_svelte_meta(
      () => command_label_default(node, {
        children: wrap_snippet(Command, ($$anchor3, $$slotProps) => {
          next();
          var text2 = text();
          template_effect(() => set_text(text2, label()));
          append($$anchor3, text2);
        }),
        $$slots: { default: true }
      }),
      "component",
      Command,
      124,
      1,
      { componentTag: "CommandLabel" }
    );
    append($$anchor2, fragment);
  });
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15, ""), onValueChange = prop($$props, "onValueChange", 3, noop3), onStateChange = prop($$props, "onStateChange", 3, noop3), loop = prop($$props, "loop", 3, false), shouldFilter = prop($$props, "shouldFilter", 3, true), filter = prop($$props, "filter", 3, computeCommandScore), label = prop($$props, "label", 3, ""), vimBindings = prop($$props, "vimBindings", 3, true), disablePointerSelection = prop($$props, "disablePointerSelection", 3, false), disableInitialScroll = prop($$props, "disableInitialScroll", 3, false), columns = prop($$props, "columns", 3, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "onValueChange",
      "onStateChange",
      "loop",
      "shouldFilter",
      "filter",
      "label",
      "vimBindings",
      "disablePointerSelection",
      "disableInitialScroll",
      "columns",
      "children",
      "child"
    ],
    "restProps"
  );
  const rootState = CommandRootState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    filter: box.with(() => filter()),
    shouldFilter: box.with(() => shouldFilter()),
    loop: box.with(() => loop()),
    value: box.with(() => value(), (v) => {
      if (strict_equals(value(), v, false)) {
        value(v);
        onValueChange()(v);
      }
    }),
    vimBindings: box.with(() => vimBindings()),
    disablePointerSelection: box.with(() => disablePointerSelection()),
    disableInitialScroll: box.with(() => disableInitialScroll()),
    onStateChange: box.with(() => onStateChange()),
    columns: box.with(() => columns())
  });
  const updateSelectedToIndex = (i) => rootState.updateSelectedToIndex(i);
  const updateSelectedByGroup = (c) => rootState.updateSelectedByGroup(c);
  const updateSelectedByItem = (c) => rootState.updateSelectedByItem(c);
  const getValidItems = () => rootState.getValidItems();
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment_2 = comment();
  var node_1 = first_child(fragment_2);
  {
    var consequent = ($$anchor2) => {
      var fragment_3 = root_37();
      var node_2 = first_child(fragment_3);
      add_svelte_meta(() => Label2(node_2), "render", Command, 130, 1);
      var node_3 = sibling(node_2, 2);
      add_svelte_meta(() => snippet(node_3, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Command, 131, 1);
      append($$anchor2, fragment_3);
    };
    var alternate = ($$anchor2) => {
      var div = root_44();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_4 = child(div);
      add_svelte_meta(() => Label2(node_4), "render", Command, 134, 2);
      var node_5 = sibling(node_4, 2);
      add_svelte_meta(() => snippet(node_5, () => $$props.children ?? noop), "render", Command, 135, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node_1, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Command,
      129,
      0
    );
  }
  append($$anchor, fragment_2);
  return pop({
    get updateSelectedToIndex() {
      return updateSelectedToIndex;
    },
    get updateSelectedByGroup() {
      return updateSelectedByGroup;
    },
    get updateSelectedByItem() {
      return updateSelectedByItem;
    },
    get getValidItems() {
      return getValidItems;
    },
    ...legacy_api()
  });
}
if (import.meta.hot) {
  Command = hmr(Command, () => Command[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command[HMR].source;
    set(Command[HMR].source, module.default[HMR].original);
  });
}
var command_default = Command;

// node_modules/bits-ui/dist/bits/command/components/command-empty.svelte
Command_empty[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-empty.svelte";
var root_38 = add_locations(from_html(`<div><!></div>`), Command_empty[FILENAME], [[34, 2]]);
function Command_empty($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Command_empty);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child",
      "forceMount"
    ],
    "restProps"
  );
  const emptyState = CommandEmptyState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    forceMount: box.with(() => forceMount())
  });
  const mergedProps = tag(user_derived(() => mergeProps(emptyState.props, restProps)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          add_svelte_meta(() => snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Command_empty, 32, 2);
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var div = root_38();
          attribute_effect(div, () => ({ ...get(mergedProps) }));
          var node_3 = child(div);
          add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop), "render", Command_empty, 35, 3);
          reset(div);
          append($$anchor3, div);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if ($$props.child) $$render(consequent);
            else $$render(alternate, false);
          }),
          "if",
          Command_empty,
          31,
          1
        );
      }
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (emptyState.shouldRender) $$render(consequent_1);
      }),
      "if",
      Command_empty,
      30,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_empty = hmr(Command_empty, () => Command_empty[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_empty[HMR].source;
    set(Command_empty[HMR].source, module.default[HMR].original);
  });
}
var command_empty_default = Command_empty;

// node_modules/bits-ui/dist/bits/command/components/command-group.svelte
Command_group[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-group.svelte";
var root_241 = add_locations(from_html(`<div><!></div>`), Command_group[FILENAME], [[35, 1]]);
function Command_group($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Command_group);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 3, ""), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "forceMount",
      "children",
      "child"
    ],
    "restProps"
  );
  const groupState = CommandGroupContainerState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    forceMount: box.with(() => forceMount()),
    value: box.with(() => value())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, groupState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Command_group, 33, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_241();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Command_group, 36, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Command_group,
      32,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_group = hmr(Command_group, () => Command_group[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_group[HMR].source;
    set(Command_group[HMR].source, module.default[HMR].original);
  });
}
var command_group_default = Command_group;

// node_modules/bits-ui/dist/bits/command/components/command-group-heading.svelte
Command_group_heading[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-group-heading.svelte";
var root_242 = add_locations(from_html(`<div><!></div>`), Command_group_heading[FILENAME], [[31, 1]]);
function Command_group_heading($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Command_group_heading);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const headingState = CommandGroupHeadingState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, headingState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Command_group_heading, 29, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_242();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Command_group_heading, 32, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Command_group_heading,
      28,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_group_heading = hmr(Command_group_heading, () => Command_group_heading[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_group_heading[HMR].source;
    set(Command_group_heading[HMR].source, module.default[HMR].original);
  });
}
var command_group_heading_default = Command_group_heading;

// node_modules/bits-ui/dist/bits/command/components/command-group-items.svelte
Command_group_items[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-group-items.svelte";
var root_243 = add_locations(from_html(`<div><!></div>`), Command_group_items[FILENAME], [[32, 2]]);
var root6 = add_locations(from_html(`<div style="display: contents;"><!></div>`), Command_group_items[FILENAME], [[28, 0]]);
function Command_group_items($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Command_group_items);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const groupItemsState = CommandGroupItemsState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, groupItemsState.props)), "mergedProps");
  var div = root6();
  var node = child(div);
  {
    var consequent = ($$anchor2) => {
      var fragment = comment();
      var node_1 = first_child(fragment);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Command_group_items, 30, 2);
      append($$anchor2, fragment);
    };
    var alternate = ($$anchor2) => {
      var div_1 = root_243();
      attribute_effect(div_1, () => ({ ...get(mergedProps) }));
      var node_2 = child(div_1);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Command_group_items, 33, 3);
      reset(div_1);
      append($$anchor2, div_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Command_group_items,
      29,
      1
    );
  }
  reset(div);
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_group_items = hmr(Command_group_items, () => Command_group_items[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_group_items[HMR].source;
    set(Command_group_items[HMR].source, module.default[HMR].original);
  });
}
var command_group_items_default = Command_group_items;

// node_modules/bits-ui/dist/bits/command/components/command-input.svelte
Command_input[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-input.svelte";
var root_244 = add_locations(from_html(`<input/>`), Command_input[FILENAME], [[39, 1]]);
function Command_input($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Command_input);
  let value = prop($$props, "value", 15, ""), autofocus = prop($$props, "autofocus", 3, false), id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "value",
      "autofocus",
      "id",
      "ref",
      "child"
    ],
    "restProps"
  );
  const inputState = CommandInputState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    value: box.with(() => value(), (v) => {
      value(v);
    }),
    autofocus: box.with(() => autofocus() ?? false)
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, inputState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Command_input, 37, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var input = root_244();
      remove_input_defaults(input);
      attribute_effect(input, () => ({ ...get(mergedProps) }));
      bind_value(input, value);
      append($$anchor2, input);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Command_input,
      36,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_input = hmr(Command_input, () => Command_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_input[HMR].source;
    set(Command_input[HMR].source, module.default[HMR].original);
  });
}
var command_input_default = Command_input;

// node_modules/bits-ui/dist/bits/command/components/command-item.svelte
Command_item[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-item.svelte";
var root_45 = add_locations(from_html(`<div><!></div>`), Command_item[FILENAME], [[45, 4]]);
var root_15 = add_locations(from_html(`<div style="display: contents;" data-item-wrapper=""><!></div>`), Command_item[FILENAME], [[40, 1]]);
function Command_item($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Command_item);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 3, ""), disabled = prop($$props, "disabled", 3, false), onSelect = prop($$props, "onSelect", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), keywords = prop($$props, "keywords", 19, () => []), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "disabled",
      "children",
      "child",
      "onSelect",
      "forceMount",
      "keywords"
    ],
    "restProps"
  );
  const itemState = CommandItemState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    value: box.with(() => value()),
    disabled: box.with(() => disabled()),
    onSelect: box.with(() => onSelect()),
    forceMount: box.with(() => forceMount()),
    keywords: box.with(() => keywords())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, itemState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => key(node, () => itemState.root.key, ($$anchor2) => {
      var div = root_15();
      var node_1 = child(div);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_1 = comment();
          var node_2 = first_child(fragment_1);
          {
            var consequent = ($$anchor4) => {
              var fragment_2 = comment();
              var node_3 = first_child(fragment_2);
              add_svelte_meta(() => snippet(node_3, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Command_item, 43, 4);
              append($$anchor4, fragment_2);
            };
            var alternate = ($$anchor4) => {
              var div_1 = root_45();
              attribute_effect(div_1, () => ({ ...get(mergedProps) }));
              var node_4 = child(div_1);
              add_svelte_meta(() => snippet(node_4, () => $$props.children ?? noop), "render", Command_item, 46, 5);
              reset(div_1);
              append($$anchor4, div_1);
            };
            add_svelte_meta(
              () => if_block(node_2, ($$render) => {
                if ($$props.child) $$render(consequent);
                else $$render(alternate, false);
              }),
              "if",
              Command_item,
              42,
              3
            );
          }
          append($$anchor3, fragment_1);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if (itemState.shouldRender) $$render(consequent_1);
          }),
          "if",
          Command_item,
          41,
          2
        );
      }
      reset(div);
      template_effect(() => set_attribute(div, "data-value", itemState.trueValue));
      append($$anchor2, div);
    }),
    "key",
    Command_item,
    39,
    0
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_item = hmr(Command_item, () => Command_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_item[HMR].source;
    set(Command_item[HMR].source, module.default[HMR].original);
  });
}
var command_item_default = Command_item;

// node_modules/bits-ui/dist/bits/command/components/command-link-item.svelte
Command_link_item[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-link-item.svelte";
var root_46 = add_locations(from_html(`<a><!></a>`), Command_link_item[FILENAME], [[45, 4]]);
var root_16 = add_locations(from_html(`<div style="display: contents;"><!></div>`), Command_link_item[FILENAME], [[40, 1]]);
function Command_link_item($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Command_link_item);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 3, ""), disabled = prop($$props, "disabled", 3, false), onSelect = prop($$props, "onSelect", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), keywords = prop($$props, "keywords", 19, () => []), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "disabled",
      "children",
      "child",
      "onSelect",
      "forceMount",
      "keywords"
    ],
    "restProps"
  );
  const itemState = CommandItemState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    value: box.with(() => value()),
    disabled: box.with(() => disabled()),
    onSelect: box.with(() => onSelect()),
    forceMount: box.with(() => forceMount()),
    keywords: box.with(() => keywords())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, itemState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => key(node, () => itemState.root.key, ($$anchor2) => {
      var div = root_16();
      var node_1 = child(div);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_1 = comment();
          var node_2 = first_child(fragment_1);
          {
            var consequent = ($$anchor4) => {
              var fragment_2 = comment();
              var node_3 = first_child(fragment_2);
              add_svelte_meta(() => snippet(node_3, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Command_link_item, 43, 4);
              append($$anchor4, fragment_2);
            };
            var alternate = ($$anchor4) => {
              var a2 = root_46();
              attribute_effect(a2, () => ({ ...get(mergedProps) }));
              var node_4 = child(a2);
              add_svelte_meta(() => snippet(node_4, () => $$props.children ?? noop), "render", Command_link_item, 46, 5);
              reset(a2);
              append($$anchor4, a2);
            };
            add_svelte_meta(
              () => if_block(node_2, ($$render) => {
                if ($$props.child) $$render(consequent);
                else $$render(alternate, false);
              }),
              "if",
              Command_link_item,
              42,
              3
            );
          }
          append($$anchor3, fragment_1);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if (itemState.shouldRender) $$render(consequent_1);
          }),
          "if",
          Command_link_item,
          41,
          2
        );
      }
      reset(div);
      append($$anchor2, div);
    }),
    "key",
    Command_link_item,
    39,
    0
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_link_item = hmr(Command_link_item, () => Command_link_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_link_item[HMR].source;
    set(Command_link_item[HMR].source, module.default[HMR].original);
  });
}
var command_link_item_default = Command_link_item;

// node_modules/bits-ui/dist/bits/command/components/command-list.svelte
Command_list[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-list.svelte";
var root_39 = add_locations(from_html(`<div><!></div>`), Command_list[FILENAME], [[34, 2]]);
function Command_list($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Command_list);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "children",
      "aria-label"
    ],
    "restProps"
  );
  const listState = CommandListState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    ariaLabel: box.with(() => $$props["aria-label"] ?? "Suggestions...")
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, listState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => key(node, () => strict_equals(listState.root._commandState.search, ""), ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          add_svelte_meta(() => snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Command_list, 32, 2);
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var div = root_39();
          attribute_effect(div, () => ({ ...get(mergedProps) }));
          var node_3 = child(div);
          add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop), "render", Command_list, 35, 3);
          reset(div);
          append($$anchor3, div);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if ($$props.child) $$render(consequent);
            else $$render(alternate, false);
          }),
          "if",
          Command_list,
          31,
          1
        );
      }
      append($$anchor2, fragment_1);
    }),
    "key",
    Command_list,
    30,
    0
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_list = hmr(Command_list, () => Command_list[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_list[HMR].source;
    set(Command_list[HMR].source, module.default[HMR].original);
  });
}
var command_list_default = Command_list;

// node_modules/bits-ui/dist/bits/command/components/command-viewport.svelte
Command_viewport[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-viewport.svelte";
var root_245 = add_locations(from_html(`<div><!></div>`), Command_viewport[FILENAME], [[31, 1]]);
function Command_viewport($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Command_viewport);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const listViewportState = CommandViewportState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, listViewportState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Command_viewport, 29, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_245();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Command_viewport, 32, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Command_viewport,
      28,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_viewport = hmr(Command_viewport, () => Command_viewport[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_viewport[HMR].source;
    set(Command_viewport[HMR].source, module.default[HMR].original);
  });
}
var command_viewport_default = Command_viewport;

// node_modules/bits-ui/dist/bits/command/components/command-loading.svelte
Command_loading[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-loading.svelte";
var root_246 = add_locations(from_html(`<div><!></div>`), Command_loading[FILENAME], [[33, 1]]);
function Command_loading($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Command_loading);
  let progress = prop($$props, "progress", 3, 0), id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "progress",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const loadingState = CommandLoadingState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    progress: box.with(() => progress())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, loadingState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Command_loading, 31, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_246();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Command_loading, 34, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Command_loading,
      30,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_loading = hmr(Command_loading, () => Command_loading[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_loading[HMR].source;
    set(Command_loading[HMR].source, module.default[HMR].original);
  });
}
var command_loading_default = Command_loading;

// node_modules/bits-ui/dist/bits/command/components/command-separator.svelte
Command_separator[FILENAME] = "node_modules/bits-ui/dist/bits/command/components/command-separator.svelte";
var root_310 = add_locations(from_html(`<div><!></div>`), Command_separator[FILENAME], [[34, 2]]);
function Command_separator($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Command_separator);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "forceMount",
      "children",
      "child"
    ],
    "restProps"
  );
  const separatorState = CommandSeparatorState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    forceMount: box.with(() => forceMount())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, separatorState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          add_svelte_meta(() => snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Command_separator, 32, 2);
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var div = root_310();
          attribute_effect(div, () => ({ ...get(mergedProps) }));
          var node_3 = child(div);
          add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop), "render", Command_separator, 35, 3);
          reset(div);
          append($$anchor3, div);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if ($$props.child) $$render(consequent);
            else $$render(alternate, false);
          }),
          "if",
          Command_separator,
          31,
          1
        );
      }
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (separatorState.shouldRender) $$render(consequent_1);
      }),
      "if",
      Command_separator,
      30,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Command_separator = hmr(Command_separator, () => Command_separator[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Command_separator[HMR].source;
    set(Command_separator[HMR].source, module.default[HMR].original);
  });
}
var command_separator_default = Command_separator;

// node_modules/bits-ui/dist/bits/command/compute-command-score.js
var SCORE_CONTINUE_MATCH = 1;
var SCORE_SPACE_WORD_JUMP = 0.9;
var SCORE_NON_SPACE_WORD_JUMP = 0.8;
var SCORE_CHARACTER_JUMP = 0.17;
var SCORE_TRANSPOSITION = 0.1;
var PENALTY_SKIPPED = 0.999;
var PENALTY_CASE_MISMATCH = 0.9999;
var PENALTY_NOT_COMPLETE = 0.99;
var IS_GAP_REGEXP = /[\\/_+.#"@[({&]/;
var COUNT_GAPS_REGEXP = /[\\/_+.#"@[({&]/g;
var IS_SPACE_REGEXP = /[\s-]/;
var COUNT_SPACE_REGEXP = /[\s-]/g;
function computeCommandScoreInner(string, abbreviation, lowerString, lowerAbbreviation, stringIndex, abbreviationIndex, memoizedResults) {
  if (abbreviationIndex === abbreviation.length) {
    if (stringIndex === string.length)
      return SCORE_CONTINUE_MATCH;
    return PENALTY_NOT_COMPLETE;
  }
  const memoizeKey = `${stringIndex},${abbreviationIndex}`;
  if (memoizedResults[memoizeKey] !== void 0)
    return memoizedResults[memoizeKey];
  const abbreviationChar = lowerAbbreviation.charAt(abbreviationIndex);
  let index = lowerString.indexOf(abbreviationChar, stringIndex);
  let highScore = 0;
  let score, transposedScore, wordBreaks, spaceBreaks;
  while (index >= 0) {
    score = computeCommandScoreInner(string, abbreviation, lowerString, lowerAbbreviation, index + 1, abbreviationIndex + 1, memoizedResults);
    if (score > highScore) {
      if (index === stringIndex) {
        score *= SCORE_CONTINUE_MATCH;
      } else if (IS_GAP_REGEXP.test(string.charAt(index - 1))) {
        score *= SCORE_NON_SPACE_WORD_JUMP;
        wordBreaks = string.slice(stringIndex, index - 1).match(COUNT_GAPS_REGEXP);
        if (wordBreaks && stringIndex > 0) {
          score *= PENALTY_SKIPPED ** wordBreaks.length;
        }
      } else if (IS_SPACE_REGEXP.test(string.charAt(index - 1))) {
        score *= SCORE_SPACE_WORD_JUMP;
        spaceBreaks = string.slice(stringIndex, index - 1).match(COUNT_SPACE_REGEXP);
        if (spaceBreaks && stringIndex > 0) {
          score *= PENALTY_SKIPPED ** spaceBreaks.length;
        }
      } else {
        score *= SCORE_CHARACTER_JUMP;
        if (stringIndex > 0) {
          score *= PENALTY_SKIPPED ** (index - stringIndex);
        }
      }
      if (string.charAt(index) !== abbreviation.charAt(abbreviationIndex)) {
        score *= PENALTY_CASE_MISMATCH;
      }
    }
    if (score < SCORE_TRANSPOSITION && lowerString.charAt(index - 1) === lowerAbbreviation.charAt(abbreviationIndex + 1) || lowerAbbreviation.charAt(abbreviationIndex + 1) === lowerAbbreviation.charAt(abbreviationIndex) && lowerString.charAt(index - 1) !== lowerAbbreviation.charAt(abbreviationIndex)) {
      transposedScore = computeCommandScoreInner(string, abbreviation, lowerString, lowerAbbreviation, index + 1, abbreviationIndex + 2, memoizedResults);
      if (transposedScore * SCORE_TRANSPOSITION > score) {
        score = transposedScore * SCORE_TRANSPOSITION;
      }
    }
    if (score > highScore) {
      highScore = score;
    }
    index = lowerString.indexOf(abbreviationChar, index + 1);
  }
  memoizedResults[memoizeKey] = highScore;
  return highScore;
}
function formatInput(string) {
  return string.toLowerCase().replace(COUNT_SPACE_REGEXP, " ");
}
function computeCommandScore(command, search, commandKeywords) {
  command = commandKeywords && commandKeywords.length > 0 ? `${`${command} ${commandKeywords?.join(" ")}`}` : command;
  return computeCommandScoreInner(command, search, formatInput(command), formatInput(search), 0, 0, {});
}

// node_modules/bits-ui/dist/bits/context-menu/exports.js
var exports_exports11 = {};
__export(exports_exports11, {
  Arrow: () => menu_arrow_default,
  CheckboxGroup: () => menu_checkbox_group_default,
  CheckboxItem: () => menu_checkbox_item_default,
  Content: () => context_menu_content_default,
  ContentStatic: () => context_menu_content_static_default,
  Group: () => menu_group_default,
  GroupHeading: () => menu_group_heading_default,
  Item: () => menu_item_default,
  Portal: () => portal_default,
  RadioGroup: () => menu_radio_group_default,
  RadioItem: () => menu_radio_item_default,
  Root: () => context_menu_default,
  Separator: () => menu_separator_default,
  Sub: () => menu_sub_default,
  SubContent: () => menu_sub_content_default,
  SubContentStatic: () => menu_sub_content_static_default,
  SubTrigger: () => menu_sub_trigger_default,
  Trigger: () => context_menu_trigger_default
});

// node_modules/bits-ui/dist/bits/menu/utils.js
var SELECTION_KEYS3 = [kbd_constants_exports.ENTER, kbd_constants_exports.SPACE];
var FIRST_KEYS3 = [kbd_constants_exports.ARROW_DOWN, kbd_constants_exports.PAGE_UP, kbd_constants_exports.HOME];
var LAST_KEYS3 = [kbd_constants_exports.ARROW_UP, kbd_constants_exports.PAGE_DOWN, kbd_constants_exports.END];
var FIRST_LAST_KEYS3 = [...FIRST_KEYS3, ...LAST_KEYS3];
var SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS3, kbd_constants_exports.ARROW_RIGHT],
  rtl: [...SELECTION_KEYS3, kbd_constants_exports.ARROW_LEFT]
};
var SUB_CLOSE_KEYS = {
  ltr: [kbd_constants_exports.ARROW_LEFT],
  rtl: [kbd_constants_exports.ARROW_RIGHT]
};
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getCheckedState(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function isMouseEvent(event) {
  return event.pointerType === "mouse";
}

// node_modules/bits-ui/dist/internal/focus.js
function focus(element2, { select = false } = {}) {
  if (!element2 || !element2.focus)
    return;
  const doc = getDocument(element2);
  if (doc.activeElement === element2)
    return;
  const previouslyFocusedElement = doc.activeElement;
  element2.focus({ preventScroll: true });
  if (element2 !== previouslyFocusedElement && isSelectableInput(element2) && select) {
    element2.select();
  }
}
function focusFirst(candidates, { select = false } = {}, getActiveElement3) {
  const previouslyFocusedElement = getActiveElement3();
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (getActiveElement3() !== previouslyFocusedElement)
      return true;
  }
}
function getTabbableCandidates(container) {
  const nodes = [];
  const doc = getDocument(container);
  const walker = doc.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
}

// node_modules/bits-ui/dist/internal/tabbable.js
function getTabbableOptions() {
  return {
    getShadowRoot: true,
    displayCheck: (
      // JSDOM does not support the `tabbable` library. To solve this we can
      // check if `ResizeObserver` is a real function (not polyfilled), which
      // determines if the current environment is JSDOM-like.
      typeof ResizeObserver === "function" && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
    )
  };
}
function getTabbableFrom(currentNode, direction) {
  if (!isTabbable(currentNode, getTabbableOptions())) {
    return getTabbableFromFocusable(currentNode, direction);
  }
  const doc = getDocument(currentNode);
  const allTabbable = tabbable(doc.body, getTabbableOptions());
  if (direction === "prev")
    allTabbable.reverse();
  const activeIndex = allTabbable.indexOf(currentNode);
  if (activeIndex === -1)
    return doc.body;
  const nextTabbableElements = allTabbable.slice(activeIndex + 1);
  return nextTabbableElements[0];
}
function getTabbableFromFocusable(currentNode, direction) {
  const doc = getDocument(currentNode);
  if (!isFocusable(currentNode, getTabbableOptions()))
    return doc.body;
  const allFocusable = focusable(doc.body, getTabbableOptions());
  if (direction === "prev")
    allFocusable.reverse();
  const activeIndex = allFocusable.indexOf(currentNode);
  if (activeIndex === -1)
    return doc.body;
  const nextFocusableElements = allFocusable.slice(activeIndex + 1);
  return nextFocusableElements.find((node) => isTabbable(node, getTabbableOptions())) ?? doc.body;
}

// node_modules/bits-ui/dist/internal/grace-area.svelte.js
var GraceArea = class {
  #opts;
  #enabled;
  #isPointerInTransit;
  #pointerGraceArea = tag(state(null), "GraceArea.#pointerGraceArea");
  constructor(opts) {
    this.#opts = opts;
    this.#enabled = tag(user_derived(() => this.#opts.enabled()), "GraceArea.#enabled");
    this.#isPointerInTransit = boxAutoReset(false, {
      afterMs: opts.transitTimeout ?? 300,
      onChange: (value) => {
        if (!get(this.#enabled)) return;
        this.#opts.setIsPointerInTransit?.(value);
      },
      getWindow: () => getWindow(this.#opts.triggerNode())
    });
    watch([opts.triggerNode, opts.contentNode, opts.enabled], ([triggerNode, contentNode, enabled]) => {
      if (!triggerNode || !contentNode || !enabled) return;
      const handleTriggerLeave = (e) => {
        this.#createGraceArea(e, contentNode);
      };
      const handleContentLeave = (e) => {
        this.#createGraceArea(e, triggerNode);
      };
      return executeCallbacks(on(triggerNode, "pointerleave", handleTriggerLeave), on(contentNode, "pointerleave", handleContentLeave));
    });
    watch(() => get(this.#pointerGraceArea), () => {
      const handleTrackPointerGrace = (e) => {
        if (!get(this.#pointerGraceArea)) return;
        const target = e.target;
        if (!isElement2(target)) return;
        const pointerPosition = { x: e.clientX, y: e.clientY };
        const hasEnteredTarget = opts.triggerNode()?.contains(target) || opts.contentNode()?.contains(target);
        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, get(this.#pointerGraceArea));
        if (hasEnteredTarget) {
          this.#removeGraceArea();
        } else if (isPointerOutsideGraceArea) {
          this.#removeGraceArea();
          opts.onPointerExit();
        }
      };
      const doc = getDocument(opts.triggerNode() ?? opts.contentNode());
      if (!doc) return;
      return on(doc, "pointermove", handleTrackPointerGrace);
    });
  }
  #removeGraceArea() {
    set(this.#pointerGraceArea, null);
    this.#isPointerInTransit.current = false;
  }
  #createGraceArea(e, hoverTarget) {
    const currentTarget = e.currentTarget;
    if (!isHTMLElement2(currentTarget)) return;
    const exitPoint = { x: e.clientX, y: e.clientY };
    const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
    const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
    const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
    const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
    set(this.#pointerGraceArea, graceArea, true);
    this.#isPointerInTransit.current = true;
  }
};
function getExitSideFromRect(point, rect) {
  const top = Math.abs(rect.top - point.y);
  const bottom = Math.abs(rect.bottom - point.y);
  const right = Math.abs(rect.right - point.x);
  const left = Math.abs(rect.left - point.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const tipPadding = padding * 1.5;
  switch (exitSide) {
    case "top":
      return [
        { x: exitPoint.x - padding, y: exitPoint.y + padding },
        { x: exitPoint.x, y: exitPoint.y - tipPadding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      ];
    case "bottom":
      return [
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x, y: exitPoint.y + tipPadding },
        { x: exitPoint.x + padding, y: exitPoint.y - padding }
      ];
    case "left":
      return [
        { x: exitPoint.x + padding, y: exitPoint.y - padding },
        { x: exitPoint.x - tipPadding, y: exitPoint.y },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      ];
    case "right":
      return [
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x + tipPadding, y: exitPoint.y },
        { x: exitPoint.x - padding, y: exitPoint.y + padding }
      ];
  }
}
function getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    { x: left, y: top },
    { x: right, y: top },
    { x: right, y: bottom },
    { x: left, y: bottom }
  ];
}
function isPointInPolygon(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j2 = polygon.length - 1; i < polygon.length; j2 = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j2].x;
    const yj = polygon[j2].y;
    const intersect = strict_equals(yi > y, yj > y, false) && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a2, b) => {
    if (a2.x < b.x) return -1;
    else if (a2.x > b.x) return 1;
    else if (a2.y < b.y) return -1;
    else if (a2.y > b.y) return 1;
    else return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1) return points.slice();
  const upperHull = [];
  for (let i = 0; i < points.length; i++) {
    const p2 = points[i];
    while (upperHull.length >= 2) {
      const q = upperHull[upperHull.length - 1];
      const r = upperHull[upperHull.length - 2];
      if ((q.x - r.x) * (p2.y - r.y) >= (q.y - r.y) * (p2.x - r.x)) upperHull.pop();
      else break;
    }
    upperHull.push(p2);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i = points.length - 1; i >= 0; i--) {
    const p2 = points[i];
    while (lowerHull.length >= 2) {
      const q = lowerHull[lowerHull.length - 1];
      const r = lowerHull[lowerHull.length - 2];
      if ((q.x - r.x) * (p2.y - r.y) >= (q.y - r.y) * (p2.x - r.x)) lowerHull.pop();
      else break;
    }
    lowerHull.push(p2);
  }
  lowerHull.pop();
  if (strict_equals(upperHull.length, 1) && strict_equals(lowerHull.length, 1) && strict_equals(upperHull[0].x, lowerHull[0].x) && strict_equals(upperHull[0].y, lowerHull[0].y)) return upperHull;
  else return upperHull.concat(lowerHull);
}

// node_modules/bits-ui/dist/bits/menu/menu.svelte.js
var CONTEXT_MENU_TRIGGER_ATTR = "data-context-menu-trigger";
var MenuRootContext = new Context("Menu.Root");
var MenuMenuContext = new Context("Menu.Root | Menu.Sub");
var MenuContentContext = new Context("Menu.Content");
var MenuGroupContext = new Context("Menu.Group | Menu.RadioGroup");
var MenuRadioGroupContext = new Context("Menu.RadioGroup");
var MenuCheckboxGroupContext = new Context("Menu.CheckboxGroup");
var MenuOpenEvent = new CustomEventDispatcher("bitsmenuopen", { bubbles: false, cancelable: true });
var menuAttrs = createBitsAttrs({
  component: "menu",
  parts: [
    "trigger",
    "content",
    "sub-trigger",
    "item",
    "group",
    "group-heading",
    "checkbox-group",
    "checkbox-item",
    "radio-group",
    "radio-item",
    "separator",
    "sub-content",
    "arrow"
  ]
});
var MenuRootState = class _MenuRootState {
  static create(opts) {
    const root18 = new _MenuRootState(opts);
    return MenuRootContext.set(root18);
  }
  opts;
  isUsingKeyboard = new IsUsingKeyboard();
  #ignoreCloseAutoFocus = tag(state(false), "MenuRootState.ignoreCloseAutoFocus");
  get ignoreCloseAutoFocus() {
    return get(this.#ignoreCloseAutoFocus);
  }
  set ignoreCloseAutoFocus(value) {
    set(this.#ignoreCloseAutoFocus, value, true);
  }
  #isPointerInTransit = tag(state(false), "MenuRootState.isPointerInTransit");
  get isPointerInTransit() {
    return get(this.#isPointerInTransit);
  }
  set isPointerInTransit(value) {
    set(this.#isPointerInTransit, value, true);
  }
  constructor(opts) {
    this.opts = opts;
  }
  getBitsAttr = (part) => {
    return menuAttrs.getAttr(part, this.opts.variant.current);
  };
};
var MenuMenuState = class _MenuMenuState {
  static create(opts, root18) {
    return MenuMenuContext.set(new _MenuMenuState(opts, root18, null));
  }
  opts;
  root;
  parentMenu;
  contentId = box.with(() => "");
  #contentNode = tag(state(null), "MenuMenuState.contentNode");
  get contentNode() {
    return get(this.#contentNode);
  }
  set contentNode(value) {
    set(this.#contentNode, value, true);
  }
  #triggerNode = tag(state(null), "MenuMenuState.triggerNode");
  get triggerNode() {
    return get(this.#triggerNode);
  }
  set triggerNode(value) {
    set(this.#triggerNode, value, true);
  }
  constructor(opts, root18, parentMenu) {
    this.opts = opts;
    this.root = root18;
    this.parentMenu = parentMenu;
    new OpenChangeComplete({
      ref: box.with(() => this.contentNode),
      open: this.opts.open,
      onComplete: () => {
        this.opts.onOpenChangeComplete.current(this.opts.open.current);
      }
    });
    if (parentMenu) {
      watch(() => parentMenu.opts.open.current, () => {
        if (parentMenu.opts.open.current) return;
        this.opts.open.current = false;
      });
    }
  }
  toggleOpen() {
    this.opts.open.current = !this.opts.open.current;
  }
  onOpen() {
    this.opts.open.current = true;
  }
  onClose() {
    this.opts.open.current = false;
  }
};
var MenuContentState = class _MenuContentState {
  static create(opts) {
    return MenuContentContext.set(new _MenuContentState(opts, MenuMenuContext.get()));
  }
  opts;
  parentMenu;
  rovingFocusGroup;
  domContext;
  attachment;
  #search = tag(state(""), "MenuContentState.search");
  get search() {
    return get(this.#search);
  }
  set search(value) {
    set(this.#search, value, true);
  }
  #timer = 0;
  #handleTypeaheadSearch;
  #mounted = tag(state(false), "MenuContentState.mounted");
  get mounted() {
    return get(this.#mounted);
  }
  set mounted(value) {
    set(this.#mounted, value, true);
  }
  #isSub;
  constructor(opts, parentMenu) {
    this.opts = opts;
    this.parentMenu = parentMenu;
    this.domContext = new DOMContext(opts.ref);
    this.attachment = attachRef(this.opts.ref, (v) => {
      if (strict_equals(this.parentMenu.contentNode, v, false)) {
        this.parentMenu.contentNode = v;
      }
    });
    parentMenu.contentId = opts.id;
    this.#isSub = opts.isSub ?? false;
    this.onkeydown = this.onkeydown.bind(this);
    this.onblur = this.onblur.bind(this);
    this.onfocus = this.onfocus.bind(this);
    this.handleInteractOutside = this.handleInteractOutside.bind(this);
    new GraceArea({
      contentNode: () => this.parentMenu.contentNode,
      triggerNode: () => this.parentMenu.triggerNode,
      enabled: () => this.parentMenu.opts.open.current && Boolean(this.parentMenu.triggerNode?.hasAttribute(this.parentMenu.root.getBitsAttr("sub-trigger"))),
      onPointerExit: () => {
        this.parentMenu.opts.open.current = false;
      },
      setIsPointerInTransit: (value) => {
        this.parentMenu.root.isPointerInTransit = value;
      }
    });
    this.#handleTypeaheadSearch = new DOMTypeahead({
      getActiveElement: () => this.domContext.getActiveElement(),
      getWindow: () => this.domContext.getWindow()
    }).handleTypeaheadSearch;
    this.rovingFocusGroup = new RovingFocusGroup({
      rootNode: box.with(() => this.parentMenu.contentNode),
      candidateAttr: this.parentMenu.root.getBitsAttr("item"),
      loop: this.opts.loop,
      orientation: box.with(() => "vertical")
    });
    watch(() => this.parentMenu.contentNode, (contentNode) => {
      if (!contentNode) return;
      const handler = () => {
        afterTick(() => {
          if (!this.parentMenu.root.isUsingKeyboard.current) return;
          this.rovingFocusGroup.focusFirstCandidate();
        });
      };
      return MenuOpenEvent.listen(contentNode, handler);
    });
    user_effect(() => {
      if (!this.parentMenu.opts.open.current) {
        this.domContext.getWindow().clearTimeout(this.#timer);
      }
    });
  }
  #getCandidateNodes() {
    const node = this.parentMenu.contentNode;
    if (!node) return [];
    const candidates = Array.from(node.querySelectorAll(`[${this.parentMenu.root.getBitsAttr("item")}]:not([data-disabled])`));
    return candidates;
  }
  #isPointerMovingToSubmenu() {
    return this.parentMenu.root.isPointerInTransit;
  }
  onCloseAutoFocus = (e) => {
    this.opts.onCloseAutoFocus.current?.(e);
    if (e.defaultPrevented || this.#isSub) return;
    if (this.parentMenu.triggerNode && isTabbable(this.parentMenu.triggerNode)) {
      this.parentMenu.triggerNode.focus();
    }
  };
  handleTabKeyDown(e) {
    let rootMenu = this.parentMenu;
    while (strict_equals(rootMenu.parentMenu, null, false)) {
      rootMenu = rootMenu.parentMenu;
    }
    if (!rootMenu.triggerNode) return;
    e.preventDefault();
    const nodeToFocus = getTabbableFrom(rootMenu.triggerNode, e.shiftKey ? "prev" : "next");
    if (nodeToFocus) {
      this.parentMenu.root.ignoreCloseAutoFocus = true;
      rootMenu.onClose();
      afterTick(() => {
        nodeToFocus.focus();
        afterTick(() => {
          this.parentMenu.root.ignoreCloseAutoFocus = false;
        });
      });
    } else {
      this.domContext.getDocument().body.focus();
    }
  }
  onkeydown(e) {
    if (e.defaultPrevented) return;
    if (strict_equals(e.key, kbd_constants_exports.TAB)) {
      this.handleTabKeyDown(e);
      return;
    }
    const target = e.target;
    const currentTarget = e.currentTarget;
    if (!isHTMLElement2(target) || !isHTMLElement2(currentTarget)) return;
    const isKeydownInside = strict_equals(target.closest(`[${this.parentMenu.root.getBitsAttr("content")}]`)?.id, this.parentMenu.contentId.current);
    const isModifierKey = e.ctrlKey || e.altKey || e.metaKey;
    const isCharacterKey = strict_equals(e.key.length, 1);
    const kbdFocusedEl = this.rovingFocusGroup.handleKeydown(target, e);
    if (kbdFocusedEl) return;
    if (strict_equals(e.code, "Space")) return;
    const candidateNodes = this.#getCandidateNodes();
    if (isKeydownInside) {
      if (!isModifierKey && isCharacterKey) {
        this.#handleTypeaheadSearch(e.key, candidateNodes);
      }
    }
    if (strict_equals(e.target?.id, this.parentMenu.contentId.current, false)) return;
    if (!FIRST_LAST_KEYS3.includes(e.key)) return;
    e.preventDefault();
    if (LAST_KEYS3.includes(e.key)) {
      candidateNodes.reverse();
    }
    focusFirst(candidateNodes, { select: false }, () => this.domContext.getActiveElement());
  }
  onblur(e) {
    if (!isElement2(e.currentTarget)) return;
    if (!isElement2(e.target)) return;
    if (!e.currentTarget.contains?.(e.target)) {
      this.domContext.getWindow().clearTimeout(this.#timer);
      this.search = "";
    }
  }
  onfocus(_) {
    if (!this.parentMenu.root.isUsingKeyboard.current) return;
    afterTick(() => this.rovingFocusGroup.focusFirstCandidate());
  }
  onItemEnter() {
    return this.#isPointerMovingToSubmenu();
  }
  onItemLeave(e) {
    if (e.currentTarget.hasAttribute(this.parentMenu.root.getBitsAttr("sub-trigger"))) return;
    if (this.#isPointerMovingToSubmenu() || this.parentMenu.root.isUsingKeyboard.current) return;
    const contentNode = this.parentMenu.contentNode;
    contentNode?.focus();
    this.rovingFocusGroup.setCurrentTabStopId("");
  }
  onTriggerLeave() {
    if (this.#isPointerMovingToSubmenu()) return true;
    return false;
  }
  onOpenAutoFocus = (e) => {
    if (e.defaultPrevented) return;
    e.preventDefault();
    const contentNode = this.parentMenu.contentNode;
    contentNode?.focus();
  };
  handleInteractOutside(e) {
    if (!isElementOrSVGElement(e.target)) return;
    const triggerId = this.parentMenu.triggerNode?.id;
    if (strict_equals(e.target.id, triggerId)) {
      e.preventDefault();
      return;
    }
    if (e.target.closest(`#${triggerId}`)) {
      e.preventDefault();
    }
  }
  #snippetProps = tag(user_derived(() => ({ open: this.parentMenu.opts.open.current })), "MenuContentState.snippetProps");
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "menu",
      "aria-orientation": getAriaOrientation("vertical"),
      [this.parentMenu.root.getBitsAttr("content")]: "",
      "data-state": getDataOpenClosed(this.parentMenu.opts.open.current),
      onkeydown: this.onkeydown,
      onblur: this.onblur,
      onfocus: this.onfocus,
      dir: this.parentMenu.root.opts.dir.current,
      style: { pointerEvents: "auto" },
      ...this.attachment
    })),
    "MenuContentState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
  popperProps = { onCloseAutoFocus: (e) => this.onCloseAutoFocus(e) };
};
var MenuItemSharedState = class {
  opts;
  content;
  attachment;
  #isFocused = tag(state(false), "MenuItemSharedState.#isFocused");
  constructor(opts, content) {
    this.opts = opts;
    this.content = content;
    this.attachment = attachRef(this.opts.ref);
    this.onpointermove = this.onpointermove.bind(this);
    this.onpointerleave = this.onpointerleave.bind(this);
    this.onfocus = this.onfocus.bind(this);
    this.onblur = this.onblur.bind(this);
  }
  onpointermove(e) {
    if (e.defaultPrevented) return;
    if (!isMouseEvent(e)) return;
    if (this.opts.disabled.current) {
      this.content.onItemLeave(e);
    } else {
      const defaultPrevented = this.content.onItemEnter();
      if (defaultPrevented) return;
      const item = e.currentTarget;
      if (!isHTMLElement2(item)) return;
      item.focus();
    }
  }
  onpointerleave(e) {
    if (e.defaultPrevented) return;
    if (!isMouseEvent(e)) return;
    this.content.onItemLeave(e);
  }
  onfocus(e) {
    afterTick(() => {
      if (e.defaultPrevented || this.opts.disabled.current) return;
      set(this.#isFocused, true);
    });
  }
  onblur(e) {
    afterTick(() => {
      if (e.defaultPrevented) return;
      set(this.#isFocused, false);
    });
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      tabindex: -1,
      role: "menuitem",
      "aria-disabled": getAriaDisabled(this.opts.disabled.current),
      "data-disabled": getDataDisabled(this.opts.disabled.current),
      "data-highlighted": get(this.#isFocused) ? "" : void 0,
      [this.content.parentMenu.root.getBitsAttr("item")]: "",
      //
      onpointermove: this.onpointermove,
      onpointerleave: this.onpointerleave,
      onfocus: this.onfocus,
      onblur: this.onblur,
      ...this.attachment
    })),
    "MenuItemSharedState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var MenuItemState = class _MenuItemState {
  static create(opts) {
    const item = new MenuItemSharedState(opts, MenuContentContext.get());
    return new _MenuItemState(opts, item);
  }
  opts;
  item;
  root;
  #isPointerDown = false;
  constructor(opts, item) {
    this.opts = opts;
    this.item = item;
    this.root = item.content.parentMenu.root;
    this.onkeydown = this.onkeydown.bind(this);
    this.onclick = this.onclick.bind(this);
    this.onpointerdown = this.onpointerdown.bind(this);
    this.onpointerup = this.onpointerup.bind(this);
  }
  #handleSelect() {
    if (this.item.opts.disabled.current) return;
    const selectEvent = new CustomEvent("menuitemselect", { bubbles: true, cancelable: true });
    this.opts.onSelect.current(selectEvent);
    if (selectEvent.defaultPrevented) {
      this.item.content.parentMenu.root.isUsingKeyboard.current = false;
      return;
    }
    if (this.opts.closeOnSelect.current) {
      this.item.content.parentMenu.root.opts.onClose();
    }
  }
  onkeydown(e) {
    const isTypingAhead = strict_equals(this.item.content.search, "", false);
    if (this.item.opts.disabled.current || isTypingAhead && strict_equals(e.key, kbd_constants_exports.SPACE)) return;
    if (SELECTION_KEYS3.includes(e.key)) {
      if (!isHTMLElement2(e.currentTarget)) return;
      e.currentTarget.click();
      e.preventDefault();
    }
  }
  onclick(_) {
    if (this.item.opts.disabled.current) return;
    this.#handleSelect();
  }
  onpointerup(e) {
    if (e.defaultPrevented) return;
    if (!this.#isPointerDown) {
      if (!isHTMLElement2(e.currentTarget)) return;
      e.currentTarget?.click();
    }
  }
  onpointerdown(_) {
    this.#isPointerDown = true;
  }
  #props = tag(
    user_derived(() => mergeProps(this.item.props, {
      onclick: this.onclick,
      onpointerdown: this.onpointerdown,
      onpointerup: this.onpointerup,
      onkeydown: this.onkeydown
    })),
    "MenuItemState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var MenuSubTriggerState = class _MenuSubTriggerState {
  static create(opts) {
    const content = MenuContentContext.get();
    const item = new MenuItemSharedState(opts, content);
    const submenu = MenuMenuContext.get();
    return new _MenuSubTriggerState(opts, item, content, submenu);
  }
  opts;
  item;
  content;
  submenu;
  attachment;
  #openTimer = null;
  constructor(opts, item, content, submenu) {
    this.opts = opts;
    this.item = item;
    this.content = content;
    this.submenu = submenu;
    this.attachment = attachRef(this.opts.ref, (v) => this.submenu.triggerNode = v);
    this.onpointerleave = this.onpointerleave.bind(this);
    this.onpointermove = this.onpointermove.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
    this.onclick = this.onclick.bind(this);
    onDestroyEffect(() => {
      this.#clearOpenTimer();
    });
  }
  #clearOpenTimer() {
    if (strict_equals(this.#openTimer, null)) return;
    this.content.domContext.getWindow().clearTimeout(this.#openTimer);
    this.#openTimer = null;
  }
  onpointermove(e) {
    if (!isMouseEvent(e)) return;
    if (!this.item.opts.disabled.current && !this.submenu.opts.open.current && !this.#openTimer && !this.content.parentMenu.root.isPointerInTransit) {
      this.#openTimer = this.content.domContext.setTimeout(
        () => {
          this.submenu.onOpen();
          this.#clearOpenTimer();
        },
        100
      );
    }
  }
  onpointerleave(e) {
    if (!isMouseEvent(e)) return;
    this.#clearOpenTimer();
  }
  onkeydown(e) {
    const isTypingAhead = strict_equals(this.content.search, "", false);
    if (this.item.opts.disabled.current || isTypingAhead && strict_equals(e.key, kbd_constants_exports.SPACE)) return;
    if (SUB_OPEN_KEYS[this.submenu.root.opts.dir.current].includes(e.key)) {
      e.currentTarget.click();
      e.preventDefault();
    }
  }
  onclick(e) {
    if (this.item.opts.disabled.current) return;
    if (!isHTMLElement2(e.currentTarget)) return;
    e.currentTarget.focus();
    const selectEvent = new CustomEvent("menusubtriggerselect", { bubbles: true, cancelable: true });
    this.opts.onSelect.current(selectEvent);
    if (!this.submenu.opts.open.current) {
      this.submenu.onOpen();
      afterTick(() => {
        const contentNode = this.submenu.contentNode;
        if (!contentNode) return;
        MenuOpenEvent.dispatch(contentNode);
      });
    }
  }
  #props = tag(
    user_derived(() => mergeProps(
      {
        "aria-haspopup": "menu",
        "aria-expanded": getAriaExpanded(this.submenu.opts.open.current),
        "data-state": getDataOpenClosed(this.submenu.opts.open.current),
        "aria-controls": this.submenu.opts.open.current ? this.submenu.contentId.current : void 0,
        [this.submenu.root.getBitsAttr("sub-trigger")]: "",
        onclick: this.onclick,
        onpointermove: this.onpointermove,
        onpointerleave: this.onpointerleave,
        onkeydown: this.onkeydown,
        ...this.attachment
      },
      this.item.props
    )),
    "MenuSubTriggerState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var MenuCheckboxItemState = class _MenuCheckboxItemState {
  static create(opts, checkboxGroup) {
    const item = new MenuItemState(opts, new MenuItemSharedState(opts, MenuContentContext.get()));
    return new _MenuCheckboxItemState(opts, item, checkboxGroup);
  }
  opts;
  item;
  group;
  constructor(opts, item, group = null) {
    this.opts = opts;
    this.item = item;
    this.group = group;
    if (this.group) {
      watch(() => this.group.opts.value.current, (groupValues) => {
        this.opts.checked.current = groupValues.includes(this.opts.value.current);
      });
      watch(() => this.opts.checked.current, (checked) => {
        if (checked) {
          this.group.addValue(this.opts.value.current);
        } else {
          this.group.removeValue(this.opts.value.current);
        }
      });
    }
  }
  toggleChecked() {
    if (this.opts.indeterminate.current) {
      this.opts.indeterminate.current = false;
      this.opts.checked.current = true;
    } else {
      this.opts.checked.current = !this.opts.checked.current;
    }
  }
  #snippetProps = tag(
    user_derived(() => ({
      checked: this.opts.checked.current,
      indeterminate: this.opts.indeterminate.current
    })),
    "MenuCheckboxItemState.snippetProps"
  );
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
  #props = tag(
    user_derived(() => ({
      ...this.item.props,
      role: "menuitemcheckbox",
      "aria-checked": getAriaChecked(this.opts.checked.current, this.opts.indeterminate.current),
      "data-state": getCheckedState(this.opts.checked.current),
      [this.item.root.getBitsAttr("checkbox-item")]: ""
    })),
    "MenuCheckboxItemState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var MenuGroupState = class _MenuGroupState {
  static create(opts) {
    return MenuGroupContext.set(new _MenuGroupState(opts, MenuRootContext.get()));
  }
  opts;
  root;
  attachment;
  #groupHeadingId = tag(state(void 0), "MenuGroupState.groupHeadingId");
  get groupHeadingId() {
    return get(this.#groupHeadingId);
  }
  set groupHeadingId(value) {
    set(this.#groupHeadingId, value, true);
  }
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "group",
      "aria-labelledby": this.groupHeadingId,
      [this.root.getBitsAttr("group")]: "",
      ...this.attachment
    })),
    "MenuGroupState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var MenuGroupHeadingState = class _MenuGroupHeadingState {
  static create(opts) {
    const checkboxGroup = MenuCheckboxGroupContext.getOr(null);
    if (checkboxGroup) return new _MenuGroupHeadingState(opts, checkboxGroup);
    const radioGroup = MenuRadioGroupContext.getOr(null);
    if (radioGroup) return new _MenuGroupHeadingState(opts, radioGroup);
    return new _MenuGroupHeadingState(opts, MenuGroupContext.get());
  }
  opts;
  group;
  attachment;
  constructor(opts, group) {
    this.opts = opts;
    this.group = group;
    this.attachment = attachRef(this.opts.ref, (v) => this.group.groupHeadingId = v?.id);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "group",
      [this.group.root.getBitsAttr("group-heading")]: "",
      ...this.attachment
    })),
    "MenuGroupHeadingState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var MenuSeparatorState = class _MenuSeparatorState {
  static create(opts) {
    return new _MenuSeparatorState(opts, MenuRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "group",
      [this.root.getBitsAttr("separator")]: "",
      ...this.attachment
    })),
    "MenuSeparatorState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var MenuArrowState = class _MenuArrowState {
  static create() {
    return new _MenuArrowState(MenuRootContext.get());
  }
  root;
  constructor(root18) {
    this.root = root18;
  }
  #props = tag(user_derived(() => ({ [this.root.getBitsAttr("arrow")]: "" })), "MenuArrowState.props");
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var MenuRadioGroupState = class _MenuRadioGroupState {
  static create(opts) {
    return MenuGroupContext.set(MenuRadioGroupContext.set(new _MenuRadioGroupState(opts, MenuContentContext.get())));
  }
  opts;
  content;
  attachment;
  #groupHeadingId = tag(state(null), "MenuRadioGroupState.groupHeadingId");
  get groupHeadingId() {
    return get(this.#groupHeadingId);
  }
  set groupHeadingId(value) {
    set(this.#groupHeadingId, value, true);
  }
  root;
  constructor(opts, content) {
    this.opts = opts;
    this.content = content;
    this.root = content.parentMenu.root;
    this.attachment = attachRef(this.opts.ref);
  }
  setValue(v) {
    this.opts.value.current = v;
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      [this.root.getBitsAttr("radio-group")]: "",
      role: "group",
      "aria-labelledby": this.groupHeadingId,
      ...this.attachment
    })),
    "MenuRadioGroupState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var MenuRadioItemState = class _MenuRadioItemState {
  static create(opts) {
    const radioGroup = MenuRadioGroupContext.get();
    const sharedItem = new MenuItemSharedState(opts, radioGroup.content);
    const item = new MenuItemState(opts, sharedItem);
    return new _MenuRadioItemState(opts, item, radioGroup);
  }
  opts;
  item;
  group;
  attachment;
  #isChecked = tag(user_derived(() => strict_equals(this.group.opts.value.current, this.opts.value.current)), "MenuRadioItemState.isChecked");
  get isChecked() {
    return get(this.#isChecked);
  }
  set isChecked(value) {
    set(this.#isChecked, value);
  }
  constructor(opts, item, group) {
    this.opts = opts;
    this.item = item;
    this.group = group;
    this.attachment = attachRef(this.opts.ref);
  }
  selectValue() {
    this.group.setValue(this.opts.value.current);
  }
  #props = tag(
    user_derived(() => ({
      [this.group.root.getBitsAttr("radio-item")]: "",
      ...this.item.props,
      role: "menuitemradio",
      "aria-checked": getAriaChecked(this.isChecked, false),
      "data-state": getCheckedState(this.isChecked),
      ...this.attachment
    })),
    "MenuRadioItemState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var DropdownMenuTriggerState = class _DropdownMenuTriggerState {
  static create(opts) {
    return new _DropdownMenuTriggerState(opts, MenuMenuContext.get());
  }
  opts;
  parentMenu;
  attachment;
  constructor(opts, parentMenu) {
    this.opts = opts;
    this.parentMenu = parentMenu;
    this.attachment = attachRef(this.opts.ref, (v) => this.parentMenu.triggerNode = v);
  }
  onpointerdown = (e) => {
    if (this.opts.disabled.current) return;
    if (strict_equals(e.pointerType, "touch")) return e.preventDefault();
    if (strict_equals(e.button, 0) && strict_equals(e.ctrlKey, false)) {
      this.parentMenu.toggleOpen();
      if (!this.parentMenu.opts.open.current) e.preventDefault();
    }
  };
  onpointerup = (e) => {
    if (this.opts.disabled.current) return;
    if (strict_equals(e.pointerType, "touch")) {
      e.preventDefault();
      this.parentMenu.toggleOpen();
    }
  };
  onkeydown = (e) => {
    if (this.opts.disabled.current) return;
    if (strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ENTER)) {
      this.parentMenu.toggleOpen();
      e.preventDefault();
      return;
    }
    if (strict_equals(e.key, kbd_constants_exports.ARROW_DOWN)) {
      this.parentMenu.onOpen();
      e.preventDefault();
    }
  };
  #ariaControls = tag(
    user_derived(() => {
      if (this.parentMenu.opts.open.current && this.parentMenu.contentId.current) return this.parentMenu.contentId.current;
      return void 0;
    }),
    "DropdownMenuTriggerState.#ariaControls"
  );
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      disabled: this.opts.disabled.current,
      "aria-haspopup": "menu",
      "aria-expanded": getAriaExpanded(this.parentMenu.opts.open.current),
      "aria-controls": get(this.#ariaControls),
      "data-disabled": getDataDisabled(this.opts.disabled.current),
      "data-state": getDataOpenClosed(this.parentMenu.opts.open.current),
      [this.parentMenu.root.getBitsAttr("trigger")]: "",
      //
      onpointerdown: this.onpointerdown,
      onpointerup: this.onpointerup,
      onkeydown: this.onkeydown,
      ...this.attachment
    })),
    "DropdownMenuTriggerState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var ContextMenuTriggerState = class _ContextMenuTriggerState {
  static create(opts) {
    return new _ContextMenuTriggerState(opts, MenuMenuContext.get());
  }
  opts;
  parentMenu;
  attachment;
  #point = tag(state(proxy({ x: 0, y: 0 })), "ContextMenuTriggerState.#point");
  virtualElement = box({
    getBoundingClientRect: () => DOMRect.fromRect({ width: 0, height: 0, ...get(this.#point) })
  });
  #longPressTimer = null;
  constructor(opts, parentMenu) {
    this.opts = opts;
    this.parentMenu = parentMenu;
    this.attachment = attachRef(this.opts.ref, (v) => this.parentMenu.triggerNode = v);
    this.oncontextmenu = this.oncontextmenu.bind(this);
    this.onpointerdown = this.onpointerdown.bind(this);
    this.onpointermove = this.onpointermove.bind(this);
    this.onpointercancel = this.onpointercancel.bind(this);
    this.onpointerup = this.onpointerup.bind(this);
    watch(() => get(this.#point), (point) => {
      this.virtualElement.current = {
        getBoundingClientRect: () => DOMRect.fromRect({ width: 0, height: 0, ...point })
      };
    });
    watch(() => this.opts.disabled.current, (isDisabled) => {
      if (isDisabled) {
        this.#clearLongPressTimer();
      }
    });
    onDestroyEffect(() => this.#clearLongPressTimer());
  }
  #clearLongPressTimer() {
    if (strict_equals(this.#longPressTimer, null)) return;
    getWindow(this.opts.ref.current).clearTimeout(this.#longPressTimer);
  }
  #handleOpen(e) {
    set(this.#point, { x: e.clientX, y: e.clientY }, true);
    this.parentMenu.onOpen();
  }
  oncontextmenu(e) {
    if (e.defaultPrevented || this.opts.disabled.current) return;
    this.#clearLongPressTimer();
    this.#handleOpen(e);
    e.preventDefault();
    this.parentMenu.contentNode?.focus();
  }
  onpointerdown(e) {
    if (this.opts.disabled.current || isMouseEvent(e)) return;
    this.#clearLongPressTimer();
    this.#longPressTimer = getWindow(this.opts.ref.current).setTimeout(() => this.#handleOpen(e), 700);
  }
  onpointermove(e) {
    if (this.opts.disabled.current || isMouseEvent(e)) return;
    this.#clearLongPressTimer();
  }
  onpointercancel(e) {
    if (this.opts.disabled.current || isMouseEvent(e)) return;
    this.#clearLongPressTimer();
  }
  onpointerup(e) {
    if (this.opts.disabled.current || isMouseEvent(e)) return;
    this.#clearLongPressTimer();
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      disabled: this.opts.disabled.current,
      "data-disabled": getDataDisabled(this.opts.disabled.current),
      "data-state": getDataOpenClosed(this.parentMenu.opts.open.current),
      [CONTEXT_MENU_TRIGGER_ATTR]: "",
      tabindex: -1,
      //
      onpointerdown: this.onpointerdown,
      onpointermove: this.onpointermove,
      onpointercancel: this.onpointercancel,
      onpointerup: this.onpointerup,
      oncontextmenu: this.oncontextmenu,
      ...this.attachment
    })),
    "ContextMenuTriggerState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var MenuCheckboxGroupState = class _MenuCheckboxGroupState {
  static create(opts) {
    return MenuCheckboxGroupContext.set(new _MenuCheckboxGroupState(opts, MenuContentContext.get()));
  }
  opts;
  content;
  root;
  attachment;
  #groupHeadingId = tag(state(null), "MenuCheckboxGroupState.groupHeadingId");
  get groupHeadingId() {
    return get(this.#groupHeadingId);
  }
  set groupHeadingId(value) {
    set(this.#groupHeadingId, value, true);
  }
  constructor(opts, content) {
    this.opts = opts;
    this.content = content;
    this.root = content.parentMenu.root;
    this.attachment = attachRef(this.opts.ref);
  }
  addValue(checkboxValue) {
    if (!checkboxValue) return;
    if (!this.opts.value.current.includes(checkboxValue)) {
      const newValue = [...snapshot(this.opts.value.current), checkboxValue];
      this.opts.value.current = newValue;
      this.opts.onValueChange.current(newValue);
    }
  }
  removeValue(checkboxValue) {
    if (!checkboxValue) return;
    const index = this.opts.value.current.indexOf(checkboxValue);
    if (strict_equals(index, -1)) return;
    const newValue = this.opts.value.current.filter((v) => strict_equals(v, checkboxValue, false));
    this.opts.value.current = newValue;
    this.opts.onValueChange.current(newValue);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      [this.root.getBitsAttr("checkbox-group")]: "",
      role: "group",
      "aria-labelledby": this.groupHeadingId,
      ...this.attachment
    })),
    "MenuCheckboxGroupState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var MenuSubmenuState = class {
  static create(opts) {
    const menu = MenuMenuContext.get();
    return MenuMenuContext.set(new MenuMenuState(opts, menu.root, menu));
  }
};

// node_modules/bits-ui/dist/bits/context-menu/components/context-menu.svelte
Context_menu[FILENAME] = "node_modules/bits-ui/dist/bits/context-menu/components/context-menu.svelte";
function Context_menu($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Context_menu);
  let open = prop($$props, "open", 15, false), dir = prop($$props, "dir", 3, "ltr"), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3);
  const root18 = MenuRootState.create({
    variant: box.with(() => "context-menu"),
    dir: box.with(() => dir()),
    onClose: () => {
      open(false);
      onOpenChange()?.(false);
    }
  });
  MenuMenuState.create(
    {
      open: box.with(() => open(), (v) => {
        open(v);
        onOpenChange()(v);
      }),
      onOpenChangeComplete: box.with(() => onOpenChangeComplete())
    },
    root18
  );
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => floating_layer_default(node, {
      children: wrap_snippet(Context_menu, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop), "render", Context_menu, 41, 1);
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }),
    "component",
    Context_menu,
    40,
    0,
    { componentTag: "FloatingLayer" }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Context_menu = hmr(Context_menu, () => Context_menu[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Context_menu[HMR].source;
    set(Context_menu[HMR].source, module.default[HMR].original);
  });
}
var context_menu_default = Context_menu;

// node_modules/bits-ui/dist/bits/menu/components/menu-sub.svelte
Menu_sub[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-sub.svelte";
function Menu_sub($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Menu_sub);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3);
  MenuSubmenuState.create({
    open: box.with(() => open(), (v) => {
      open(v);
      onOpenChange()?.(v);
    }),
    onOpenChangeComplete: box.with(() => onOpenChangeComplete())
  });
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => floating_layer_default(node, {
      children: wrap_snippet(Menu_sub, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop), "render", Menu_sub, 28, 1);
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }),
    "component",
    Menu_sub,
    27,
    0,
    { componentTag: "FloatingLayer" }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_sub = hmr(Menu_sub, () => Menu_sub[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_sub[HMR].source;
    set(Menu_sub[HMR].source, module.default[HMR].original);
  });
}
var menu_sub_default = Menu_sub;

// node_modules/bits-ui/dist/bits/menu/components/menu-item.svelte
Menu_item[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-item.svelte";
var root_247 = add_locations(from_html(`<div><!></div>`), Menu_item[FILENAME], [[38, 1]]);
function Menu_item($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menu_item);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), disabled = prop($$props, "disabled", 3, false), onSelect = prop($$props, "onSelect", 3, noop3), closeOnSelect = prop($$props, "closeOnSelect", 3, true), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "ref",
      "id",
      "disabled",
      "onSelect",
      "closeOnSelect"
    ],
    "restProps"
  );
  const itemState = MenuItemState.create({
    id: box.with(() => id()),
    disabled: box.with(() => disabled()),
    onSelect: box.with(() => onSelect()),
    ref: box.with(() => ref(), (v) => ref(v)),
    closeOnSelect: box.with(() => closeOnSelect())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, itemState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Menu_item, 36, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_247();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Menu_item, 39, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Menu_item,
      35,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_item = hmr(Menu_item, () => Menu_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_item[HMR].source;
    set(Menu_item[HMR].source, module.default[HMR].original);
  });
}
var menu_item_default = Menu_item;

// node_modules/bits-ui/dist/bits/menu/components/menu-group.svelte
Menu_group[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-group.svelte";
var root_248 = add_locations(from_html(`<div><!></div>`), Menu_group[FILENAME], [[30, 1]]);
function Menu_group($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menu_group);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const groupState = MenuGroupState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, groupState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Menu_group, 28, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_248();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Menu_group, 31, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Menu_group,
      27,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_group = hmr(Menu_group, () => Menu_group[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_group[HMR].source;
    set(Menu_group[HMR].source, module.default[HMR].original);
  });
}
var menu_group_default = Menu_group;

// node_modules/bits-ui/dist/bits/menu/components/menu-group-heading.svelte
Menu_group_heading[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-group-heading.svelte";
var root_249 = add_locations(from_html(`<div><!></div>`), Menu_group_heading[FILENAME], [[30, 1]]);
function Menu_group_heading($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menu_group_heading);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const groupHeadingState = MenuGroupHeadingState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, groupHeadingState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Menu_group_heading, 28, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_249();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Menu_group_heading, 31, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Menu_group_heading,
      27,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_group_heading = hmr(Menu_group_heading, () => Menu_group_heading[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_group_heading[HMR].source;
    set(Menu_group_heading[HMR].source, module.default[HMR].original);
  });
}
var menu_group_heading_default = Menu_group_heading;

// node_modules/bits-ui/dist/bits/menu/components/menu-arrow.svelte
Menu_arrow[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-arrow.svelte";
function Menu_arrow($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Menu_arrow);
  var $$ownership_validator = create_ownership_validator($$props);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "ref"], "restProps");
  const arrowState = MenuArrowState.create();
  const mergedProps = tag(user_derived(() => mergeProps(restProps, arrowState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    $$ownership_validator.binding("ref", floating_layer_arrow_default, ref);
    add_svelte_meta(
      () => floating_layer_arrow_default(node, spread_props(() => get(mergedProps), {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        }
      })),
      "component",
      Menu_arrow,
      14,
      0,
      { componentTag: "FloatingLayerArrow" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_arrow = hmr(Menu_arrow, () => Menu_arrow[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_arrow[HMR].source;
    set(Menu_arrow[HMR].source, module.default[HMR].original);
  });
}
var menu_arrow_default = Menu_arrow;

// node_modules/bits-ui/dist/bits/context-menu/components/context-menu-content.svelte
Context_menu_content[FILENAME] = "node_modules/bits-ui/dist/bits/context-menu/components/context-menu-content.svelte";
var root_47 = add_locations(from_html(`<div><div><!></div></div>`), Context_menu_content[FILENAME], [[97, 4, [[98, 5]]]]);
var root_93 = add_locations(from_html(`<div><div><!></div></div>`), Context_menu_content[FILENAME], [[130, 4, [[131, 5]]]]);
function Context_menu_content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Context_menu_content);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), onOpenAutoFocus = prop($$props, "onOpenAutoFocus", 3, noop3), preventScroll = prop($$props, "preventScroll", 3, true), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), trapFocus = prop($$props, "trapFocus", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "child",
      "children",
      "ref",
      "loop",
      "onInteractOutside",
      "onCloseAutoFocus",
      "onOpenAutoFocus",
      "preventScroll",
      "onEscapeKeydown",
      "forceMount",
      "trapFocus"
    ],
    "restProps"
  );
  const contentState = MenuContentState.create({
    id: box.with(() => id()),
    loop: box.with(() => loop()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onCloseAutoFocus: box.with(() => onCloseAutoFocus())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  function handleInteractOutside(e) {
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    if (e.target && e.target instanceof Element) {
      const subContentSelector = `[${contentState.parentMenu.root.getBitsAttr("sub-content")}]`;
      if (e.target.closest(subContentSelector)) return;
    }
    contentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  function isValidEvent2(e) {
    if ("button" in e && strict_equals(e.button, 2)) {
      const target = e.target;
      if (!target) return false;
      const isAnotherContextTrigger = strict_equals(target.closest(`[${CONTEXT_MENU_TRIGGER_ATTR}]`), contentState.parentMenu.triggerNode, false);
      return isAnotherContextTrigger;
    }
    return false;
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Context_menu_content, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0?.().props;
          props();
          let wrapperProps = () => $$arg0?.().wrapperProps;
          wrapperProps();
          var fragment_2 = comment();
          const finalProps = tag(user_derived(() => mergeProps(props(), { style: getFloatingContentCSSVars("context-menu") })), "finalProps");
          get(finalProps);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              {
                let $0 = user_derived(() => ({
                  props: get(finalProps),
                  wrapperProps: wrapperProps(),
                  ...contentState.snippetProps
                }));
                add_svelte_meta(() => snippet(node_3, () => $$props.child, () => get($0)), "render", Context_menu_content, 95, 4);
              }
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_47();
              attribute_effect(div, () => ({ ...wrapperProps() }));
              var div_1 = child(div);
              attribute_effect(div_1, () => ({ ...get(finalProps) }));
              var node_4 = child(div_1);
              add_svelte_meta(() => snippet(node_4, () => $$props.children ?? noop), "render", Context_menu_content, 99, 6);
              reset(div_1);
              reset(div);
              append($$anchor4, div);
            };
            add_svelte_meta(
              () => if_block(node_2, ($$render) => {
                if ($$props.child) $$render(consequent);
                else $$render(alternate, false);
              }),
              "if",
              Context_menu_content,
              94,
              3
            );
          }
          append($$anchor3, fragment_2);
        });
        add_svelte_meta(
          () => popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), () => contentState.popperProps, {
            get ref() {
              return contentState.opts.ref;
            },
            side: "right",
            sideOffset: 2,
            align: "start",
            get enabled() {
              return contentState.parentMenu.opts.open.current;
            },
            get preventScroll() {
              return preventScroll();
            },
            onInteractOutside: handleInteractOutside,
            onEscapeKeydown: handleEscapeKeydown,
            get onOpenAutoFocus() {
              return onOpenAutoFocus();
            },
            isValidEvent: isValidEvent2,
            get trapFocus() {
              return trapFocus();
            },
            get loop() {
              return loop();
            },
            get id() {
              return id();
            },
            popper,
            $$slots: { popper: true }
          })),
          "component",
          Context_menu_content,
          73,
          1,
          { componentTag: "PopperLayerForceMount" }
        );
      }
      append($$anchor2, fragment_1);
    };
    var alternate_2 = ($$anchor2) => {
      var fragment_4 = comment();
      var node_5 = first_child(fragment_4);
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_5 = comment();
          var node_6 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Context_menu_content, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0?.().props;
              props();
              let wrapperProps = () => $$arg0?.().wrapperProps;
              wrapperProps();
              var fragment_6 = comment();
              const finalProps = tag(user_derived(() => mergeProps(props(), { style: getFloatingContentCSSVars("context-menu") })), "finalProps");
              get(finalProps);
              var node_7 = first_child(fragment_6);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_8 = first_child(fragment_7);
                  {
                    let $0 = user_derived(() => ({
                      props: get(finalProps),
                      wrapperProps: wrapperProps(),
                      ...contentState.snippetProps
                    }));
                    add_svelte_meta(() => snippet(node_8, () => $$props.child, () => get($0)), "render", Context_menu_content, 128, 4);
                  }
                  append($$anchor5, fragment_7);
                };
                var alternate_1 = ($$anchor5) => {
                  var div_2 = root_93();
                  attribute_effect(div_2, () => ({ ...wrapperProps() }));
                  var div_3 = child(div_2);
                  attribute_effect(div_3, () => ({ ...get(finalProps) }));
                  var node_9 = child(div_3);
                  add_svelte_meta(() => snippet(node_9, () => $$props.children ?? noop), "render", Context_menu_content, 132, 6);
                  reset(div_3);
                  reset(div_2);
                  append($$anchor5, div_2);
                };
                add_svelte_meta(
                  () => if_block(node_7, ($$render) => {
                    if ($$props.child) $$render(consequent_2);
                    else $$render(alternate_1, false);
                  }),
                  "if",
                  Context_menu_content,
                  127,
                  3
                );
              }
              append($$anchor4, fragment_6);
            });
            add_svelte_meta(
              () => popper_layer_default(node_6, spread_props(() => get(mergedProps), () => contentState.popperProps, {
                get ref() {
                  return contentState.opts.ref;
                },
                side: "right",
                sideOffset: 2,
                align: "start",
                get open() {
                  return contentState.parentMenu.opts.open.current;
                },
                get preventScroll() {
                  return preventScroll();
                },
                onInteractOutside: handleInteractOutside,
                onEscapeKeydown: handleEscapeKeydown,
                get onOpenAutoFocus() {
                  return onOpenAutoFocus();
                },
                isValidEvent: isValidEvent2,
                get trapFocus() {
                  return trapFocus();
                },
                get loop() {
                  return loop();
                },
                get id() {
                  return id();
                },
                popper,
                $$slots: { popper: true }
              })),
              "component",
              Context_menu_content,
              106,
              1,
              { componentTag: "PopperLayer" }
            );
          }
          append($$anchor3, fragment_5);
        };
        add_svelte_meta(
          () => if_block(
            node_5,
            ($$render) => {
              if (!forceMount()) $$render(consequent_3);
            },
            true
          ),
          "if",
          Context_menu_content,
          105,
          0
        );
      }
      append($$anchor2, fragment_4);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (forceMount()) $$render(consequent_1);
        else $$render(alternate_2, false);
      }),
      "if",
      Context_menu_content,
      72,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Context_menu_content = hmr(Context_menu_content, () => Context_menu_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Context_menu_content[HMR].source;
    set(Context_menu_content[HMR].source, module.default[HMR].original);
  });
}
var context_menu_content_default = Context_menu_content;

// node_modules/bits-ui/dist/bits/context-menu/components/context-menu-content-static.svelte
Context_menu_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/context-menu/components/context-menu-content-static.svelte";
var root_48 = add_locations(from_html(`<div><!></div>`), Context_menu_content_static[FILENAME], [[90, 4]]);
var root_94 = add_locations(from_html(`<div><!></div>`), Context_menu_content_static[FILENAME], [[122, 4]]);
function Context_menu_content_static($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Context_menu_content_static);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), preventScroll = prop($$props, "preventScroll", 3, true), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "child",
      "children",
      "ref",
      "loop",
      "onInteractOutside",
      "onCloseAutoFocus",
      "preventScroll",
      "onEscapeKeydown",
      "forceMount"
    ],
    "restProps"
  );
  const contentState = MenuContentState.create({
    id: box.with(() => id()),
    loop: box.with(() => loop()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onCloseAutoFocus: box.with(() => onCloseAutoFocus())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  function handleInteractOutside(e) {
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  function isValidEvent2(e) {
    if ("button" in e && strict_equals(e.button, 2)) {
      const target = e.target;
      if (!target) return false;
      const isAnotherContextTrigger = strict_equals(target.closest(`[${CONTEXT_MENU_TRIGGER_ATTR}]`), contentState.parentMenu.triggerNode, false);
      return isAnotherContextTrigger;
    }
    return false;
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Context_menu_content_static, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0?.().props;
          props();
          var fragment_2 = comment();
          const finalProps = tag(user_derived(() => mergeProps(props(), { style: getFloatingContentCSSVars("context-menu") })), "finalProps");
          get(finalProps);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              {
                let $0 = user_derived(() => ({ props: get(finalProps), ...contentState.snippetProps }));
                add_svelte_meta(() => snippet(node_3, () => $$props.child, () => get($0)), "render", Context_menu_content_static, 88, 4);
              }
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_48();
              attribute_effect(div, () => ({ ...get(finalProps) }));
              var node_4 = child(div);
              add_svelte_meta(() => snippet(node_4, () => $$props.children ?? noop), "render", Context_menu_content_static, 91, 5);
              reset(div);
              append($$anchor4, div);
            };
            add_svelte_meta(
              () => if_block(node_2, ($$render) => {
                if ($$props.child) $$render(consequent);
                else $$render(alternate, false);
              }),
              "if",
              Context_menu_content_static,
              87,
              3
            );
          }
          append($$anchor3, fragment_2);
        });
        add_svelte_meta(
          () => popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), () => contentState.popperProps, {
            get ref() {
              return contentState.opts.ref;
            },
            isStatic: true,
            side: "right",
            sideOffset: 2,
            align: "start",
            get enabled() {
              return contentState.parentMenu.opts.open.current;
            },
            get preventScroll() {
              return preventScroll();
            },
            onInteractOutside: handleInteractOutside,
            onEscapeKeydown: handleEscapeKeydown,
            isValidEvent: isValidEvent2,
            trapFocus: true,
            get loop() {
              return loop();
            },
            get forceMount() {
              return forceMount();
            },
            get id() {
              return id();
            },
            popper,
            $$slots: { popper: true }
          })),
          "component",
          Context_menu_content_static,
          65,
          1,
          { componentTag: "PopperLayerForceMount" }
        );
      }
      append($$anchor2, fragment_1);
    };
    var alternate_2 = ($$anchor2) => {
      var fragment_4 = comment();
      var node_5 = first_child(fragment_4);
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_5 = comment();
          var node_6 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Context_menu_content_static, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0?.().props;
              props();
              var fragment_6 = comment();
              const finalProps = tag(user_derived(() => mergeProps(props(), { style: getFloatingContentCSSVars("context-menu") })), "finalProps");
              get(finalProps);
              var node_7 = first_child(fragment_6);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_8 = first_child(fragment_7);
                  {
                    let $0 = user_derived(() => ({ props: get(finalProps), ...contentState.snippetProps }));
                    add_svelte_meta(() => snippet(node_8, () => $$props.child, () => get($0)), "render", Context_menu_content_static, 120, 4);
                  }
                  append($$anchor5, fragment_7);
                };
                var alternate_1 = ($$anchor5) => {
                  var div_1 = root_94();
                  attribute_effect(div_1, () => ({ ...get(finalProps) }));
                  var node_9 = child(div_1);
                  add_svelte_meta(() => snippet(node_9, () => $$props.children ?? noop), "render", Context_menu_content_static, 123, 5);
                  reset(div_1);
                  append($$anchor5, div_1);
                };
                add_svelte_meta(
                  () => if_block(node_7, ($$render) => {
                    if ($$props.child) $$render(consequent_2);
                    else $$render(alternate_1, false);
                  }),
                  "if",
                  Context_menu_content_static,
                  119,
                  3
                );
              }
              append($$anchor4, fragment_6);
            });
            add_svelte_meta(
              () => popper_layer_default(node_6, spread_props(() => get(mergedProps), () => contentState.popperProps, {
                get ref() {
                  return contentState.opts.ref;
                },
                isStatic: true,
                side: "right",
                sideOffset: 2,
                align: "start",
                get open() {
                  return contentState.parentMenu.opts.open.current;
                },
                get preventScroll() {
                  return preventScroll();
                },
                onInteractOutside: handleInteractOutside,
                onEscapeKeydown: handleEscapeKeydown,
                isValidEvent: isValidEvent2,
                trapFocus: true,
                get loop() {
                  return loop();
                },
                forceMount: false,
                get id() {
                  return id();
                },
                popper,
                $$slots: { popper: true }
              })),
              "component",
              Context_menu_content_static,
              97,
              1,
              { componentTag: "PopperLayer" }
            );
          }
          append($$anchor3, fragment_5);
        };
        add_svelte_meta(
          () => if_block(
            node_5,
            ($$render) => {
              if (!forceMount()) $$render(consequent_3);
            },
            true
          ),
          "if",
          Context_menu_content_static,
          96,
          0
        );
      }
      append($$anchor2, fragment_4);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (forceMount()) $$render(consequent_1);
        else $$render(alternate_2, false);
      }),
      "if",
      Context_menu_content_static,
      64,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Context_menu_content_static = hmr(Context_menu_content_static, () => Context_menu_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Context_menu_content_static[HMR].source;
    set(Context_menu_content_static[HMR].source, module.default[HMR].original);
  });
}
var context_menu_content_static_default = Context_menu_content_static;

// node_modules/bits-ui/dist/bits/context-menu/components/context-menu-trigger.svelte
Context_menu_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/context-menu/components/context-menu-trigger.svelte";
var root_311 = add_locations(from_html(`<div><!></div>`), Context_menu_trigger[FILENAME], [[35, 2]]);
function Context_menu_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Context_menu_trigger);
  let id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "children",
      "disabled"
    ],
    "restProps"
  );
  const triggerState = ContextMenuTriggerState.create({
    id: box.with(() => id()),
    disabled: box.with(() => disabled()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, triggerState.props, { style: { pointerEvents: "auto" } })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => component(node, () => components_exports.Anchor, ($$anchor2, FloatingLayer_Anchor) => {
      FloatingLayer_Anchor($$anchor2, {
        get id() {
          return id();
        },
        get virtualEl() {
          return triggerState.virtualElement;
        },
        get ref() {
          return triggerState.opts.ref;
        },
        children: wrap_snippet(Context_menu_trigger, ($$anchor3, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          {
            var consequent = ($$anchor4) => {
              var fragment_2 = comment();
              var node_2 = first_child(fragment_2);
              add_svelte_meta(() => snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Context_menu_trigger, 33, 2);
              append($$anchor4, fragment_2);
            };
            var alternate = ($$anchor4) => {
              var div = root_311();
              attribute_effect(div, () => ({ ...get(mergedProps) }));
              var node_3 = child(div);
              add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop), "render", Context_menu_trigger, 36, 3);
              reset(div);
              append($$anchor4, div);
            };
            add_svelte_meta(
              () => if_block(node_1, ($$render) => {
                if ($$props.child) $$render(consequent);
                else $$render(alternate, false);
              }),
              "if",
              Context_menu_trigger,
              32,
              1
            );
          }
          append($$anchor3, fragment_1);
        }),
        $$slots: { default: true }
      });
    }),
    "component",
    Context_menu_trigger,
    31,
    0,
    { componentTag: "FloatingLayer.Anchor" }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Context_menu_trigger = hmr(Context_menu_trigger, () => Context_menu_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Context_menu_trigger[HMR].source;
    set(Context_menu_trigger[HMR].source, module.default[HMR].original);
  });
}
var context_menu_trigger_default = Context_menu_trigger;

// node_modules/bits-ui/dist/bits/menu/components/menu-radio-item.svelte
Menu_radio_item[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-radio-item.svelte";
var root_250 = add_locations(from_html(`<div><!></div>`), Menu_radio_item[FILENAME], [[46, 1]]);
function Menu_radio_item($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menu_radio_item);
  let ref = prop($$props, "ref", 15, null), onSelect = prop($$props, "onSelect", 3, noop3), id = prop($$props, "id", 19, () => createId(uid)), disabled = prop($$props, "disabled", 3, false), closeOnSelect = prop($$props, "closeOnSelect", 3, true), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "value",
      "onSelect",
      "id",
      "disabled",
      "closeOnSelect"
    ],
    "restProps"
  );
  const radioItemState = MenuRadioItemState.create({
    value: box.with(() => $$props.value),
    id: box.with(() => id()),
    disabled: box.with(() => disabled()),
    onSelect: box.with(() => handleSelect),
    ref: box.with(() => ref(), (v) => ref(v)),
    closeOnSelect: box.with(() => closeOnSelect())
  });
  function handleSelect(e) {
    onSelect()(e);
    if (e.defaultPrevented) return;
    radioItemState.selectValue();
  }
  const mergedProps = tag(user_derived(() => mergeProps(restProps, radioItemState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps), checked: radioItemState.isChecked })), "render", Menu_radio_item, 44, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_250();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => ({ checked: radioItemState.isChecked })), "render", Menu_radio_item, 47, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Menu_radio_item,
      43,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_radio_item = hmr(Menu_radio_item, () => Menu_radio_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_radio_item[HMR].source;
    set(Menu_radio_item[HMR].source, module.default[HMR].original);
  });
}
var menu_radio_item_default = Menu_radio_item;

// node_modules/bits-ui/dist/bits/menu/components/menu-separator.svelte
Menu_separator[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-separator.svelte";
var root_251 = add_locations(from_html(`<div><!></div>`), Menu_separator[FILENAME], [[31, 1]]);
function Menu_separator($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menu_separator);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "child",
      "children"
    ],
    "restProps"
  );
  const separatorState = MenuSeparatorState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, separatorState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Menu_separator, 29, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_251();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Menu_separator, 32, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Menu_separator,
      28,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_separator = hmr(Menu_separator, () => Menu_separator[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_separator[HMR].source;
    set(Menu_separator[HMR].source, module.default[HMR].original);
  });
}
var menu_separator_default = Menu_separator;

// node_modules/bits-ui/dist/bits/menu/components/menu-radio-group.svelte
Menu_radio_group[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-radio-group.svelte";
var root_252 = add_locations(from_html(`<div><!></div>`), Menu_radio_group[FILENAME], [[41, 1]]);
function Menu_radio_group($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menu_radio_group);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15, ""), onValueChange = prop($$props, "onValueChange", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "children",
      "child",
      "ref",
      "value",
      "onValueChange"
    ],
    "restProps"
  );
  const radioGroupState = MenuRadioGroupState.create({
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    ref: box.with(() => ref(), (v) => ref(v)),
    id: box.with(() => id())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, radioGroupState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Menu_radio_group, 39, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_252();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Menu_radio_group, 42, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Menu_radio_group,
      38,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_radio_group = hmr(Menu_radio_group, () => Menu_radio_group[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_radio_group[HMR].source;
    set(Menu_radio_group[HMR].source, module.default[HMR].original);
  });
}
var menu_radio_group_default = Menu_radio_group;

// node_modules/bits-ui/dist/bits/menu/components/menu-sub-content.svelte
Menu_sub_content[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-sub-content.svelte";
var root_49 = add_locations(from_html(`<div><div><!></div></div>`), Menu_sub_content[FILENAME], [[136, 4, [[137, 5]]]]);
var root_95 = add_locations(from_html(`<div><div><!></div></div>`), Menu_sub_content[FILENAME], [[171, 4, [[172, 5]]]]);
function Menu_sub_content($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menu_sub_content);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "defer-otherwise-close"), escapeKeydownBehavior = prop($$props, "escapeKeydownBehavior", 3, "defer-otherwise-close"), onOpenAutoFocusProp = prop($$props, "onOpenAutoFocus", 3, noop3), onCloseAutoFocusProp = prop($$props, "onCloseAutoFocus", 3, noop3), onFocusOutside = prop($$props, "onFocusOutside", 3, noop3), side = prop($$props, "side", 3, "right"), trapFocus = prop($$props, "trapFocus", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child",
      "loop",
      "onInteractOutside",
      "forceMount",
      "onEscapeKeydown",
      "interactOutsideBehavior",
      "escapeKeydownBehavior",
      "onOpenAutoFocus",
      "onCloseAutoFocus",
      "onFocusOutside",
      "side",
      "trapFocus"
    ],
    "restProps"
  );
  const subContentState = MenuContentState.create({
    id: box.with(() => id()),
    loop: box.with(() => loop()),
    ref: box.with(() => ref(), (v) => ref(v)),
    isSub: true,
    onCloseAutoFocus: box.with(() => handleCloseAutoFocus)
  });
  function onkeydown(e) {
    const isKeyDownInside = e.currentTarget.contains(e.target);
    const isCloseKey = SUB_CLOSE_KEYS[subContentState.parentMenu.root.opts.dir.current].includes(e.key);
    if (isKeyDownInside && isCloseKey) {
      subContentState.parentMenu.onClose();
      const triggerNode = subContentState.parentMenu.triggerNode;
      triggerNode?.focus();
      e.preventDefault();
    }
  }
  const dataAttr = tag(user_derived(() => subContentState.parentMenu.root.getBitsAttr("sub-content")), "dataAttr");
  const mergedProps = tag(user_derived(() => mergeProps(restProps, subContentState.props, { side: side(), onkeydown, [get(dataAttr)]: "" })), "mergedProps");
  function handleOpenAutoFocus(e) {
    onOpenAutoFocusProp()(e);
    if (e.defaultPrevented) return;
    e.preventDefault();
    if (subContentState.parentMenu.root.isUsingKeyboard && subContentState.parentMenu.contentNode) {
      MenuOpenEvent.dispatch(subContentState.parentMenu.contentNode);
    }
  }
  function handleCloseAutoFocus(e) {
    onCloseAutoFocusProp()(e);
    if (e.defaultPrevented) return;
    e.preventDefault();
  }
  function handleInteractOutside(e) {
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    subContentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    subContentState.parentMenu.onClose();
  }
  function handleOnFocusOutside(e) {
    onFocusOutside()(e);
    if (e.defaultPrevented) return;
    if (!isHTMLElement2(e.target)) return;
    if (strict_equals(e.target.id, subContentState.parentMenu.triggerNode?.id, false)) {
      subContentState.parentMenu.onClose();
    }
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Menu_sub_content, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0?.().props;
          props();
          let wrapperProps = () => $$arg0?.().wrapperProps;
          wrapperProps();
          var fragment_2 = comment();
          const finalProps = tag(user_derived(() => mergeProps(props(), get(mergedProps), { style: getFloatingContentCSSVars("menu") })), "finalProps");
          get(finalProps);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              {
                let $0 = user_derived(() => ({
                  props: get(finalProps),
                  wrapperProps: wrapperProps(),
                  ...subContentState.snippetProps
                }));
                add_svelte_meta(() => snippet(node_3, () => $$props.child, () => get($0)), "render", Menu_sub_content, 130, 4);
              }
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_49();
              attribute_effect(div, () => ({ ...wrapperProps() }));
              var div_1 = child(div);
              attribute_effect(div_1, () => ({ ...get(finalProps) }));
              var node_4 = child(div_1);
              add_svelte_meta(() => snippet(node_4, () => $$props.children ?? noop), "render", Menu_sub_content, 138, 6);
              reset(div_1);
              reset(div);
              append($$anchor4, div);
            };
            add_svelte_meta(
              () => if_block(node_2, ($$render) => {
                if ($$props.child) $$render(consequent);
                else $$render(alternate, false);
              }),
              "if",
              Menu_sub_content,
              129,
              3
            );
          }
          append($$anchor3, fragment_2);
        });
        add_svelte_meta(
          () => popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), {
            get ref() {
              return subContentState.opts.ref;
            },
            get interactOutsideBehavior() {
              return interactOutsideBehavior();
            },
            get escapeKeydownBehavior() {
              return escapeKeydownBehavior();
            },
            onOpenAutoFocus: handleOpenAutoFocus,
            get enabled() {
              return subContentState.parentMenu.opts.open.current;
            },
            onInteractOutside: handleInteractOutside,
            onEscapeKeydown: handleEscapeKeydown,
            onFocusOutside: handleOnFocusOutside,
            preventScroll: false,
            get loop() {
              return loop();
            },
            get trapFocus() {
              return trapFocus();
            },
            popper,
            $$slots: { popper: true }
          })),
          "component",
          Menu_sub_content,
          111,
          1,
          { componentTag: "PopperLayerForceMount" }
        );
      }
      append($$anchor2, fragment_1);
    };
    var alternate_2 = ($$anchor2) => {
      var fragment_4 = comment();
      var node_5 = first_child(fragment_4);
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_5 = comment();
          var node_6 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Menu_sub_content, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0?.().props;
              props();
              let wrapperProps = () => $$arg0?.().wrapperProps;
              wrapperProps();
              var fragment_6 = comment();
              const finalProps = tag(user_derived(() => mergeProps(props(), get(mergedProps), { style: getFloatingContentCSSVars("menu") })), "finalProps");
              get(finalProps);
              var node_7 = first_child(fragment_6);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_8 = first_child(fragment_7);
                  {
                    let $0 = user_derived(() => ({
                      props: get(finalProps),
                      wrapperProps: wrapperProps(),
                      ...subContentState.snippetProps
                    }));
                    add_svelte_meta(() => snippet(node_8, () => $$props.child, () => get($0)), "render", Menu_sub_content, 165, 4);
                  }
                  append($$anchor5, fragment_7);
                };
                var alternate_1 = ($$anchor5) => {
                  var div_2 = root_95();
                  attribute_effect(div_2, () => ({ ...wrapperProps() }));
                  var div_3 = child(div_2);
                  attribute_effect(div_3, () => ({ ...get(finalProps) }));
                  var node_9 = child(div_3);
                  add_svelte_meta(() => snippet(node_9, () => $$props.children ?? noop), "render", Menu_sub_content, 173, 6);
                  reset(div_3);
                  reset(div_2);
                  append($$anchor5, div_2);
                };
                add_svelte_meta(
                  () => if_block(node_7, ($$render) => {
                    if ($$props.child) $$render(consequent_2);
                    else $$render(alternate_1, false);
                  }),
                  "if",
                  Menu_sub_content,
                  164,
                  3
                );
              }
              append($$anchor4, fragment_6);
            });
            add_svelte_meta(
              () => popper_layer_default(node_6, spread_props(() => get(mergedProps), {
                get ref() {
                  return subContentState.opts.ref;
                },
                get interactOutsideBehavior() {
                  return interactOutsideBehavior();
                },
                get escapeKeydownBehavior() {
                  return escapeKeydownBehavior();
                },
                onCloseAutoFocus: handleCloseAutoFocus,
                onOpenAutoFocus: handleOpenAutoFocus,
                get open() {
                  return subContentState.parentMenu.opts.open.current;
                },
                onInteractOutside: handleInteractOutside,
                onEscapeKeydown: handleEscapeKeydown,
                onFocusOutside: handleOnFocusOutside,
                preventScroll: false,
                get loop() {
                  return loop();
                },
                get trapFocus() {
                  return trapFocus();
                },
                popper,
                $$slots: { popper: true }
              })),
              "component",
              Menu_sub_content,
              145,
              1,
              { componentTag: "PopperLayer" }
            );
          }
          append($$anchor3, fragment_5);
        };
        add_svelte_meta(
          () => if_block(
            node_5,
            ($$render) => {
              if (!forceMount()) $$render(consequent_3);
            },
            true
          ),
          "if",
          Menu_sub_content,
          144,
          0
        );
      }
      append($$anchor2, fragment_4);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (forceMount()) $$render(consequent_1);
        else $$render(alternate_2, false);
      }),
      "if",
      Menu_sub_content,
      110,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_sub_content = hmr(Menu_sub_content, () => Menu_sub_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_sub_content[HMR].source;
    set(Menu_sub_content[HMR].source, module.default[HMR].original);
  });
}
var menu_sub_content_default = Menu_sub_content;

// node_modules/bits-ui/dist/bits/menu/components/menu-sub-content-static.svelte
Menu_sub_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-sub-content-static.svelte";
var root_410 = add_locations(from_html(`<div><!></div>`), Menu_sub_content_static[FILENAME], [[131, 4]]);
var root_96 = add_locations(from_html(`<div><!></div>`), Menu_sub_content_static[FILENAME], [[161, 4]]);
function Menu_sub_content_static($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menu_sub_content_static);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "defer-otherwise-close"), escapeKeydownBehavior = prop($$props, "escapeKeydownBehavior", 3, "defer-otherwise-close"), onOpenAutoFocusProp = prop($$props, "onOpenAutoFocus", 3, noop3), onCloseAutoFocusProp = prop($$props, "onCloseAutoFocus", 3, noop3), onFocusOutside = prop($$props, "onFocusOutside", 3, noop3), trapFocus = prop($$props, "trapFocus", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child",
      "loop",
      "onInteractOutside",
      "forceMount",
      "onEscapeKeydown",
      "interactOutsideBehavior",
      "escapeKeydownBehavior",
      "onOpenAutoFocus",
      "onCloseAutoFocus",
      "onFocusOutside",
      "trapFocus"
    ],
    "restProps"
  );
  const subContentState = MenuContentState.create({
    id: box.with(() => id()),
    loop: box.with(() => loop()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onCloseAutoFocus: box.with(() => handleCloseAutoFocus),
    isSub: true
  });
  function onkeydown(e) {
    const isKeyDownInside = e.currentTarget.contains(e.target);
    const isCloseKey = SUB_CLOSE_KEYS[subContentState.parentMenu.root.opts.dir.current].includes(e.key);
    if (isKeyDownInside && isCloseKey) {
      subContentState.parentMenu.onClose();
      const triggerNode = subContentState.parentMenu.triggerNode;
      triggerNode?.focus();
      e.preventDefault();
    }
  }
  const dataAttr = tag(user_derived(() => subContentState.parentMenu.root.getBitsAttr("sub-content")), "dataAttr");
  const mergedProps = tag(user_derived(() => mergeProps(restProps, subContentState.props, { onkeydown, [get(dataAttr)]: "" })), "mergedProps");
  function handleOpenAutoFocus(e) {
    onOpenAutoFocusProp()(e);
    if (e.defaultPrevented) return;
    afterTick(() => {
      e.preventDefault();
      if (subContentState.parentMenu.root.isUsingKeyboard) {
        const subContentEl = subContentState.parentMenu.contentNode;
        subContentEl?.focus();
      }
    });
  }
  function handleCloseAutoFocus(e) {
    onCloseAutoFocusProp()(e);
    if (e.defaultPrevented) return;
    e.preventDefault();
  }
  function handleInteractOutside(e) {
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    subContentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    subContentState.parentMenu.onClose();
  }
  function handleOnFocusOutside(e) {
    onFocusOutside()(e);
    if (e.defaultPrevented) return;
    if (!isHTMLElement2(e.target)) return;
    if (strict_equals(e.target.id, subContentState.parentMenu.triggerNode?.id, false)) {
      subContentState.parentMenu.onClose();
    }
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Menu_sub_content_static, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0?.().props;
          props();
          var fragment_2 = comment();
          const finalProps = tag(user_derived(() => mergeProps(props(), get(mergedProps), { style: getFloatingContentCSSVars("menu") })), "finalProps");
          get(finalProps);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              {
                let $0 = user_derived(() => ({ props: get(finalProps), ...subContentState.snippetProps }));
                add_svelte_meta(() => snippet(node_3, () => $$props.child, () => get($0)), "render", Menu_sub_content_static, 129, 4);
              }
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_410();
              attribute_effect(div, () => ({ ...get(finalProps) }));
              var node_4 = child(div);
              add_svelte_meta(() => snippet(node_4, () => $$props.children ?? noop), "render", Menu_sub_content_static, 132, 5);
              reset(div);
              append($$anchor4, div);
            };
            add_svelte_meta(
              () => if_block(node_2, ($$render) => {
                if ($$props.child) $$render(consequent);
                else $$render(alternate, false);
              }),
              "if",
              Menu_sub_content_static,
              128,
              3
            );
          }
          append($$anchor3, fragment_2);
        });
        add_svelte_meta(
          () => popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), {
            get ref() {
              return subContentState.opts.ref;
            },
            get interactOutsideBehavior() {
              return interactOutsideBehavior();
            },
            get escapeKeydownBehavior() {
              return escapeKeydownBehavior();
            },
            onOpenAutoFocus: handleOpenAutoFocus,
            get enabled() {
              return subContentState.parentMenu.opts.open.current;
            },
            onInteractOutside: handleInteractOutside,
            onEscapeKeydown: handleEscapeKeydown,
            onFocusOutside: handleOnFocusOutside,
            preventScroll: false,
            get loop() {
              return loop();
            },
            get trapFocus() {
              return trapFocus();
            },
            isStatic: true,
            popper,
            $$slots: { popper: true }
          })),
          "component",
          Menu_sub_content_static,
          109,
          1,
          { componentTag: "PopperLayerForceMount" }
        );
      }
      append($$anchor2, fragment_1);
    };
    var alternate_2 = ($$anchor2) => {
      var fragment_4 = comment();
      var node_5 = first_child(fragment_4);
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_5 = comment();
          var node_6 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Menu_sub_content_static, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0?.().props;
              props();
              var fragment_6 = comment();
              const finalProps = tag(user_derived(() => mergeProps(props(), get(mergedProps), { style: getFloatingContentCSSVars("menu") })), "finalProps");
              get(finalProps);
              var node_7 = first_child(fragment_6);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_8 = first_child(fragment_7);
                  {
                    let $0 = user_derived(() => ({ props: get(finalProps), ...subContentState.snippetProps }));
                    add_svelte_meta(() => snippet(node_8, () => $$props.child, () => get($0)), "render", Menu_sub_content_static, 159, 4);
                  }
                  append($$anchor5, fragment_7);
                };
                var alternate_1 = ($$anchor5) => {
                  var div_1 = root_96();
                  attribute_effect(div_1, () => ({ ...get(finalProps) }));
                  var node_9 = child(div_1);
                  add_svelte_meta(() => snippet(node_9, () => $$props.children ?? noop), "render", Menu_sub_content_static, 162, 5);
                  reset(div_1);
                  append($$anchor5, div_1);
                };
                add_svelte_meta(
                  () => if_block(node_7, ($$render) => {
                    if ($$props.child) $$render(consequent_2);
                    else $$render(alternate_1, false);
                  }),
                  "if",
                  Menu_sub_content_static,
                  158,
                  3
                );
              }
              append($$anchor4, fragment_6);
            });
            add_svelte_meta(
              () => popper_layer_default(node_6, spread_props(() => get(mergedProps), {
                get ref() {
                  return subContentState.opts.ref;
                },
                get interactOutsideBehavior() {
                  return interactOutsideBehavior();
                },
                get escapeKeydownBehavior() {
                  return escapeKeydownBehavior();
                },
                onCloseAutoFocus: handleCloseAutoFocus,
                onOpenAutoFocus: handleOpenAutoFocus,
                get open() {
                  return subContentState.parentMenu.opts.open.current;
                },
                onInteractOutside: handleInteractOutside,
                onEscapeKeydown: handleEscapeKeydown,
                onFocusOutside: handleOnFocusOutside,
                preventScroll: false,
                get loop() {
                  return loop();
                },
                get trapFocus() {
                  return trapFocus();
                },
                isStatic: true,
                popper,
                $$slots: { popper: true }
              })),
              "component",
              Menu_sub_content_static,
              138,
              1,
              { componentTag: "PopperLayer" }
            );
          }
          append($$anchor3, fragment_5);
        };
        add_svelte_meta(
          () => if_block(
            node_5,
            ($$render) => {
              if (!forceMount()) $$render(consequent_3);
            },
            true
          ),
          "if",
          Menu_sub_content_static,
          137,
          0
        );
      }
      append($$anchor2, fragment_4);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (forceMount()) $$render(consequent_1);
        else $$render(alternate_2, false);
      }),
      "if",
      Menu_sub_content_static,
      108,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_sub_content_static = hmr(Menu_sub_content_static, () => Menu_sub_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_sub_content_static[HMR].source;
    set(Menu_sub_content_static[HMR].source, module.default[HMR].original);
  });
}
var menu_sub_content_static_default = Menu_sub_content_static;

// node_modules/bits-ui/dist/bits/menu/components/menu-sub-trigger.svelte
Menu_sub_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-sub-trigger.svelte";
var root_312 = add_locations(from_html(`<div><!></div>`), Menu_sub_trigger[FILENAME], [[38, 2]]);
function Menu_sub_trigger($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menu_sub_trigger);
  let id = prop($$props, "id", 19, () => createId(uid)), disabled = prop($$props, "disabled", 3, false), ref = prop($$props, "ref", 15, null), onSelect = prop($$props, "onSelect", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "disabled",
      "ref",
      "children",
      "child",
      "onSelect"
    ],
    "restProps"
  );
  const subTriggerState = MenuSubTriggerState.create({
    disabled: box.with(() => disabled()),
    onSelect: box.with(() => onSelect()),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, subTriggerState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => floating_layer_anchor_default(node, {
      get id() {
        return id();
      },
      get ref() {
        return subTriggerState.opts.ref;
      },
      children: wrap_snippet(Menu_sub_trigger, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        {
          var consequent = ($$anchor3) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            add_svelte_meta(() => snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Menu_sub_trigger, 36, 2);
            append($$anchor3, fragment_2);
          };
          var alternate = ($$anchor3) => {
            var div = root_312();
            attribute_effect(div, () => ({ ...get(mergedProps) }));
            var node_3 = child(div);
            add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop), "render", Menu_sub_trigger, 39, 3);
            reset(div);
            append($$anchor3, div);
          };
          add_svelte_meta(
            () => if_block(node_1, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            }),
            "if",
            Menu_sub_trigger,
            35,
            1
          );
        }
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }),
    "component",
    Menu_sub_trigger,
    34,
    0,
    { componentTag: "FloatingLayerAnchor" }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_sub_trigger = hmr(Menu_sub_trigger, () => Menu_sub_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_sub_trigger[HMR].source;
    set(Menu_sub_trigger[HMR].source, module.default[HMR].original);
  });
}
var menu_sub_trigger_default = Menu_sub_trigger;

// node_modules/bits-ui/dist/bits/menu/components/menu-checkbox-item.svelte
Menu_checkbox_item[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-checkbox-item.svelte";
var root_253 = add_locations(from_html(`<div><!></div>`), Menu_checkbox_item[FILENAME], [[91, 1]]);
function Menu_checkbox_item($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menu_checkbox_item);
  let ref = prop($$props, "ref", 15, null), checked = prop($$props, "checked", 15, false), id = prop($$props, "id", 19, () => createId(uid)), onCheckedChange = prop($$props, "onCheckedChange", 3, noop3), disabled = prop($$props, "disabled", 3, false), onSelect = prop($$props, "onSelect", 3, noop3), closeOnSelect = prop($$props, "closeOnSelect", 3, true), indeterminate = prop($$props, "indeterminate", 15, false), onIndeterminateChange = prop($$props, "onIndeterminateChange", 3, noop3), value = prop($$props, "value", 3, ""), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "ref",
      "checked",
      "id",
      "onCheckedChange",
      "disabled",
      "onSelect",
      "closeOnSelect",
      "indeterminate",
      "onIndeterminateChange",
      "value"
    ],
    "restProps"
  );
  const group = MenuCheckboxGroupContext.getOr(null);
  if (group && value()) {
    if (group.opts.value.current.includes(value())) {
      checked(true);
    } else {
      checked(false);
    }
  }
  watch.pre(() => value(), () => {
    if (group && value()) {
      if (group.opts.value.current.includes(value())) {
        checked(true);
      } else {
        checked(false);
      }
    }
  });
  const checkboxItemState = MenuCheckboxItemState.create(
    {
      checked: box.with(() => checked(), (v) => {
        checked(v);
        onCheckedChange()(v);
      }),
      id: box.with(() => id()),
      disabled: box.with(() => disabled()),
      onSelect: box.with(() => handleSelect),
      ref: box.with(() => ref(), (v) => ref(v)),
      closeOnSelect: box.with(() => closeOnSelect()),
      indeterminate: box.with(() => indeterminate(), (v) => {
        indeterminate(v);
        onIndeterminateChange()(v);
      }),
      value: box.with(() => value())
    },
    group
  );
  function handleSelect(e) {
    onSelect()(e);
    if (e.defaultPrevented) return;
    checkboxItemState.toggleChecked();
  }
  const mergedProps = tag(user_derived(() => mergeProps(restProps, checkboxItemState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => snippet(node_1, () => $$props.child, () => ({
          checked: checked(),
          indeterminate: indeterminate(),
          props: get(mergedProps)
        })),
        "render",
        Menu_checkbox_item,
        89,
        1
      );
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_253();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => ({ checked: checked(), indeterminate: indeterminate() })), "render", Menu_checkbox_item, 92, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Menu_checkbox_item,
      88,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_checkbox_item = hmr(Menu_checkbox_item, () => Menu_checkbox_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_checkbox_item[HMR].source;
    set(Menu_checkbox_item[HMR].source, module.default[HMR].original);
  });
}
var menu_checkbox_item_default = Menu_checkbox_item;

// node_modules/bits-ui/dist/bits/menu/components/menu-checkbox-group.svelte
Menu_checkbox_group[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-checkbox-group.svelte";
var root_254 = add_locations(from_html(`<div><!></div>`), Menu_checkbox_group[FILENAME], [[42, 1]]);
function Menu_checkbox_group($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menu_checkbox_group);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 31, () => tag_proxy(proxy([]), "value")), onValueChange = prop($$props, "onValueChange", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "children",
      "child",
      "ref",
      "value",
      "onValueChange"
    ],
    "restProps"
  );
  const checkboxGroupState = MenuCheckboxGroupState.create({
    value: box.with(() => snapshot(value()), (v) => {
      value(snapshot(v));
      onValueChange()(v);
    }),
    onValueChange: box.with(() => onValueChange()),
    ref: box.with(() => ref(), (v) => ref(v)),
    id: box.with(() => id())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, checkboxGroupState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Menu_checkbox_group, 40, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_254();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Menu_checkbox_group, 43, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Menu_checkbox_group,
      39,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_checkbox_group = hmr(Menu_checkbox_group, () => Menu_checkbox_group[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_checkbox_group[HMR].source;
    set(Menu_checkbox_group[HMR].source, module.default[HMR].original);
  });
}
var menu_checkbox_group_default = Menu_checkbox_group;

// node_modules/bits-ui/dist/bits/date-field/exports.js
var exports_exports12 = {};
__export(exports_exports12, {
  Input: () => date_field_input_default,
  Label: () => date_field_label_default,
  Root: () => date_field_default,
  Segment: () => date_field_segment_default
});

// node_modules/bits-ui/dist/bits/date-field/date-field.svelte.js
var dateFieldAttrs = createBitsAttrs({
  component: "date-field",
  parts: ["input", "label", "segment"]
});
var SEGMENT_CONFIGS = {
  day: {
    min: 1,
    max: (root18) => {
      const segmentMonthValue = root18.segmentValues.month;
      const placeholder = root18.value.current ?? root18.placeholder.current;
      return segmentMonthValue ? getDaysInMonth(placeholder.set({ month: Number.parseInt(segmentMonthValue) })) : getDaysInMonth(placeholder);
    },
    cycle: 1,
    padZero: true
  },
  month: {
    min: 1,
    max: 12,
    cycle: 1,
    padZero: true,
    getAnnouncement: (month, root18) => `${month} - ${root18.formatter.fullMonth(toDate(root18.placeholder.current.set({ month })))}`
  },
  year: { min: 1, max: 9999, cycle: 1, padZero: false },
  hour: {
    min: (root18) => strict_equals(root18.hourCycle.current, 12) ? 1 : 0,
    max: (root18) => {
      if (strict_equals(root18.hourCycle.current, 24)) return 23;
      if ("dayPeriod" in root18.segmentValues && strict_equals(root18.segmentValues.dayPeriod, null, false)) return 12;
      return 23;
    },
    cycle: 1,
    canBeZero: true,
    padZero: true
  },
  minute: { min: 0, max: 59, cycle: 1, canBeZero: true, padZero: true },
  second: { min: 0, max: 59, cycle: 1, canBeZero: true, padZero: true }
};
var DateFieldRootContext = new Context("DateField.Root");
var DateFieldRootState = class _DateFieldRootState {
  static create(opts, rangeRoot) {
    return DateFieldRootContext.set(new _DateFieldRootState(opts, rangeRoot));
  }
  value;
  placeholder;
  validate;
  minValue;
  maxValue;
  disabled;
  readonly;
  granularity;
  readonlySegments;
  hourCycle;
  locale;
  hideTimeZone;
  required;
  onInvalid;
  errorMessageId;
  isInvalidProp;
  descriptionId = useId();
  formatter;
  initialSegments;
  #segmentValues = tag(state(), "DateFieldRootState.segmentValues");
  get segmentValues() {
    return get(this.#segmentValues);
  }
  set segmentValues(value) {
    set(this.#segmentValues, value, true);
  }
  announcer;
  #readonlySegmentsSet = tag(user_derived(() => new Set(this.readonlySegments.current)), "DateFieldRootState.readonlySegmentsSet");
  get readonlySegmentsSet() {
    return get(this.#readonlySegmentsSet);
  }
  set readonlySegmentsSet(value) {
    set(this.#readonlySegmentsSet, value);
  }
  segmentStates = initSegmentStates();
  #fieldNode = tag(state(null), "DateFieldRootState.#fieldNode");
  #labelNode = tag(state(null), "DateFieldRootState.#labelNode");
  #descriptionNode = tag(state(null), "DateFieldRootState.descriptionNode");
  get descriptionNode() {
    return get(this.#descriptionNode);
  }
  set descriptionNode(value) {
    set(this.#descriptionNode, value, true);
  }
  #validationNode = tag(state(null), "DateFieldRootState.validationNode");
  get validationNode() {
    return get(this.#validationNode);
  }
  set validationNode(value) {
    set(this.#validationNode, value, true);
  }
  states = initSegmentStates();
  #dayPeriodNode = tag(state(null), "DateFieldRootState.dayPeriodNode");
  get dayPeriodNode() {
    return get(this.#dayPeriodNode);
  }
  set dayPeriodNode(value) {
    set(this.#dayPeriodNode, value, true);
  }
  rangeRoot = void 0;
  #name = tag(state(""), "DateFieldRootState.name");
  get name() {
    return get(this.#name);
  }
  set name(value) {
    set(this.#name, value, true);
  }
  domContext = new DOMContext(() => null);
  constructor(props, rangeRoot) {
    this.rangeRoot = rangeRoot;
    this.value = props.value;
    this.placeholder = rangeRoot ? rangeRoot.opts.placeholder : props.placeholder;
    this.validate = rangeRoot ? box(void 0) : props.validate;
    this.minValue = rangeRoot ? rangeRoot.opts.minValue : props.minValue;
    this.maxValue = rangeRoot ? rangeRoot.opts.maxValue : props.maxValue;
    this.disabled = rangeRoot ? rangeRoot.opts.disabled : props.disabled;
    this.readonly = rangeRoot ? rangeRoot.opts.readonly : props.readonly;
    this.granularity = rangeRoot ? rangeRoot.opts.granularity : props.granularity;
    this.readonlySegments = rangeRoot ? rangeRoot.opts.readonlySegments : props.readonlySegments;
    this.hourCycle = rangeRoot ? rangeRoot.opts.hourCycle : props.hourCycle;
    this.locale = rangeRoot ? rangeRoot.opts.locale : props.locale;
    this.hideTimeZone = rangeRoot ? rangeRoot.opts.hideTimeZone : props.hideTimeZone;
    this.required = rangeRoot ? rangeRoot.opts.required : props.required;
    this.onInvalid = rangeRoot ? rangeRoot.opts.onInvalid : props.onInvalid;
    this.errorMessageId = rangeRoot ? rangeRoot.opts.errorMessageId : props.errorMessageId;
    this.isInvalidProp = props.isInvalidProp;
    this.formatter = createFormatter({
      initialLocale: this.locale.current,
      monthFormat: box.with(() => "long"),
      yearFormat: box.with(() => "numeric")
    });
    this.initialSegments = initializeSegmentValues(this.inferredGranularity);
    this.segmentValues = this.initialSegments;
    this.announcer = getAnnouncer(null);
    this.getFieldNode = this.getFieldNode.bind(this);
    this.updateSegment = this.updateSegment.bind(this);
    this.handleSegmentClick = this.handleSegmentClick.bind(this);
    this.getBaseSegmentAttrs = this.getBaseSegmentAttrs.bind(this);
    user_effect(() => {
      untrack(() => {
        this.initialSegments = initializeSegmentValues(this.inferredGranularity);
      });
    });
    onMount(() => {
      this.announcer = getAnnouncer(this.domContext.getDocument());
    });
    onDestroyEffect(() => {
      if (rangeRoot) return;
      removeDescriptionElement(this.descriptionId, this.domContext.getDocument());
    });
    user_effect(() => {
      if (rangeRoot) return;
      if (strict_equals(this.formatter.getLocale(), this.locale.current)) return;
      this.formatter.setLocale(this.locale.current);
    });
    user_effect(() => {
      if (rangeRoot) return;
      if (this.value.current) {
        const descriptionId = untrack(() => this.descriptionId);
        setDescription({
          id: descriptionId,
          formatter: this.formatter,
          value: this.value.current,
          doc: this.domContext.getDocument()
        });
      }
      const placeholder = untrack(() => this.placeholder.current);
      if (this.value.current && strict_equals(placeholder, this.value.current, false)) {
        untrack(() => {
          if (this.value.current) {
            this.placeholder.current = this.value.current;
          }
        });
      }
    });
    if (this.value.current) {
      this.syncSegmentValues(this.value.current);
    }
    user_effect(() => {
      this.locale.current;
      if (this.value.current) {
        this.syncSegmentValues(this.value.current);
      }
      this.#clearUpdating();
    });
    user_effect(() => {
      if (strict_equals(this.value.current, void 0)) {
        this.segmentValues = initializeSegmentValues(this.inferredGranularity);
      }
    });
    watch(() => this.validationStatus, () => {
      if (strict_equals(this.validationStatus, false, false)) {
        this.onInvalid.current?.(this.validationStatus.reason, this.validationStatus.message);
      }
    });
  }
  setName(name) {
    this.name = name;
  }
  /**
   * Sets the field node for the `DateFieldRootState` instance. We use this method so we can
   * keep `#fieldNode` private to prevent accidental usage of the incorrect field node.
   */
  setFieldNode(node) {
    set(this.#fieldNode, node, true);
  }
  /**
   * Gets the correct field node for the date field regardless of whether it's being
   * used in a standalone context or within a `DateRangeField` component.
   */
  getFieldNode() {
    if (!this.rangeRoot) {
      return get(this.#fieldNode);
    } else {
      return this.rangeRoot.fieldNode;
    }
  }
  /**
   * Sets the label node for the `DateFieldRootState` instance. We use this method so we can
   * keep `#labelNode` private to prevent accidental usage of the incorrect label node.
   */
  setLabelNode(node) {
    set(this.#labelNode, node, true);
  }
  /**
   * Gets the correct label node for the date field regardless of whether it's being used in
   * a standalone context or within a `DateRangeField` component.
   */
  getLabelNode() {
    if (!this.rangeRoot) {
      return get(this.#labelNode);
    }
    return this.rangeRoot.labelNode;
  }
  #clearUpdating() {
    this.states.day.updating = null;
    this.states.month.updating = null;
    this.states.year.updating = null;
    this.states.hour.updating = null;
    this.states.minute.updating = null;
    this.states.dayPeriod.updating = null;
  }
  setValue(value) {
    this.value.current = value;
  }
  syncSegmentValues(value) {
    const dateValues = DATE_SEGMENT_PARTS.map((part) => {
      const partValue = value[part];
      if (strict_equals(part, "month")) {
        if (this.states.month.updating) {
          return [part, this.states.month.updating];
        }
        if (partValue < 10) {
          return [part, `0${partValue}`];
        }
      }
      if (strict_equals(part, "day")) {
        if (this.states.day.updating) {
          return [part, this.states.day.updating];
        }
        if (partValue < 10) {
          return [part, `0${partValue}`];
        }
      }
      if (strict_equals(part, "year")) {
        if (this.states.year.updating) {
          return [part, this.states.year.updating];
        }
        const valueDigits = `${partValue}`.length;
        const diff = 4 - valueDigits;
        if (diff > 0) {
          return [part, `${"0".repeat(diff)}${partValue}`];
        }
      }
      return [part, `${partValue}`];
    });
    if ("hour" in value) {
      const timeValues = EDITABLE_TIME_SEGMENT_PARTS.map((part) => {
        if (strict_equals(part, "dayPeriod")) {
          if (this.states.dayPeriod.updating) {
            return [part, this.states.dayPeriod.updating];
          } else {
            return [part, this.formatter.dayPeriod(toDate(value))];
          }
        } else if (strict_equals(part, "hour")) {
          if (this.states.hour.updating) {
            return [part, this.states.hour.updating];
          }
          if (strict_equals(value[part], void 0, false) && value[part] < 10) {
            return [part, `0${value[part]}`];
          }
          if (strict_equals(value[part], 0)) {
            if (this.dayPeriodNode) {
              return [part, "12"];
            }
          }
        } else if (strict_equals(part, "minute")) {
          if (this.states.minute.updating) {
            return [part, this.states.minute.updating];
          }
          if (strict_equals(value[part], void 0, false) && value[part] < 10) {
            return [part, `0${value[part]}`];
          }
        } else if (strict_equals(part, "second")) {
          if (this.states.second.updating) {
            return [part, this.states.second.updating];
          }
          if (strict_equals(value[part], void 0, false) && value[part] < 10) {
            return [part, `0${value[part]}`];
          }
        }
        return [part, `${value[part]}`];
      });
      const mergedSegmentValues = [...dateValues, ...timeValues];
      this.segmentValues = Object.fromEntries(mergedSegmentValues);
      this.#clearUpdating();
      return;
    }
    this.segmentValues = Object.fromEntries(dateValues);
  }
  #validationStatus = tag(
    user_derived(() => {
      const value = this.value.current;
      if (!value) return false;
      const msg = this.validate.current?.(value);
      if (msg) {
        return { reason: "custom", message: msg };
      }
      const minValue = this.minValue.current;
      if (minValue && isBefore(value, minValue)) {
        return { reason: "min" };
      }
      const maxValue = this.maxValue.current;
      if (maxValue && isBefore(maxValue, value)) {
        return { reason: "max" };
      }
      return false;
    }),
    "DateFieldRootState.validationStatus"
  );
  get validationStatus() {
    return get(this.#validationStatus);
  }
  set validationStatus(value) {
    set(this.#validationStatus, value);
  }
  #isInvalid = tag(
    user_derived(() => {
      if (strict_equals(this.validationStatus, false)) return false;
      if (this.isInvalidProp.current) return true;
      return true;
    }),
    "DateFieldRootState.isInvalid"
  );
  get isInvalid() {
    return get(this.#isInvalid);
  }
  set isInvalid(value) {
    set(this.#isInvalid, value);
  }
  #inferredGranularity = tag(
    user_derived(() => {
      const granularity = this.granularity.current;
      if (granularity) return granularity;
      const inferred = inferGranularity(this.placeholder.current, this.granularity.current);
      return inferred;
    }),
    "DateFieldRootState.inferredGranularity"
  );
  get inferredGranularity() {
    return get(this.#inferredGranularity);
  }
  set inferredGranularity(value) {
    set(this.#inferredGranularity, value);
  }
  #dateRef = tag(user_derived(() => this.value.current ?? this.placeholder.current), "DateFieldRootState.dateRef");
  get dateRef() {
    return get(this.#dateRef);
  }
  set dateRef(value) {
    set(this.#dateRef, value);
  }
  #allSegmentContent = tag(
    user_derived(() => createContent({
      segmentValues: this.segmentValues,
      formatter: this.formatter,
      locale: this.locale.current,
      granularity: this.inferredGranularity,
      dateRef: this.dateRef,
      hideTimeZone: this.hideTimeZone.current,
      hourCycle: this.hourCycle.current
    })),
    "DateFieldRootState.allSegmentContent"
  );
  get allSegmentContent() {
    return get(this.#allSegmentContent);
  }
  set allSegmentContent(value) {
    set(this.#allSegmentContent, value);
  }
  #segmentContents = tag(user_derived(() => this.allSegmentContent.arr), "DateFieldRootState.segmentContents");
  get segmentContents() {
    return get(this.#segmentContents);
  }
  set segmentContents(value) {
    set(this.#segmentContents, value);
  }
  sharedSegmentAttrs = {
    role: "spinbutton",
    contenteditable: "true",
    tabindex: 0,
    spellcheck: false,
    inputmode: "numeric",
    autocorrect: "off",
    enterkeyhint: "next",
    style: { caretColor: "transparent" }
  };
  #getLabelledBy(segmentId) {
    return `${segmentId} ${this.getLabelNode()?.id ?? ""}`;
  }
  updateSegment(part, cb) {
    const disabled = this.disabled.current;
    const readonly = this.readonly.current;
    const readonlySegmentsSet = this.readonlySegmentsSet;
    if (disabled || readonly || readonlySegmentsSet.has(part)) return;
    const prev2 = this.segmentValues;
    let newSegmentValues = prev2;
    const dateRef = this.placeholder.current;
    if (isDateAndTimeSegmentObj(prev2)) {
      const pVal = prev2[part];
      const castCb = cb;
      if (strict_equals(part, "month")) {
        const next3 = castCb(pVal);
        this.states.month.updating = next3;
        if (strict_equals(next3, null, false) && strict_equals(prev2.day, null, false)) {
          const date = dateRef.set({ month: Number.parseInt(next3) });
          const daysInMonth = getDaysInMonth(toDate(date));
          const prevDay = Number.parseInt(prev2.day);
          if (prevDay > daysInMonth) {
            prev2.day = `${daysInMonth}`;
          }
        }
        newSegmentValues = { ...prev2, [part]: next3 };
      } else if (strict_equals(part, "dayPeriod")) {
        const next3 = castCb(pVal);
        this.states.dayPeriod.updating = next3;
        const date = this.value.current;
        if (date && "hour" in date) {
          const trueHour = date.hour;
          if (strict_equals(next3, "AM")) {
            if (trueHour >= 12) {
              prev2.hour = `${trueHour - 12}`;
            }
          } else if (strict_equals(next3, "PM")) {
            if (trueHour < 12) {
              prev2.hour = `${trueHour + 12}`;
            }
          }
        }
        newSegmentValues = { ...prev2, [part]: next3 };
      } else if (strict_equals(part, "hour")) {
        const next3 = castCb(pVal);
        this.states.hour.updating = next3;
        if (strict_equals(next3, null, false) && strict_equals(prev2.dayPeriod, null, false)) {
          const dayPeriod = this.formatter.dayPeriod(toDate(dateRef.set({ hour: Number.parseInt(next3) })), this.hourCycle.current);
          if (strict_equals(dayPeriod, "AM") || strict_equals(dayPeriod, "PM")) {
            prev2.dayPeriod = dayPeriod;
          }
        }
        newSegmentValues = { ...prev2, [part]: next3 };
      } else if (strict_equals(part, "minute")) {
        const next3 = castCb(pVal);
        this.states.minute.updating = next3;
        newSegmentValues = { ...prev2, [part]: next3 };
      } else if (strict_equals(part, "second")) {
        const next3 = castCb(pVal);
        this.states.second.updating = next3;
        newSegmentValues = { ...prev2, [part]: next3 };
      } else if (strict_equals(part, "year")) {
        const next3 = castCb(pVal);
        this.states.year.updating = next3;
        newSegmentValues = { ...prev2, [part]: next3 };
      } else if (strict_equals(part, "day")) {
        const next3 = castCb(pVal);
        this.states.day.updating = next3;
        newSegmentValues = { ...prev2, [part]: next3 };
      } else {
        const next3 = castCb(pVal);
        newSegmentValues = { ...prev2, [part]: next3 };
      }
    } else if (isDateSegmentPart(part)) {
      const pVal = prev2[part];
      const castCb = cb;
      const next3 = castCb(pVal);
      if (strict_equals(part, "month") && strict_equals(next3, null, false) && strict_equals(prev2.day, null, false)) {
        this.states.month.updating = next3;
        const date = dateRef.set({ month: Number.parseInt(next3) });
        const daysInMonth = getDaysInMonth(toDate(date));
        if (Number.parseInt(prev2.day) > daysInMonth) {
          prev2.day = `${daysInMonth}`;
        }
        newSegmentValues = { ...prev2, [part]: next3 };
      } else if (strict_equals(part, "year")) {
        const next4 = castCb(pVal);
        this.states.year.updating = next4;
        newSegmentValues = { ...prev2, [part]: next4 };
      } else if (strict_equals(part, "day")) {
        const next4 = castCb(pVal);
        this.states.day.updating = next4;
        newSegmentValues = { ...prev2, [part]: next4 };
      } else {
        newSegmentValues = { ...prev2, [part]: next3 };
      }
    }
    this.segmentValues = newSegmentValues;
    if (areAllSegmentsFilled(newSegmentValues, get(this.#fieldNode))) {
      this.setValue(getValueFromSegments({
        segmentObj: newSegmentValues,
        fieldNode: get(this.#fieldNode),
        dateRef: this.placeholder.current
      }));
    } else {
      this.setValue(void 0);
      this.segmentValues = newSegmentValues;
    }
  }
  handleSegmentClick(e) {
    if (this.disabled.current) {
      e.preventDefault();
    }
  }
  getBaseSegmentAttrs(part, segmentId) {
    const inReadonlySegments = this.readonlySegmentsSet.has(part);
    const defaultAttrs = {
      "aria-invalid": getAriaInvalid(this.isInvalid),
      "aria-disabled": getAriaDisabled(this.disabled.current),
      "aria-readonly": getAriaReadonly(this.readonly.current || inReadonlySegments),
      "data-invalid": getDataInvalid(this.isInvalid),
      "data-disabled": getDataDisabled(this.disabled.current),
      "data-readonly": getDataReadonly(this.readonly.current || inReadonlySegments),
      "data-segment": `${part}`,
      [dateFieldAttrs.segment]: ""
    };
    if (strict_equals(part, "literal")) return defaultAttrs;
    const descriptionId = this.descriptionNode?.id;
    const hasDescription = isFirstSegment(segmentId, get(this.#fieldNode)) && descriptionId;
    const errorMsgId = this.errorMessageId?.current;
    const describedBy = hasDescription ? `${descriptionId} ${this.isInvalid && errorMsgId ? errorMsgId : ""}` : void 0;
    const contenteditable = !(this.readonly.current || inReadonlySegments || this.disabled.current);
    return {
      ...defaultAttrs,
      "aria-labelledby": this.#getLabelledBy(segmentId),
      contenteditable: contenteditable ? "true" : void 0,
      "aria-describedby": describedBy,
      tabindex: this.disabled.current ? void 0 : 0
    };
  }
};
var DateFieldInputState = class _DateFieldInputState {
  static create(opts) {
    return new _DateFieldInputState(opts, DateFieldRootContext.get());
  }
  opts;
  root;
  domContext;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.domContext = new DOMContext(opts.ref);
    this.root.domContext = this.domContext;
    this.attachment = attachRef(opts.ref, (v) => this.root.setFieldNode(v));
    watch(() => this.opts.name.current, (v) => {
      this.root.setName(v);
    });
  }
  #ariaDescribedBy = tag(
    user_derived(() => {
      if (!isBrowser) return void 0;
      const doesDescriptionExist = this.domContext.getElementById(this.root.descriptionId);
      if (!doesDescriptionExist) return void 0;
      return this.root.descriptionId;
    }),
    "DateFieldInputState.#ariaDescribedBy"
  );
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "group",
      "aria-labelledby": this.root.getLabelNode()?.id ?? void 0,
      "aria-describedby": get(this.#ariaDescribedBy),
      "aria-disabled": getAriaDisabled(this.root.disabled.current),
      "data-invalid": this.root.isInvalid ? "" : void 0,
      "data-disabled": getDataDisabled(this.root.disabled.current),
      [dateFieldAttrs.input]: "",
      ...this.attachment
    })),
    "DateFieldInputState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var DateFieldHiddenInputState = class _DateFieldHiddenInputState {
  static create() {
    return new _DateFieldHiddenInputState(DateFieldRootContext.get());
  }
  root;
  #shouldRender = tag(user_derived(() => strict_equals(this.root.name, "", false)), "DateFieldHiddenInputState.shouldRender");
  get shouldRender() {
    return get(this.#shouldRender);
  }
  set shouldRender(value) {
    set(this.#shouldRender, value);
  }
  #isoValue = tag(user_derived(() => this.root.value.current ? this.root.value.current.toString() : ""), "DateFieldHiddenInputState.isoValue");
  get isoValue() {
    return get(this.#isoValue);
  }
  set isoValue(value) {
    set(this.#isoValue, value);
  }
  constructor(root18) {
    this.root = root18;
  }
  #props = tag(
    user_derived(() => {
      return {
        name: this.root.name,
        value: this.isoValue,
        required: this.root.required.current
      };
    }),
    "DateFieldHiddenInputState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var DateFieldLabelState = class _DateFieldLabelState {
  static create(opts) {
    return new _DateFieldLabelState(opts, DateFieldRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.onclick = this.onclick.bind(this);
    this.attachment = attachRef(opts.ref, (v) => this.root.setLabelNode(v));
  }
  onclick(_) {
    if (this.root.disabled.current) return;
    const firstSegment = getFirstSegment(this.root.getFieldNode());
    if (!firstSegment) return;
    firstSegment.focus();
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "data-invalid": getDataInvalid(this.root.isInvalid),
      "data-disabled": getDataDisabled(this.root.disabled.current),
      [dateFieldAttrs.label]: "",
      onclick: this.onclick,
      ...this.attachment
    })),
    "DateFieldLabelState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var BaseNumericSegmentState = class {
  opts;
  root;
  announcer;
  part;
  config;
  attachment;
  constructor(opts, root18, part, config) {
    this.opts = opts;
    this.root = root18;
    this.part = part;
    this.config = config;
    this.announcer = root18.announcer;
    this.onkeydown = this.onkeydown.bind(this);
    this.onfocusout = this.onfocusout.bind(this);
    this.attachment = attachRef(opts.ref);
  }
  #getMax() {
    return strict_equals(typeof this.config.max, "function") ? this.config.max(this.root) : this.config.max;
  }
  #getMin() {
    return strict_equals(typeof this.config.min, "function") ? this.config.min(this.root) : this.config.min;
  }
  #getAnnouncement(value) {
    if (this.config.getAnnouncement) {
      return this.config.getAnnouncement(value, this.root);
    }
    return value;
  }
  #formatValue(value, forDisplay = true) {
    const str = String(value);
    if (forDisplay && this.config.padZero && strict_equals(str.length, 1)) {
      return `0${value}`;
    }
    return str;
  }
  onkeydown(e) {
    const placeholder = this.root.value.current ?? this.root.placeholder.current;
    if (e.ctrlKey || e.metaKey || this.root.disabled.current) return;
    if ((strict_equals(this.part, "hour") || strict_equals(this.part, "minute") || strict_equals(this.part, "second")) && !(this.part in placeholder)) return;
    if (strict_equals(e.key, kbd_constants_exports.TAB, false)) e.preventDefault();
    if (!isAcceptableSegmentKey(e.key)) return;
    if (isArrowUp(e.key)) {
      this.#handleArrowUp(placeholder);
      return;
    }
    if (isArrowDown(e.key)) {
      this.#handleArrowDown(placeholder);
      return;
    }
    if (isNumberString(e.key)) {
      this.#handleNumberKey(e);
      return;
    }
    if (isBackspace(e.key)) {
      this.#handleBackspace(e);
      return;
    }
    if (isSegmentNavigationKey(e.key)) {
      handleSegmentNavigation(e, this.root.getFieldNode());
    }
  }
  #handleArrowUp(placeholder) {
    const stateKey = this.part;
    if (stateKey in this.root.states) {
      this.root.states[stateKey].hasLeftFocus = false;
    }
    this.root.updateSegment(this.part, (prev2) => {
      if (strict_equals(prev2, null)) {
        const next4 = placeholder[this.part];
        this.announcer.announce(this.#getAnnouncement(next4));
        return this.#formatValue(next4);
      }
      const current = placeholder.set({ [this.part]: Number.parseInt(prev2) });
      const next3 = current.cycle(this.part, this.config.cycle)[this.part];
      this.announcer.announce(this.#getAnnouncement(next3));
      return this.#formatValue(next3);
    });
  }
  #handleArrowDown(placeholder) {
    const stateKey = this.part;
    if (stateKey in this.root.states) {
      this.root.states[stateKey].hasLeftFocus = false;
    }
    this.root.updateSegment(this.part, (prev2) => {
      if (strict_equals(prev2, null)) {
        const next4 = placeholder[this.part];
        this.announcer.announce(this.#getAnnouncement(next4));
        return this.#formatValue(next4);
      }
      const current = placeholder.set({ [this.part]: Number.parseInt(prev2) });
      const next3 = current.cycle(this.part, -this.config.cycle)[this.part];
      this.announcer.announce(this.#getAnnouncement(next3));
      return this.#formatValue(next3);
    });
  }
  #handleNumberKey(e) {
    const num = Number.parseInt(e.key);
    let moveToNext = false;
    const max = this.#getMax();
    const maxStart = Math.floor(max / 10);
    const numIsZero = strict_equals(num, 0);
    const stateKey = this.part;
    this.root.updateSegment(this.part, (prev2) => {
      if (stateKey in this.root.states && this.root.states[stateKey].hasLeftFocus) {
        prev2 = null;
        this.root.states[stateKey].hasLeftFocus = false;
      }
      if (strict_equals(prev2, null)) {
        if (numIsZero) {
          if (stateKey in this.root.states) {
            this.root.states[stateKey].lastKeyZero = true;
          }
          this.announcer.announce("0");
          return "0";
        }
        if (stateKey in this.root.states && (this.root.states[stateKey].lastKeyZero || num > maxStart)) {
          moveToNext = true;
        }
        if (stateKey in this.root.states) {
          this.root.states[stateKey].lastKeyZero = false;
        }
        if (moveToNext && strict_equals(String(num).length, 1)) {
          this.announcer.announce(num);
          return `0${num}`;
        }
        return `${num}`;
      }
      if (stateKey in this.root.states && this.root.states[stateKey].lastKeyZero) {
        if (strict_equals(num, 0, false)) {
          moveToNext = true;
          this.root.states[stateKey].lastKeyZero = false;
          return `0${num}`;
        }
        if (strict_equals(this.part, "hour") && strict_equals(num, 0) && strict_equals(this.root.hourCycle.current, 24)) {
          moveToNext = true;
          this.root.states[stateKey].lastKeyZero = false;
          return `00`;
        }
        if ((strict_equals(this.part, "minute") || strict_equals(this.part, "second")) && strict_equals(num, 0)) {
          moveToNext = true;
          this.root.states[stateKey].lastKeyZero = false;
          return "00";
        }
        return prev2;
      }
      const total = Number.parseInt(prev2 + num.toString());
      if (total > max) {
        moveToNext = true;
        return `0${num}`;
      }
      moveToNext = true;
      return `${total}`;
    });
    if (moveToNext) {
      moveToNextSegment(e, this.root.getFieldNode());
    }
  }
  #handleBackspace(e) {
    const stateKey = this.part;
    if (stateKey in this.root.states) {
      this.root.states[stateKey].hasLeftFocus = false;
    }
    let moveToPrev = false;
    this.root.updateSegment(this.part, (prev2) => {
      if (strict_equals(prev2, null)) {
        moveToPrev = true;
        this.announcer.announce(null);
        return null;
      }
      if (strict_equals(prev2.length, 2) && prev2.startsWith("0")) {
        this.announcer.announce(null);
        return null;
      }
      const str = prev2.toString();
      if (strict_equals(str.length, 1)) {
        this.announcer.announce(null);
        return null;
      }
      const next3 = Number.parseInt(str.slice(0, -1));
      this.announcer.announce(this.#getAnnouncement(next3));
      return `${next3}`;
    });
    if (moveToPrev) {
      moveToPrevSegment(e, this.root.getFieldNode());
    }
  }
  onfocusout(_) {
    const stateKey = this.part;
    if (stateKey in this.root.states) {
      this.root.states[stateKey].hasLeftFocus = true;
    }
    if (this.config.padZero) {
      this.root.updateSegment(this.part, (prev2) => {
        if (prev2 && strict_equals(prev2.length, 1)) {
          return `0${prev2}`;
        }
        return prev2;
      });
    }
  }
  getSegmentProps() {
    const segmentValues = this.root.segmentValues;
    const placeholder = this.root.placeholder.current;
    const isEmpty = strict_equals(segmentValues[this.part], null);
    let date = placeholder;
    if (segmentValues[this.part]) {
      date = placeholder.set({ [this.part]: Number.parseInt(segmentValues[this.part]) });
    }
    const valueNow = date[this.part];
    const valueMin = this.#getMin();
    const valueMax = this.#getMax();
    let valueText = isEmpty ? "Empty" : `${valueNow}`;
    if (strict_equals(this.part, "hour") && "dayPeriod" in segmentValues && segmentValues.dayPeriod) {
      valueText = isEmpty ? "Empty" : `${valueNow} ${segmentValues.dayPeriod}`;
    }
    return {
      "aria-label": `${this.part}, `,
      "aria-valuemin": valueMin,
      "aria-valuemax": valueMax,
      "aria-valuenow": valueNow,
      "aria-valuetext": valueText
    };
  }
  #props = tag(
    user_derived(() => {
      return {
        ...this.root.sharedSegmentAttrs,
        id: this.opts.id.current,
        ...this.getSegmentProps(),
        onkeydown: this.onkeydown,
        onfocusout: this.onfocusout,
        onclick: this.root.handleSegmentClick,
        ...this.root.getBaseSegmentAttrs(this.part, this.opts.id.current),
        ...this.attachment
      };
    }),
    "BaseNumericSegmentState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var DateFieldYearSegmentState = class extends BaseNumericSegmentState {
  #pressedKeys = [];
  #backspaceCount = 0;
  constructor(opts, root18) {
    super(opts, root18, "year", SEGMENT_CONFIGS.year);
  }
  onkeydown(e) {
    if (e.ctrlKey || e.metaKey || this.root.disabled.current) return;
    if (strict_equals(e.key, kbd_constants_exports.TAB, false)) e.preventDefault();
    if (!isAcceptableSegmentKey(e.key)) return;
    if (isArrowUp(e.key)) {
      this.#resetBackspaceCount();
      super.onkeydown(e);
      return;
    }
    if (isArrowDown(e.key)) {
      this.#resetBackspaceCount();
      super.onkeydown(e);
      return;
    }
    if (isNumberString(e.key)) {
      this.#handleYearNumberKey(e);
      return;
    }
    if (isBackspace(e.key)) {
      this.#handleYearBackspace(e);
      return;
    }
    if (isSegmentNavigationKey(e.key)) {
      handleSegmentNavigation(e, this.root.getFieldNode());
    }
  }
  #resetBackspaceCount() {
    this.#backspaceCount = 0;
  }
  #incrementBackspaceCount() {
    this.#backspaceCount++;
  }
  #handleYearNumberKey(e) {
    this.#pressedKeys.push(e.key);
    let moveToNext = false;
    const num = Number.parseInt(e.key);
    this.root.updateSegment("year", (prev2) => {
      if (this.root.states.year.hasLeftFocus) {
        prev2 = null;
        this.root.states.year.hasLeftFocus = false;
      }
      if (strict_equals(prev2, null)) {
        this.announcer.announce(num);
        return `000${num}`;
      }
      const str = prev2.toString() + num.toString();
      const mergedInt = Number.parseInt(str);
      const mergedIntDigits = String(mergedInt).length;
      if (mergedIntDigits < 4) {
        if (this.#backspaceCount > 0 && this.#pressedKeys.length <= this.#backspaceCount && str.length <= 4) {
          this.announcer.announce(mergedInt);
          return str;
        }
        this.announcer.announce(mergedInt);
        return prependYearZeros(mergedInt);
      }
      this.announcer.announce(mergedInt);
      moveToNext = true;
      const mergedIntStr = `${mergedInt}`;
      if (mergedIntStr.length > 4) {
        return mergedIntStr.slice(0, 4);
      }
      return mergedIntStr;
    });
    if (strict_equals(this.#pressedKeys.length, 4) || strict_equals(this.#pressedKeys.length, this.#backspaceCount)) {
      moveToNext = true;
    }
    if (moveToNext) {
      moveToNextSegment(e, this.root.getFieldNode());
    }
  }
  #handleYearBackspace(e) {
    this.#pressedKeys = [];
    this.#incrementBackspaceCount();
    let moveToPrev = false;
    this.root.updateSegment("year", (prev2) => {
      this.root.states.year.hasLeftFocus = false;
      if (strict_equals(prev2, null)) {
        moveToPrev = true;
        this.announcer.announce(null);
        return null;
      }
      const str = prev2.toString();
      if (strict_equals(str.length, 1)) {
        this.announcer.announce(null);
        return null;
      }
      const next3 = str.slice(0, -1);
      this.announcer.announce(next3);
      return `${next3}`;
    });
    if (moveToPrev) {
      moveToPrevSegment(e, this.root.getFieldNode());
    }
  }
  onfocusout(_) {
    this.root.states.year.hasLeftFocus = true;
    this.#pressedKeys = [];
    this.#resetBackspaceCount();
    this.root.updateSegment("year", (prev2) => {
      if (prev2 && strict_equals(prev2.length, 4, false)) {
        return prependYearZeros(Number.parseInt(prev2));
      }
      return prev2;
    });
  }
};
var DateFieldDaySegmentState = class extends BaseNumericSegmentState {
  constructor(opts, root18) {
    super(opts, root18, "day", SEGMENT_CONFIGS.day);
  }
};
var DateFieldMonthSegmentState = class extends BaseNumericSegmentState {
  constructor(opts, root18) {
    super(opts, root18, "month", SEGMENT_CONFIGS.month);
  }
};
var DateFieldHourSegmentState = class extends BaseNumericSegmentState {
  constructor(opts, root18) {
    super(opts, root18, "hour", SEGMENT_CONFIGS.hour);
  }
  // Override to handle special hour logic
  onkeydown(e) {
    if (isNumberString(e.key)) {
      const oldUpdateSegment = this.root.updateSegment.bind(this.root);
      this.root.updateSegment = (part, cb) => {
        const result = oldUpdateSegment(part, cb);
        if (strict_equals(part, "hour") && "hour" in this.root.segmentValues) {
          const hourValue = this.root.segmentValues.hour;
          if (strict_equals(hourValue, "0") && this.root.dayPeriodNode && strict_equals(this.root.hourCycle.current, 24, false)) {
            this.root.segmentValues.hour = "12";
          }
        }
        return result;
      };
    }
    super.onkeydown(e);
    this.root.updateSegment = this.root.updateSegment.bind(this.root);
  }
};
var DateFieldMinuteSegmentState = class extends BaseNumericSegmentState {
  constructor(opts, root18) {
    super(opts, root18, "minute", SEGMENT_CONFIGS.minute);
  }
};
var DateFieldSecondSegmentState = class extends BaseNumericSegmentState {
  constructor(opts, root18) {
    super(opts, root18, "second", SEGMENT_CONFIGS.second);
  }
};
var DateFieldDayPeriodSegmentState = class _DateFieldDayPeriodSegmentState {
  static create(opts) {
    return new _DateFieldDayPeriodSegmentState(opts, DateFieldRootContext.get());
  }
  opts;
  root;
  attachment;
  #announcer;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.#announcer = this.root.announcer;
    this.onkeydown = this.onkeydown.bind(this);
    this.attachment = attachRef(opts.ref, (v) => this.root.dayPeriodNode = v);
  }
  onkeydown(e) {
    if (e.ctrlKey || e.metaKey || this.root.disabled.current) return;
    if (strict_equals(e.key, kbd_constants_exports.TAB, false)) e.preventDefault();
    if (!isAcceptableDayPeriodKey(e.key)) return;
    if (isArrowUp(e.key) || isArrowDown(e.key)) {
      this.root.updateSegment("dayPeriod", (prev2) => {
        if (strict_equals(prev2, "AM")) {
          const next4 = "PM";
          this.#announcer.announce(next4);
          return next4;
        }
        const next3 = "AM";
        this.#announcer.announce(next3);
        return next3;
      });
      return;
    }
    if (isBackspace(e.key)) {
      this.root.states.dayPeriod.hasLeftFocus = false;
      this.root.updateSegment("dayPeriod", () => {
        const next3 = "AM";
        this.#announcer.announce(next3);
        return next3;
      });
    }
    if (strict_equals(e.key, kbd_constants_exports.A) || strict_equals(e.key, kbd_constants_exports.P) || kbd_constants_exports.a || kbd_constants_exports.p) {
      this.root.updateSegment("dayPeriod", () => {
        const next3 = strict_equals(e.key, kbd_constants_exports.A) || strict_equals(e.key, kbd_constants_exports.a) ? "AM" : "PM";
        this.#announcer.announce(next3);
        return next3;
      });
    }
    if (isSegmentNavigationKey(e.key)) {
      handleSegmentNavigation(e, this.root.getFieldNode());
    }
  }
  #props = tag(
    user_derived(() => {
      const segmentValues = this.root.segmentValues;
      if (!("dayPeriod" in segmentValues)) return;
      const valueMin = 0;
      const valueMax = 12;
      const valueNow = strict_equals(segmentValues.dayPeriod, "AM") ? 0 : 12;
      const valueText = segmentValues.dayPeriod ?? "AM";
      return {
        ...this.root.sharedSegmentAttrs,
        id: this.opts.id.current,
        inputmode: "text",
        "aria-label": "AM/PM",
        "aria-valuemin": valueMin,
        "aria-valuemax": valueMax,
        "aria-valuenow": valueNow,
        "aria-valuetext": valueText,
        onkeydown: this.onkeydown,
        onclick: this.root.handleSegmentClick,
        ...this.root.getBaseSegmentAttrs("dayPeriod", this.opts.id.current),
        ...this.attachment
      };
    }),
    "DateFieldDayPeriodSegmentState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var DateFieldLiteralSegmentState = class _DateFieldLiteralSegmentState {
  static create(opts) {
    return new _DateFieldLiteralSegmentState(opts, DateFieldRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "aria-hidden": getAriaHidden(true),
      ...this.root.getBaseSegmentAttrs("literal", this.opts.id.current),
      ...this.attachment
    })),
    "DateFieldLiteralSegmentState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var DateFieldTimeZoneSegmentState = class _DateFieldTimeZoneSegmentState {
  static create(opts) {
    return new _DateFieldTimeZoneSegmentState(opts, DateFieldRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.onkeydown = this.onkeydown.bind(this);
    this.attachment = attachRef(opts.ref);
  }
  onkeydown(e) {
    if (strict_equals(e.key, kbd_constants_exports.TAB, false)) e.preventDefault();
    if (this.root.disabled.current) return;
    if (isSegmentNavigationKey(e.key)) {
      handleSegmentNavigation(e, this.root.getFieldNode());
    }
  }
  #props = tag(
    user_derived(() => ({
      role: "textbox",
      id: this.opts.id.current,
      "aria-label": "timezone, ",
      style: { caretColor: "transparent" },
      onkeydown: this.onkeydown,
      ...this.root.getBaseSegmentAttrs("timeZoneName", this.opts.id.current),
      "data-readonly": getDataReadonly(true),
      ...this.attachment
    })),
    "DateFieldTimeZoneSegmentState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var DateFieldSegmentState = class {
  static create(part, opts) {
    const root18 = DateFieldRootContext.get();
    switch (part) {
      case "day":
        return new DateFieldDaySegmentState(opts, root18);
      case "month":
        return new DateFieldMonthSegmentState(opts, root18);
      case "year":
        return new DateFieldYearSegmentState(opts, root18);
      case "hour":
        return new DateFieldHourSegmentState(opts, root18);
      case "minute":
        return new DateFieldMinuteSegmentState(opts, root18);
      case "second":
        return new DateFieldSecondSegmentState(opts, root18);
      case "dayPeriod":
        return new DateFieldDayPeriodSegmentState(opts, root18);
      case "literal":
        return new DateFieldLiteralSegmentState(opts, root18);
      case "timeZoneName":
        return new DateFieldTimeZoneSegmentState(opts, root18);
    }
  }
};
function isAcceptableDayPeriodKey(key2) {
  return isAcceptableSegmentKey(key2) || strict_equals(key2, kbd_constants_exports.A) || strict_equals(key2, kbd_constants_exports.P) || strict_equals(key2, kbd_constants_exports.a) || strict_equals(key2, kbd_constants_exports.p);
}
function isArrowUp(key2) {
  return strict_equals(key2, kbd_constants_exports.ARROW_UP);
}
function isArrowDown(key2) {
  return strict_equals(key2, kbd_constants_exports.ARROW_DOWN);
}
function isBackspace(key2) {
  return strict_equals(key2, kbd_constants_exports.BACKSPACE);
}
function prependYearZeros(year) {
  const digits = String(year).length;
  const diff = 4 - digits;
  return `${"0".repeat(diff)}${year}`;
}

// node_modules/bits-ui/dist/bits/date-field/components/date-field.svelte
Date_field[FILENAME] = "node_modules/bits-ui/dist/bits/date-field/components/date-field.svelte";
function Date_field($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Date_field);
  let disabled = prop($$props, "disabled", 3, false), hideTimeZone = prop($$props, "hideTimeZone", 3, false), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop3), onValueChange = prop($$props, "onValueChange", 3, noop3), validate = prop($$props, "validate", 3, noop3), onInvalid = prop($$props, "onInvalid", 3, noop3), placeholder = prop($$props, "placeholder", 15), value = prop($$props, "value", 15), readonly = prop($$props, "readonly", 3, false), readonlySegments = prop($$props, "readonlySegments", 19, () => []), required = prop($$props, "required", 3, false);
  function handleDefaultPlaceholder() {
    if (strict_equals(placeholder(), void 0, false)) return;
    const defaultPlaceholder = getDefaultDate({ granularity: $$props.granularity, defaultValue: value() });
    placeholder(defaultPlaceholder);
  }
  handleDefaultPlaceholder();
  watch.pre(() => placeholder(), () => {
    handleDefaultPlaceholder();
  });
  DateFieldRootState.create({
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    placeholder: box.with(() => placeholder(), (v) => {
      placeholder(v);
      onPlaceholderChange()(v);
    }),
    disabled: box.with(() => disabled()),
    granularity: box.with(() => $$props.granularity),
    hideTimeZone: box.with(() => hideTimeZone()),
    hourCycle: box.with(() => $$props.hourCycle),
    locale: resolveLocaleProp(() => $$props.locale),
    maxValue: box.with(() => $$props.maxValue),
    minValue: box.with(() => $$props.minValue),
    validate: box.with(() => validate()),
    readonly: box.with(() => readonly()),
    readonlySegments: box.with(() => readonlySegments()),
    required: box.with(() => required()),
    onInvalid: box.with(() => onInvalid()),
    errorMessageId: box.with(() => $$props.errorMessageId),
    isInvalidProp: box.with(() => void 0)
  });
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop), "render", Date_field, 90, 0);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_field = hmr(Date_field, () => Date_field[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_field[HMR].source;
    set(Date_field[HMR].source, module.default[HMR].original);
  });
}
var date_field_default = Date_field;

// node_modules/bits-ui/dist/bits/date-field/components/date-field-hidden-input.svelte
Date_field_hidden_input[FILENAME] = "node_modules/bits-ui/dist/bits/date-field/components/date-field-hidden-input.svelte";
function Date_field_hidden_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Date_field_hidden_input);
  const hiddenInputState = DateFieldHiddenInputState.create();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => hidden_input_default(node_1, spread_props(() => hiddenInputState.props)), "component", Date_field_hidden_input, 9, 1, { componentTag: "HiddenInput" });
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (hiddenInputState.shouldRender) $$render(consequent);
      }),
      "if",
      Date_field_hidden_input,
      8,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_field_hidden_input = hmr(Date_field_hidden_input, () => Date_field_hidden_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_field_hidden_input[HMR].source;
    set(Date_field_hidden_input[HMR].source, module.default[HMR].original);
  });
}
var date_field_hidden_input_default = Date_field_hidden_input;

// node_modules/bits-ui/dist/bits/date-field/components/date-field-input.svelte
Date_field_input[FILENAME] = "node_modules/bits-ui/dist/bits/date-field/components/date-field-input.svelte";
var root_255 = add_locations(from_html(`<div><!></div>`), Date_field_input[FILENAME], [[34, 1]]);
var root7 = add_locations(from_html(`<!> <!>`, 1), Date_field_input[FILENAME], []);
function Date_field_input($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Date_field_input);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), name = prop($$props, "name", 3, ""), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "name",
      "children",
      "child"
    ],
    "restProps"
  );
  const inputState = DateFieldInputState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    name: box.with(() => name())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, inputState.props)), "mergedProps");
  var fragment = root7();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => snippet(node_1, () => $$props.child, () => ({
          props: get(mergedProps),
          segments: inputState.root.segmentContents
        })),
        "render",
        Date_field_input,
        32,
        1
      );
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_255();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => ({ segments: inputState.root.segmentContents })), "render", Date_field_input, 35, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Date_field_input,
      31,
      0
    );
  }
  var node_3 = sibling(node, 2);
  add_svelte_meta(() => date_field_hidden_input_default(node_3, {}), "component", Date_field_input, 39, 0, { componentTag: "DateFieldHiddenInput" });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_field_input = hmr(Date_field_input, () => Date_field_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_field_input[HMR].source;
    set(Date_field_input[HMR].source, module.default[HMR].original);
  });
}
var date_field_input_default = Date_field_input;

// node_modules/bits-ui/dist/bits/date-field/components/date-field-label.svelte
Date_field_label[FILENAME] = "node_modules/bits-ui/dist/bits/date-field/components/date-field-label.svelte";
var root_256 = add_locations(from_html(`<div><!></div>`), Date_field_label[FILENAME], [[31, 1]]);
function Date_field_label($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Date_field_label);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const labelState = DateFieldLabelState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, labelState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Date_field_label, 29, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_256();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Date_field_label, 32, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Date_field_label,
      28,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_field_label = hmr(Date_field_label, () => Date_field_label[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_field_label[HMR].source;
    set(Date_field_label[HMR].source, module.default[HMR].original);
  });
}
var date_field_label_default = Date_field_label;

// node_modules/bits-ui/dist/bits/date-field/components/date-field-segment.svelte
Date_field_segment[FILENAME] = "node_modules/bits-ui/dist/bits/date-field/components/date-field-segment.svelte";
var root_257 = add_locations(from_html(`<span><!></span>`), Date_field_segment[FILENAME], [[34, 1]]);
function Date_field_segment($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Date_field_segment);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child",
      "part"
    ],
    "restProps"
  );
  const segmentState = DateFieldSegmentState.create($$props.part, {
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, segmentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Date_field_segment, 32, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_257();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Date_field_segment, 35, 2);
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Date_field_segment,
      31,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_field_segment = hmr(Date_field_segment, () => Date_field_segment[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_field_segment[HMR].source;
    set(Date_field_segment[HMR].source, module.default[HMR].original);
  });
}
var date_field_segment_default = Date_field_segment;

// node_modules/bits-ui/dist/bits/date-picker/exports.js
var exports_exports13 = {};
__export(exports_exports13, {
  Arrow: () => popover_arrow_default,
  Calendar: () => date_picker_calendar_default,
  Cell: () => calendar_cell_default,
  Close: () => popover_close_default,
  Content: () => date_picker_content_default,
  ContentStatic: () => date_picker_content_static_default,
  Day: () => calendar_day_default,
  Grid: () => calendar_grid_default,
  GridBody: () => calendar_grid_body_default,
  GridHead: () => calendar_grid_head_default,
  GridRow: () => calendar_grid_row_default,
  HeadCell: () => calendar_head_cell_default,
  Header: () => calendar_header_default,
  Heading: () => calendar_heading_default,
  Input: () => date_field_input_default,
  Label: () => date_field_label_default,
  MonthSelect: () => calendar_month_select_default,
  NextButton: () => calendar_next_button_default,
  Portal: () => portal_default,
  PrevButton: () => calendar_prev_button_default,
  Root: () => date_picker_default,
  Segment: () => date_field_segment_default,
  Trigger: () => date_picker_trigger_default,
  YearSelect: () => calendar_year_select_default
});

// node_modules/bits-ui/dist/bits/date-picker/date-picker.svelte.js
var DatePickerRootContext = new Context("DatePicker.Root");
var DatePickerRootState = class _DatePickerRootState {
  static create(opts) {
    return DatePickerRootContext.set(new _DatePickerRootState(opts));
  }
  opts;
  constructor(opts) {
    this.opts = opts;
  }
};

// node_modules/bits-ui/dist/bits/popover/popover.svelte.js
var popoverAttrs = createBitsAttrs({
  component: "popover",
  parts: ["root", "trigger", "content", "close"]
});
var PopoverRootContext = new Context("Popover.Root");
var PopoverRootState = class _PopoverRootState {
  static create(opts) {
    return PopoverRootContext.set(new _PopoverRootState(opts));
  }
  opts;
  #contentNode = tag(state(null), "PopoverRootState.contentNode");
  get contentNode() {
    return get(this.#contentNode);
  }
  set contentNode(value) {
    set(this.#contentNode, value, true);
  }
  #triggerNode = tag(state(null), "PopoverRootState.triggerNode");
  get triggerNode() {
    return get(this.#triggerNode);
  }
  set triggerNode(value) {
    set(this.#triggerNode, value, true);
  }
  constructor(opts) {
    this.opts = opts;
    new OpenChangeComplete({
      ref: box.with(() => this.contentNode),
      open: this.opts.open,
      onComplete: () => {
        this.opts.onOpenChangeComplete.current(this.opts.open.current);
      }
    });
  }
  toggleOpen() {
    this.opts.open.current = !this.opts.open.current;
  }
  handleClose() {
    if (!this.opts.open.current) return;
    this.opts.open.current = false;
  }
};
var PopoverTriggerState = class _PopoverTriggerState {
  static create(opts) {
    return new _PopoverTriggerState(opts, PopoverRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.triggerNode = v);
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  onclick(e) {
    if (this.opts.disabled.current) return;
    if (strict_equals(e.button, 0, false)) return;
    this.root.toggleOpen();
  }
  onkeydown(e) {
    if (this.opts.disabled.current) return;
    if (!(strict_equals(e.key, kbd_constants_exports.ENTER) || strict_equals(e.key, kbd_constants_exports.SPACE))) return;
    e.preventDefault();
    this.root.toggleOpen();
  }
  #getAriaControls() {
    if (this.root.opts.open.current && this.root.contentNode?.id) {
      return this.root.contentNode?.id;
    }
    return void 0;
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "aria-haspopup": "dialog",
      "aria-expanded": getAriaExpanded(this.root.opts.open.current),
      "data-state": getDataOpenClosed(this.root.opts.open.current),
      "aria-controls": this.#getAriaControls(),
      [popoverAttrs.trigger]: "",
      disabled: this.opts.disabled.current,
      //
      onkeydown: this.onkeydown,
      onclick: this.onclick,
      ...this.attachment
    })),
    "PopoverTriggerState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var PopoverContentState = class _PopoverContentState {
  static create(opts) {
    return new _PopoverContentState(opts, PopoverRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.contentNode = v);
  }
  onInteractOutside = (e) => {
    this.opts.onInteractOutside.current(e);
    if (e.defaultPrevented) return;
    if (!isElement2(e.target)) return;
    const closestTrigger = e.target.closest(popoverAttrs.selector("trigger"));
    if (strict_equals(closestTrigger, this.root.triggerNode)) return;
    this.root.handleClose();
  };
  onEscapeKeydown = (e) => {
    this.opts.onEscapeKeydown.current(e);
    if (e.defaultPrevented) return;
    this.root.handleClose();
  };
  onCloseAutoFocus = (e) => {
    this.opts.onCloseAutoFocus.current?.(e);
    if (e.defaultPrevented) return;
    e.preventDefault();
    this.root.triggerNode?.focus();
  };
  #snippetProps = tag(user_derived(() => ({ open: this.root.opts.open.current })), "PopoverContentState.snippetProps");
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      tabindex: -1,
      "data-state": getDataOpenClosed(this.root.opts.open.current),
      [popoverAttrs.content]: "",
      style: { pointerEvents: "auto" },
      ...this.attachment
    })),
    "PopoverContentState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
  popperProps = {
    onInteractOutside: this.onInteractOutside,
    onEscapeKeydown: this.onEscapeKeydown,
    onCloseAutoFocus: this.onCloseAutoFocus
  };
};
var PopoverCloseState = class _PopoverCloseState {
  static create(opts) {
    return new _PopoverCloseState(opts, PopoverRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  onclick(_) {
    this.root.handleClose();
  }
  onkeydown(e) {
    if (!(strict_equals(e.key, kbd_constants_exports.ENTER) || strict_equals(e.key, kbd_constants_exports.SPACE))) return;
    e.preventDefault();
    this.root.handleClose();
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      onclick: this.onclick,
      onkeydown: this.onkeydown,
      type: "button",
      [popoverAttrs.close]: "",
      ...this.attachment
    })),
    "PopoverCloseState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker.svelte
Date_picker[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker.svelte";
function Date_picker($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Date_picker);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop3), placeholder = prop($$props, "placeholder", 15), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop3), isDateUnavailable = prop($$props, "isDateUnavailable", 3, () => false), validate = prop($$props, "validate", 3, noop3), onInvalid = prop($$props, "onInvalid", 3, noop3), disabled = prop($$props, "disabled", 3, false), readonly = prop($$props, "readonly", 3, false), readonlySegments = prop($$props, "readonlySegments", 19, () => []), hideTimeZone = prop($$props, "hideTimeZone", 3, false), required = prop($$props, "required", 3, false), calendarLabel = prop($$props, "calendarLabel", 3, "Event"), disableDaysOutsideMonth = prop($$props, "disableDaysOutsideMonth", 3, true), preventDeselect = prop($$props, "preventDeselect", 3, false), pagedNavigation = prop($$props, "pagedNavigation", 3, false), weekdayFormat = prop($$props, "weekdayFormat", 3, "narrow"), isDateDisabled = prop($$props, "isDateDisabled", 3, () => false), fixedWeeks = prop($$props, "fixedWeeks", 3, false), numberOfMonths = prop($$props, "numberOfMonths", 3, 1), closeOnDateSelect = prop($$props, "closeOnDateSelect", 3, true), initialFocus = prop($$props, "initialFocus", 3, false), monthFormat = prop($$props, "monthFormat", 3, "long"), yearFormat = prop($$props, "yearFormat", 3, "numeric");
  const defaultPlaceholder = getDefaultDate({ granularity: $$props.granularity, defaultValue: value() });
  function handleDefaultPlaceholder() {
    if (strict_equals(placeholder(), void 0, false)) return;
    placeholder(defaultPlaceholder);
  }
  handleDefaultPlaceholder();
  watch.pre(() => placeholder(), () => {
    handleDefaultPlaceholder();
  });
  function onDateSelect() {
    if (closeOnDateSelect()) {
      open(false);
    }
  }
  const pickerRootState = DatePickerRootState.create({
    open: box.with(() => open(), (v) => {
      open(v);
      onOpenChange()(v);
    }),
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    placeholder: box.with(() => placeholder(), (v) => {
      placeholder(v);
      onPlaceholderChange()(v);
    }),
    isDateUnavailable: box.with(() => isDateUnavailable()),
    minValue: box.with(() => $$props.minValue),
    maxValue: box.with(() => $$props.maxValue),
    disabled: box.with(() => disabled()),
    readonly: box.with(() => readonly()),
    granularity: box.with(() => $$props.granularity),
    readonlySegments: box.with(() => readonlySegments()),
    hourCycle: box.with(() => $$props.hourCycle),
    locale: resolveLocaleProp(() => $$props.locale),
    hideTimeZone: box.with(() => hideTimeZone()),
    required: box.with(() => required()),
    calendarLabel: box.with(() => calendarLabel()),
    disableDaysOutsideMonth: box.with(() => disableDaysOutsideMonth()),
    preventDeselect: box.with(() => preventDeselect()),
    pagedNavigation: box.with(() => pagedNavigation()),
    weekStartsOn: box.with(() => $$props.weekStartsOn),
    weekdayFormat: box.with(() => weekdayFormat()),
    isDateDisabled: box.with(() => isDateDisabled()),
    fixedWeeks: box.with(() => fixedWeeks()),
    numberOfMonths: box.with(() => numberOfMonths()),
    initialFocus: box.with(() => initialFocus()),
    onDateSelect: box.with(() => onDateSelect),
    defaultPlaceholder,
    monthFormat: box.with(() => monthFormat()),
    yearFormat: box.with(() => yearFormat())
  });
  PopoverRootState.create({
    open: pickerRootState.opts.open,
    onOpenChangeComplete: box.with(() => onOpenChangeComplete())
  });
  DateFieldRootState.create({
    value: pickerRootState.opts.value,
    disabled: pickerRootState.opts.disabled,
    readonly: pickerRootState.opts.readonly,
    readonlySegments: pickerRootState.opts.readonlySegments,
    validate: box.with(() => validate()),
    onInvalid: box.with(() => onInvalid()),
    minValue: pickerRootState.opts.minValue,
    maxValue: pickerRootState.opts.maxValue,
    granularity: pickerRootState.opts.granularity,
    hideTimeZone: pickerRootState.opts.hideTimeZone,
    hourCycle: pickerRootState.opts.hourCycle,
    locale: pickerRootState.opts.locale,
    required: pickerRootState.opts.required,
    placeholder: pickerRootState.opts.placeholder,
    errorMessageId: box.with(() => $$props.errorMessageId),
    isInvalidProp: box.with(() => void 0)
  });
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => component(node, () => components_exports.Root, ($$anchor2, FloatingLayer_Root) => {
      FloatingLayer_Root($$anchor2, {
        children: wrap_snippet(Date_picker, ($$anchor3, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop), "render", Date_picker, 159, 1);
          append($$anchor3, fragment_1);
        }),
        $$slots: { default: true }
      });
    }),
    "component",
    Date_picker,
    158,
    0,
    { componentTag: "FloatingLayer.Root" }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_picker = hmr(Date_picker, () => Date_picker[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_picker[HMR].source;
    set(Date_picker[HMR].source, module.default[HMR].original);
  });
}
var date_picker_default = Date_picker;

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-calendar.svelte
Date_picker_calendar[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-calendar.svelte";
var root_258 = add_locations(from_html(`<div><!></div>`), Date_picker_calendar[FILENAME], [[58, 1]]);
function Date_picker_calendar($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Date_picker_calendar);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref"
    ],
    "restProps"
  );
  const datePickerRootState = DatePickerRootContext.get();
  const calendarState = CalendarRootState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    calendarLabel: datePickerRootState.opts.calendarLabel,
    fixedWeeks: datePickerRootState.opts.fixedWeeks,
    isDateDisabled: datePickerRootState.opts.isDateDisabled,
    isDateUnavailable: datePickerRootState.opts.isDateUnavailable,
    locale: datePickerRootState.opts.locale,
    numberOfMonths: datePickerRootState.opts.numberOfMonths,
    pagedNavigation: datePickerRootState.opts.pagedNavigation,
    preventDeselect: datePickerRootState.opts.preventDeselect,
    readonly: datePickerRootState.opts.readonly,
    type: box.with(() => "single"),
    weekStartsOn: datePickerRootState.opts.weekStartsOn,
    weekdayFormat: datePickerRootState.opts.weekdayFormat,
    disabled: datePickerRootState.opts.disabled,
    disableDaysOutsideMonth: datePickerRootState.opts.disableDaysOutsideMonth,
    maxValue: datePickerRootState.opts.maxValue,
    minValue: datePickerRootState.opts.minValue,
    placeholder: datePickerRootState.opts.placeholder,
    value: datePickerRootState.opts.value,
    onDateSelect: datePickerRootState.opts.onDateSelect,
    initialFocus: datePickerRootState.opts.initialFocus,
    defaultPlaceholder: datePickerRootState.opts.defaultPlaceholder,
    maxDays: box.with(() => void 0),
    monthFormat: datePickerRootState.opts.monthFormat,
    yearFormat: datePickerRootState.opts.yearFormat
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, calendarState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => ({ props: get(mergedProps), ...calendarState.snippetProps }));
        add_svelte_meta(() => snippet(node_1, () => $$props.child, () => get($0)), "render", Date_picker_calendar, 56, 1);
      }
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_258();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => calendarState.snippetProps), "render", Date_picker_calendar, 59, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Date_picker_calendar,
      55,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_picker_calendar = hmr(Date_picker_calendar, () => Date_picker_calendar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_picker_calendar[HMR].source;
    set(Date_picker_calendar[HMR].source, module.default[HMR].original);
  });
}
var date_picker_calendar_default = Date_picker_calendar;

// node_modules/bits-ui/dist/bits/popover/components/popover-content.svelte
Popover_content[FILENAME] = "node_modules/bits-ui/dist/bits/popover/components/popover-content.svelte";
var root_411 = add_locations(from_html(`<div><div><!></div></div>`), Popover_content[FILENAME], [[60, 4, [[61, 5]]]]);
var root_97 = add_locations(from_html(`<div><div><!></div></div>`), Popover_content[FILENAME], [[87, 4, [[88, 5]]]]);
function Popover_content($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Popover_content);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), forceMount = prop($$props, "forceMount", 3, false), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), trapFocus = prop($$props, "trapFocus", 3, true), preventScroll = prop($$props, "preventScroll", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "ref",
      "id",
      "forceMount",
      "onCloseAutoFocus",
      "onEscapeKeydown",
      "onInteractOutside",
      "trapFocus",
      "preventScroll"
    ],
    "restProps"
  );
  const contentState = PopoverContentState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onInteractOutside: box.with(() => onInteractOutside()),
    onEscapeKeydown: box.with(() => onEscapeKeydown()),
    onCloseAutoFocus: box.with(() => onCloseAutoFocus())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Popover_content, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0?.().props;
          props();
          let wrapperProps = () => $$arg0?.().wrapperProps;
          wrapperProps();
          var fragment_2 = comment();
          const finalProps = tag(user_derived(() => mergeProps(props(), { style: getFloatingContentCSSVars("popover") })), "finalProps");
          get(finalProps);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              {
                let $0 = user_derived(() => ({
                  props: get(finalProps),
                  wrapperProps: wrapperProps(),
                  ...contentState.snippetProps
                }));
                add_svelte_meta(() => snippet(node_3, () => $$props.child, () => get($0)), "render", Popover_content, 58, 4);
              }
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_411();
              attribute_effect(div, () => ({ ...wrapperProps() }));
              var div_1 = child(div);
              attribute_effect(div_1, () => ({ ...get(finalProps) }));
              var node_4 = child(div_1);
              add_svelte_meta(() => snippet(node_4, () => $$props.children ?? noop), "render", Popover_content, 62, 6);
              reset(div_1);
              reset(div);
              append($$anchor4, div);
            };
            add_svelte_meta(
              () => if_block(node_2, ($$render) => {
                if ($$props.child) $$render(consequent);
                else $$render(alternate, false);
              }),
              "if",
              Popover_content,
              57,
              3
            );
          }
          append($$anchor3, fragment_2);
        });
        add_svelte_meta(
          () => popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), () => contentState.popperProps, {
            get ref() {
              return contentState.opts.ref;
            },
            get enabled() {
              return contentState.root.opts.open.current;
            },
            get id() {
              return id();
            },
            get trapFocus() {
              return trapFocus();
            },
            get preventScroll() {
              return preventScroll();
            },
            loop: true,
            forceMount: true,
            popper,
            $$slots: { popper: true }
          })),
          "component",
          Popover_content,
          42,
          1,
          { componentTag: "PopperLayerForceMount" }
        );
      }
      append($$anchor2, fragment_1);
    };
    var alternate_2 = ($$anchor2) => {
      var fragment_4 = comment();
      var node_5 = first_child(fragment_4);
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_5 = comment();
          var node_6 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Popover_content, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0?.().props;
              props();
              let wrapperProps = () => $$arg0?.().wrapperProps;
              wrapperProps();
              var fragment_6 = comment();
              const finalProps = tag(user_derived(() => mergeProps(props(), { style: getFloatingContentCSSVars("popover") })), "finalProps");
              get(finalProps);
              var node_7 = first_child(fragment_6);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_8 = first_child(fragment_7);
                  {
                    let $0 = user_derived(() => ({
                      props: get(finalProps),
                      wrapperProps: wrapperProps(),
                      ...contentState.snippetProps
                    }));
                    add_svelte_meta(() => snippet(node_8, () => $$props.child, () => get($0)), "render", Popover_content, 85, 4);
                  }
                  append($$anchor5, fragment_7);
                };
                var alternate_1 = ($$anchor5) => {
                  var div_2 = root_97();
                  attribute_effect(div_2, () => ({ ...wrapperProps() }));
                  var div_3 = child(div_2);
                  attribute_effect(div_3, () => ({ ...get(finalProps) }));
                  var node_9 = child(div_3);
                  add_svelte_meta(() => snippet(node_9, () => $$props.children ?? noop), "render", Popover_content, 89, 6);
                  reset(div_3);
                  reset(div_2);
                  append($$anchor5, div_2);
                };
                add_svelte_meta(
                  () => if_block(node_7, ($$render) => {
                    if ($$props.child) $$render(consequent_2);
                    else $$render(alternate_1, false);
                  }),
                  "if",
                  Popover_content,
                  84,
                  3
                );
              }
              append($$anchor4, fragment_6);
            });
            add_svelte_meta(
              () => popper_layer_default(node_6, spread_props(() => get(mergedProps), () => contentState.popperProps, {
                get ref() {
                  return contentState.opts.ref;
                },
                get open() {
                  return contentState.root.opts.open.current;
                },
                get id() {
                  return id();
                },
                get trapFocus() {
                  return trapFocus();
                },
                get preventScroll() {
                  return preventScroll();
                },
                loop: true,
                forceMount: false,
                popper,
                $$slots: { popper: true }
              })),
              "component",
              Popover_content,
              69,
              1,
              { componentTag: "PopperLayer" }
            );
          }
          append($$anchor3, fragment_5);
        };
        add_svelte_meta(
          () => if_block(
            node_5,
            ($$render) => {
              if (!forceMount()) $$render(consequent_3);
            },
            true
          ),
          "if",
          Popover_content,
          68,
          0
        );
      }
      append($$anchor2, fragment_4);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (forceMount()) $$render(consequent_1);
        else $$render(alternate_2, false);
      }),
      "if",
      Popover_content,
      41,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popover_content = hmr(Popover_content, () => Popover_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popover_content[HMR].source;
    set(Popover_content[HMR].source, module.default[HMR].original);
  });
}
var popover_content_default = Popover_content;

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-content.svelte
Date_picker_content[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-content.svelte";
function Date_picker_content($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Date_picker_content);
  var $$ownership_validator = create_ownership_validator($$props);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "ref", "onOpenAutoFocus"], "restProps");
  const mergedProps = tag(user_derived(() => mergeProps({ onOpenAutoFocus: $$props.onOpenAutoFocus }, { onOpenAutoFocus: pickerOpenFocus })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    $$ownership_validator.binding("ref", popover_content_default, ref);
    add_svelte_meta(
      () => popover_content_default(node, spread_props(() => get(mergedProps), () => restProps, {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        }
      })),
      "component",
      Date_picker_content,
      14,
      0,
      { componentTag: "PopoverContent" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_picker_content = hmr(Date_picker_content, () => Date_picker_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_picker_content[HMR].source;
    set(Date_picker_content[HMR].source, module.default[HMR].original);
  });
}
var date_picker_content_default = Date_picker_content;

// node_modules/bits-ui/dist/bits/popover/components/popover-content-static.svelte
Popover_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/popover/components/popover-content-static.svelte";
var root_412 = add_locations(from_html(`<div><!></div>`), Popover_content_static[FILENAME], [[61, 4]]);
var root_98 = add_locations(from_html(`<div><!></div>`), Popover_content_static[FILENAME], [[87, 4]]);
function Popover_content_static($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Popover_content_static);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), forceMount = prop($$props, "forceMount", 3, false), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), trapFocus = prop($$props, "trapFocus", 3, true), preventScroll = prop($$props, "preventScroll", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "ref",
      "id",
      "forceMount",
      "onCloseAutoFocus",
      "onEscapeKeydown",
      "onInteractOutside",
      "trapFocus",
      "preventScroll"
    ],
    "restProps"
  );
  const contentState = PopoverContentState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onInteractOutside: box.with(() => onInteractOutside()),
    onEscapeKeydown: box.with(() => onEscapeKeydown()),
    onCloseAutoFocus: box.with(() => onCloseAutoFocus())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Popover_content_static, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0?.().props;
          props();
          var fragment_2 = comment();
          const finalProps = tag(user_derived(() => mergeProps(props(), { style: getFloatingContentCSSVars("popover") })), "finalProps");
          get(finalProps);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              {
                let $0 = user_derived(() => ({ props: get(finalProps), ...contentState.snippetProps }));
                add_svelte_meta(() => snippet(node_3, () => $$props.child, () => get($0)), "render", Popover_content_static, 59, 4);
              }
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_412();
              attribute_effect(div, () => ({ ...get(finalProps) }));
              var node_4 = child(div);
              add_svelte_meta(() => snippet(node_4, () => $$props.children ?? noop), "render", Popover_content_static, 62, 5);
              reset(div);
              append($$anchor4, div);
            };
            add_svelte_meta(
              () => if_block(node_2, ($$render) => {
                if ($$props.child) $$render(consequent);
                else $$render(alternate, false);
              }),
              "if",
              Popover_content_static,
              58,
              3
            );
          }
          append($$anchor3, fragment_2);
        });
        add_svelte_meta(
          () => popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), () => contentState.popperProps, {
            get ref() {
              return contentState.opts.ref;
            },
            isStatic: true,
            get enabled() {
              return contentState.root.opts.open.current;
            },
            get id() {
              return id();
            },
            get trapFocus() {
              return trapFocus();
            },
            get preventScroll() {
              return preventScroll();
            },
            loop: true,
            forceMount: true,
            popper,
            $$slots: { popper: true }
          })),
          "component",
          Popover_content_static,
          42,
          1,
          { componentTag: "PopperLayerForceMount" }
        );
      }
      append($$anchor2, fragment_1);
    };
    var alternate_2 = ($$anchor2) => {
      var fragment_4 = comment();
      var node_5 = first_child(fragment_4);
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_5 = comment();
          var node_6 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Popover_content_static, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0?.().props;
              props();
              var fragment_6 = comment();
              const finalProps = tag(user_derived(() => mergeProps(props(), { style: getFloatingContentCSSVars("popover") })), "finalProps");
              get(finalProps);
              var node_7 = first_child(fragment_6);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_8 = first_child(fragment_7);
                  {
                    let $0 = user_derived(() => ({ props: get(finalProps), ...contentState.snippetProps }));
                    add_svelte_meta(() => snippet(node_8, () => $$props.child, () => get($0)), "render", Popover_content_static, 85, 4);
                  }
                  append($$anchor5, fragment_7);
                };
                var alternate_1 = ($$anchor5) => {
                  var div_1 = root_98();
                  attribute_effect(div_1, () => ({ ...get(finalProps) }));
                  var node_9 = child(div_1);
                  add_svelte_meta(() => snippet(node_9, () => $$props.children ?? noop), "render", Popover_content_static, 88, 5);
                  reset(div_1);
                  append($$anchor5, div_1);
                };
                add_svelte_meta(
                  () => if_block(node_7, ($$render) => {
                    if ($$props.child) $$render(consequent_2);
                    else $$render(alternate_1, false);
                  }),
                  "if",
                  Popover_content_static,
                  84,
                  3
                );
              }
              append($$anchor4, fragment_6);
            });
            add_svelte_meta(
              () => popper_layer_default(node_6, spread_props(() => get(mergedProps), () => contentState.popperProps, {
                get ref() {
                  return contentState.opts.ref;
                },
                isStatic: true,
                get open() {
                  return contentState.root.opts.open.current;
                },
                get id() {
                  return id();
                },
                get trapFocus() {
                  return trapFocus();
                },
                get preventScroll() {
                  return preventScroll();
                },
                loop: true,
                forceMount: false,
                popper,
                $$slots: { popper: true }
              })),
              "component",
              Popover_content_static,
              68,
              1,
              { componentTag: "PopperLayer" }
            );
          }
          append($$anchor3, fragment_5);
        };
        add_svelte_meta(
          () => if_block(
            node_5,
            ($$render) => {
              if (!forceMount()) $$render(consequent_3);
            },
            true
          ),
          "if",
          Popover_content_static,
          67,
          0
        );
      }
      append($$anchor2, fragment_4);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (forceMount()) $$render(consequent_1);
        else $$render(alternate_2, false);
      }),
      "if",
      Popover_content_static,
      41,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popover_content_static = hmr(Popover_content_static, () => Popover_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popover_content_static[HMR].source;
    set(Popover_content_static[HMR].source, module.default[HMR].original);
  });
}
var popover_content_static_default = Popover_content_static;

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-content-static.svelte
Date_picker_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-content-static.svelte";
function Date_picker_content_static($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Date_picker_content_static);
  var $$ownership_validator = create_ownership_validator($$props);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "ref", "onOpenAutoFocus"], "restProps");
  const mergedProps = tag(user_derived(() => mergeProps({ onOpenAutoFocus: $$props.onOpenAutoFocus }, { onOpenAutoFocus: pickerOpenFocus })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    $$ownership_validator.binding("ref", popover_content_static_default, ref);
    add_svelte_meta(
      () => popover_content_static_default(node, spread_props(() => get(mergedProps), () => restProps, {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        }
      })),
      "component",
      Date_picker_content_static,
      18,
      0,
      { componentTag: "PopoverContentStatic" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_picker_content_static = hmr(Date_picker_content_static, () => Date_picker_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_picker_content_static[HMR].source;
    set(Date_picker_content_static[HMR].source, module.default[HMR].original);
  });
}
var date_picker_content_static_default = Date_picker_content_static;

// node_modules/bits-ui/dist/bits/popover/components/popover-trigger.svelte
Popover_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/popover/components/popover-trigger.svelte";
var root_313 = add_locations(from_html(`<button><!></button>`), Popover_trigger[FILENAME], [[36, 2]]);
function Popover_trigger($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Popover_trigger);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), type = prop($$props, "type", 3, "button"), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "type",
      "disabled"
    ],
    "restProps"
  );
  const triggerState = PopoverTriggerState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => Boolean(disabled()))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, triggerState.props, { type: type() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => floating_layer_anchor_default(node, {
      get id() {
        return id();
      },
      get ref() {
        return triggerState.opts.ref;
      },
      children: wrap_snippet(Popover_trigger, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        {
          var consequent = ($$anchor3) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            add_svelte_meta(() => snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Popover_trigger, 34, 2);
            append($$anchor3, fragment_2);
          };
          var alternate = ($$anchor3) => {
            var button = root_313();
            attribute_effect(button, () => ({ ...get(mergedProps) }));
            var node_3 = child(button);
            add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop), "render", Popover_trigger, 37, 3);
            reset(button);
            append($$anchor3, button);
          };
          add_svelte_meta(
            () => if_block(node_1, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            }),
            "if",
            Popover_trigger,
            33,
            1
          );
        }
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }),
    "component",
    Popover_trigger,
    32,
    0,
    { componentTag: "FloatingLayerAnchor" }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popover_trigger = hmr(Popover_trigger, () => Popover_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popover_trigger[HMR].source;
    set(Popover_trigger[HMR].source, module.default[HMR].original);
  });
}
var popover_trigger_default = Popover_trigger;

// node_modules/bits-ui/dist/bits/date-picker/components/date-picker-trigger.svelte
Date_picker_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/date-picker/components/date-picker-trigger.svelte";
function Date_picker_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Date_picker_trigger);
  var $$ownership_validator = create_ownership_validator($$props);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "ref", "onkeydown"], "restProps");
  function onKeydown(e) {
    if (isSegmentNavigationKey(e.key)) {
      const currNode = e.currentTarget;
      const dateFieldInputNode = currNode.closest(dateFieldAttrs.selector("input"));
      if (!dateFieldInputNode) return;
      handleSegmentNavigation(e, dateFieldInputNode);
    }
  }
  const mergedProps = tag(user_derived(() => mergeProps({ onkeydown: $$props.onkeydown }, { onkeydown: onKeydown })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    $$ownership_validator.binding("ref", popover_trigger_default, ref);
    add_svelte_meta(
      () => popover_trigger_default(node, spread_props(() => restProps, { "data-segment": "trigger" }, () => get(mergedProps), {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        }
      })),
      "component",
      Date_picker_trigger,
      27,
      0,
      { componentTag: "PopoverTrigger" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_picker_trigger = hmr(Date_picker_trigger, () => Date_picker_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_picker_trigger[HMR].source;
    set(Date_picker_trigger[HMR].source, module.default[HMR].original);
  });
}
var date_picker_trigger_default = Date_picker_trigger;

// node_modules/bits-ui/dist/bits/popover/components/popover-arrow.svelte
Popover_arrow[FILENAME] = "node_modules/bits-ui/dist/bits/popover/components/popover-arrow.svelte";
function Popover_arrow($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Popover_arrow);
  var $$ownership_validator = create_ownership_validator($$props);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "ref"], "restProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    $$ownership_validator.binding("ref", floating_layer_arrow_default, ref);
    add_svelte_meta(
      () => floating_layer_arrow_default(node, spread_props(() => restProps, {
        "data-popover-arrow": "",
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        }
      })),
      "component",
      Popover_arrow,
      8,
      0,
      { componentTag: "FloatingLayerArrow" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popover_arrow = hmr(Popover_arrow, () => Popover_arrow[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popover_arrow[HMR].source;
    set(Popover_arrow[HMR].source, module.default[HMR].original);
  });
}
var popover_arrow_default = Popover_arrow;

// node_modules/bits-ui/dist/bits/popover/components/popover-close.svelte
Popover_close[FILENAME] = "node_modules/bits-ui/dist/bits/popover/components/popover-close.svelte";
var root_259 = add_locations(from_html(`<button><!></button>`), Popover_close[FILENAME], [[30, 1]]);
function Popover_close($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Popover_close);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "id",
      "ref"
    ],
    "restProps"
  );
  const closeState = PopoverCloseState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, closeState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Popover_close, 28, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_259();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Popover_close, 31, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Popover_close,
      27,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popover_close = hmr(Popover_close, () => Popover_close[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popover_close[HMR].source;
    set(Popover_close[HMR].source, module.default[HMR].original);
  });
}
var popover_close_default = Popover_close;

// node_modules/bits-ui/dist/bits/date-range-field/exports.js
var exports_exports14 = {};
__export(exports_exports14, {
  Input: () => date_range_field_input_default,
  Label: () => date_range_field_label_default,
  Root: () => date_range_field_default,
  Segment: () => date_field_segment_default
});

// node_modules/bits-ui/dist/bits/date-range-field/date-range-field.svelte.js
var dateRangeFieldAttrs = createBitsAttrs({ component: "date-range-field", parts: ["root", "label"] });
var DateRangeFieldRootContext = new Context("DateRangeField.Root");
var DateRangeFieldRootState = class _DateRangeFieldRootState {
  static create(opts) {
    return DateRangeFieldRootContext.set(new _DateRangeFieldRootState(opts));
  }
  opts;
  startFieldState = void 0;
  endFieldState = void 0;
  descriptionId = useId();
  formatter;
  #fieldNode = tag(state(null), "DateRangeFieldRootState.fieldNode");
  get fieldNode() {
    return get(this.#fieldNode);
  }
  set fieldNode(value) {
    set(this.#fieldNode, value, true);
  }
  #labelNode = tag(state(null), "DateRangeFieldRootState.labelNode");
  get labelNode() {
    return get(this.#labelNode);
  }
  set labelNode(value) {
    set(this.#labelNode, value, true);
  }
  #descriptionNode = tag(state(null), "DateRangeFieldRootState.descriptionNode");
  get descriptionNode() {
    return get(this.#descriptionNode);
  }
  set descriptionNode(value) {
    set(this.#descriptionNode, value, true);
  }
  #startValueComplete = tag(user_derived(() => strict_equals(this.opts.startValue.current, void 0, false)), "DateRangeFieldRootState.startValueComplete");
  get startValueComplete() {
    return get(this.#startValueComplete);
  }
  set startValueComplete(value) {
    set(this.#startValueComplete, value);
  }
  #endValueComplete = tag(user_derived(() => strict_equals(this.opts.endValue.current, void 0, false)), "DateRangeFieldRootState.endValueComplete");
  get endValueComplete() {
    return get(this.#endValueComplete);
  }
  set endValueComplete(value) {
    set(this.#endValueComplete, value);
  }
  #rangeComplete = tag(user_derived(() => this.startValueComplete && this.endValueComplete), "DateRangeFieldRootState.rangeComplete");
  get rangeComplete() {
    return get(this.#rangeComplete);
  }
  set rangeComplete(value) {
    set(this.#rangeComplete, value);
  }
  domContext;
  attachment;
  constructor(opts) {
    this.opts = opts;
    this.formatter = createFormatter({
      initialLocale: this.opts.locale.current,
      monthFormat: box.with(() => "long"),
      yearFormat: box.with(() => "numeric")
    });
    this.domContext = new DOMContext(this.opts.ref);
    this.attachment = attachRef(this.opts.ref, (v) => this.fieldNode = v);
    onDestroyEffect(() => {
      removeDescriptionElement(this.descriptionId, this.domContext.getDocument());
    });
    user_effect(() => {
      if (strict_equals(this.formatter.getLocale(), this.opts.locale.current)) return;
      this.formatter.setLocale(this.opts.locale.current);
    });
    watch(() => this.opts.value.current, (value) => {
      if (value.start && value.end) {
        this.opts.startValue.current = value.start;
        this.opts.endValue.current = value.end;
      } else if (value.start) {
        this.opts.startValue.current = value.start;
        this.opts.endValue.current = void 0;
      } else if (strict_equals(value.start, void 0) && strict_equals(value.end, void 0)) {
        this.opts.startValue.current = void 0;
        this.opts.endValue.current = void 0;
      }
    });
    watch(() => this.opts.value.current, (value) => {
      const startValue = value.start;
      if (startValue && strict_equals(this.opts.placeholder.current, startValue, false)) {
        this.opts.placeholder.current = startValue;
      }
    });
    watch(
      [
        () => this.opts.startValue.current,
        () => this.opts.endValue.current
      ],
      ([startValue, endValue]) => {
        if (this.opts.value.current && strict_equals(this.opts.value.current.start, startValue) && strict_equals(this.opts.value.current.end, endValue)) {
          return;
        }
        if (startValue && endValue) {
          this.#updateValue((prev2) => {
            if (strict_equals(prev2.start, startValue) && strict_equals(prev2.end, endValue)) {
              return prev2;
            }
            return { start: startValue, end: endValue };
          });
        } else if (this.opts.value.current && this.opts.value.current.start && this.opts.value.current.end) {
          this.opts.value.current.start = void 0;
          this.opts.value.current.end = void 0;
        }
      }
    );
  }
  #validationStatus = tag(
    user_derived(() => {
      const value = this.opts.value.current;
      if (strict_equals(value, void 0)) return false;
      if (strict_equals(value.start, void 0) || strict_equals(value.end, void 0)) return false;
      const msg = this.opts.validate.current?.({ start: value.start, end: value.end });
      if (msg) {
        return { reason: "custom", message: msg };
      }
      const minValue = this.opts.minValue.current;
      if (minValue && value.start && isBefore(value.start, minValue)) {
        return { reason: "min" };
      }
      const maxValue = this.opts.maxValue.current;
      if (maxValue && value.end && isBefore(maxValue, value.end) || maxValue && value.start && isBefore(maxValue, value.start)) {
        return { reason: "max" };
      }
      return false;
    }),
    "DateRangeFieldRootState.validationStatus"
  );
  get validationStatus() {
    return get(this.#validationStatus);
  }
  set validationStatus(value) {
    set(this.#validationStatus, value);
  }
  #isInvalid = tag(
    user_derived(() => {
      if (strict_equals(this.validationStatus, false)) return false;
      return true;
    }),
    "DateRangeFieldRootState.isInvalid"
  );
  get isInvalid() {
    return get(this.#isInvalid);
  }
  set isInvalid(value) {
    set(this.#isInvalid, value);
  }
  #updateValue(cb) {
    const value = this.opts.value.current;
    const newValue = cb(value);
    this.opts.value.current = newValue;
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "group",
      [dateRangeFieldAttrs.root]: "",
      "data-invalid": getDataInvalid(this.isInvalid),
      ...this.attachment
    })),
    "DateRangeFieldRootState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var DateRangeFieldLabelState = class _DateRangeFieldLabelState {
  static create(opts) {
    return new _DateRangeFieldLabelState(opts, DateRangeFieldRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.labelNode = v);
  }
  #onclick = () => {
    if (this.root.opts.disabled.current) return;
    const firstSegment = getFirstSegment(this.root.fieldNode);
    if (!firstSegment) return;
    firstSegment.focus();
  };
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "data-invalid": getDataInvalid(this.root.isInvalid),
      "data-disabled": getDataDisabled(this.root.opts.disabled.current),
      [dateRangeFieldAttrs.label]: "",
      onclick: this.#onclick,
      ...this.attachment
    })),
    "DateRangeFieldLabelState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var DateRangeFieldInputState = class {
  static create(opts, type) {
    const root18 = DateRangeFieldRootContext.get();
    const fieldState = DateFieldRootState.create(
      {
        value: strict_equals(type, "start") ? root18.opts.startValue : root18.opts.endValue,
        disabled: root18.opts.disabled,
        readonly: root18.opts.readonly,
        readonlySegments: root18.opts.readonlySegments,
        validate: box.with(() => void 0),
        minValue: root18.opts.minValue,
        maxValue: root18.opts.maxValue,
        hourCycle: root18.opts.hourCycle,
        locale: root18.opts.locale,
        hideTimeZone: root18.opts.hideTimeZone,
        required: root18.opts.required,
        granularity: root18.opts.granularity,
        placeholder: root18.opts.placeholder,
        onInvalid: root18.opts.onInvalid,
        errorMessageId: root18.opts.errorMessageId,
        isInvalidProp: box.with(() => root18.isInvalid)
      },
      root18
    );
    return new DateFieldInputState({ name: opts.name, id: opts.id, ref: opts.ref }, fieldState);
  }
};

// node_modules/bits-ui/dist/bits/date-range-field/components/date-range-field.svelte
Date_range_field[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-field/components/date-range-field.svelte";
var root_260 = add_locations(from_html(`<div><!></div>`), Date_range_field[FILENAME], [[137, 1]]);
function Date_range_field($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Date_range_field);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop3), placeholder = prop($$props, "placeholder", 15), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop3), disabled = prop($$props, "disabled", 3, false), readonly = prop($$props, "readonly", 3, false), required = prop($$props, "required", 3, false), hideTimeZone = prop($$props, "hideTimeZone", 3, false), validate = prop($$props, "validate", 3, noop3), onInvalid = prop($$props, "onInvalid", 3, noop3), readonlySegments = prop($$props, "readonlySegments", 19, () => []), onStartValueChange = prop($$props, "onStartValueChange", 3, noop3), onEndValueChange = prop($$props, "onEndValueChange", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "onValueChange",
      "placeholder",
      "onPlaceholderChange",
      "disabled",
      "readonly",
      "required",
      "hourCycle",
      "granularity",
      "locale",
      "hideTimeZone",
      "validate",
      "onInvalid",
      "maxValue",
      "minValue",
      "readonlySegments",
      "children",
      "child",
      "onStartValueChange",
      "onEndValueChange",
      "errorMessageId"
    ],
    "restProps"
  );
  let startValue = tag(state(proxy(value()?.start)), "startValue");
  let endValue = tag(state(proxy(value()?.end)), "endValue");
  function handleDefaultPlaceholder() {
    if (strict_equals(placeholder(), void 0, false)) return;
    const defaultPlaceholder = getDefaultDate({
      granularity: $$props.granularity,
      defaultValue: value()?.start
    });
    placeholder(defaultPlaceholder);
  }
  handleDefaultPlaceholder();
  watch.pre(() => placeholder(), () => {
    handleDefaultPlaceholder();
  });
  function handleDefaultValue() {
    if (strict_equals(value(), void 0, false)) return;
    const defaultValue = { start: void 0, end: void 0 };
    value(defaultValue);
  }
  handleDefaultValue();
  watch.pre(() => value(), () => {
    handleDefaultValue();
  });
  const rootState = DateRangeFieldRootState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => disabled()),
    readonly: box.with(() => readonly()),
    required: box.with(() => required()),
    hourCycle: box.with(() => $$props.hourCycle),
    granularity: box.with(() => $$props.granularity),
    locale: resolveLocaleProp(() => $$props.locale),
    hideTimeZone: box.with(() => hideTimeZone()),
    validate: box.with(() => validate()),
    maxValue: box.with(() => $$props.maxValue),
    minValue: box.with(() => $$props.minValue),
    placeholder: box.with(() => placeholder(), (v) => {
      placeholder(v);
      onPlaceholderChange()(v);
    }),
    readonlySegments: box.with(() => readonlySegments()),
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    startValue: box.with(() => get(startValue), (v) => {
      set(startValue, v, true);
      onStartValueChange()(v);
    }),
    endValue: box.with(() => get(endValue), (v) => {
      set(endValue, v, true);
      onEndValueChange()(v);
    }),
    onInvalid: box.with(() => onInvalid()),
    errorMessageId: box.with(() => $$props.errorMessageId)
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Date_range_field, 135, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_260();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Date_range_field, 138, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Date_range_field,
      134,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_range_field = hmr(Date_range_field, () => Date_range_field[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_range_field[HMR].source;
    set(Date_range_field[HMR].source, module.default[HMR].original);
  });
}
var date_range_field_default = Date_range_field;

// node_modules/bits-ui/dist/bits/date-range-field/components/date-range-field-input.svelte
Date_range_field_input[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-field/components/date-range-field-input.svelte";
var root_261 = add_locations(from_html(`<div><!></div>`), Date_range_field_input[FILENAME], [[38, 1]]);
var root8 = add_locations(from_html(`<!> <!>`, 1), Date_range_field_input[FILENAME], []);
function Date_range_field_input($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Date_range_field_input);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), name = prop($$props, "name", 3, ""), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "name",
      "child",
      "children",
      "type"
    ],
    "restProps"
  );
  const inputState = DateRangeFieldInputState.create(
    {
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v) => ref(v)),
      name: box.with(() => name())
    },
    $$props.type
  );
  const mergedProps = tag(user_derived(() => mergeProps(restProps, inputState.props, { role: "presentation" })), "mergedProps");
  var fragment = root8();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => snippet(node_1, () => $$props.child, () => ({
          props: get(mergedProps),
          segments: inputState.root.segmentContents
        })),
        "render",
        Date_range_field_input,
        36,
        1
      );
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_261();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => ({ segments: inputState.root.segmentContents })), "render", Date_range_field_input, 39, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Date_range_field_input,
      35,
      0
    );
  }
  var node_3 = sibling(node, 2);
  add_svelte_meta(() => date_field_hidden_input_default(node_3, {}), "component", Date_range_field_input, 43, 0, { componentTag: "DateFieldHiddenInput" });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_range_field_input = hmr(Date_range_field_input, () => Date_range_field_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_range_field_input[HMR].source;
    set(Date_range_field_input[HMR].source, module.default[HMR].original);
  });
}
var date_range_field_input_default = Date_range_field_input;

// node_modules/bits-ui/dist/bits/date-range-field/components/date-range-field-label.svelte
Date_range_field_label[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-field/components/date-range-field-label.svelte";
var root_262 = add_locations(from_html(`<span><!></span>`), Date_range_field_label[FILENAME], [[31, 1]]);
function Date_range_field_label($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Date_range_field_label);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const labelState = DateRangeFieldLabelState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, labelState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Date_range_field_label, 29, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_262();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Date_range_field_label, 32, 2);
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Date_range_field_label,
      28,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_range_field_label = hmr(Date_range_field_label, () => Date_range_field_label[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_range_field_label[HMR].source;
    set(Date_range_field_label[HMR].source, module.default[HMR].original);
  });
}
var date_range_field_label_default = Date_range_field_label;

// node_modules/bits-ui/dist/bits/date-range-picker/exports.js
var exports_exports15 = {};
__export(exports_exports15, {
  Arrow: () => popover_arrow_default,
  Calendar: () => date_range_picker_calendar_default,
  Cell: () => range_calendar_cell_default,
  Close: () => popover_close_default,
  Content: () => date_picker_content_default,
  Day: () => range_calendar_day_default,
  Grid: () => calendar_grid_default,
  GridBody: () => calendar_grid_body_default,
  GridHead: () => calendar_grid_head_default,
  GridRow: () => calendar_grid_row_default,
  HeadCell: () => calendar_head_cell_default,
  Header: () => calendar_header_default,
  Heading: () => calendar_heading_default,
  Input: () => date_range_field_input_default,
  Label: () => date_range_field_label_default,
  MonthSelect: () => calendar_month_select_default,
  NextButton: () => calendar_next_button_default,
  PrevButton: () => calendar_prev_button_default,
  Root: () => date_range_picker_default,
  Segment: () => date_field_segment_default,
  Trigger: () => date_range_picker_trigger_default,
  YearSelect: () => calendar_year_select_default
});

// node_modules/bits-ui/dist/bits/date-range-picker/date-range-picker.svelte.js
var DateRangePickerRootContext = new Context("DateRangePicker.Root");
var DateRangePickerRootState = class _DateRangePickerRootState {
  static create(opts) {
    return DateRangePickerRootContext.set(new _DateRangePickerRootState(opts));
  }
  opts;
  constructor(opts) {
    this.opts = opts;
  }
};

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker.svelte
Date_range_picker[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker.svelte";
var root_314 = add_locations(from_html(`<div><!></div>`), Date_range_picker[FILENAME], [[218, 2]]);
function Date_range_picker($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Date_range_picker);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3), value = prop($$props, "value", 15), id = prop($$props, "id", 19, useId), ref = prop($$props, "ref", 15, null), onValueChange = prop($$props, "onValueChange", 3, noop3), placeholder = prop($$props, "placeholder", 15), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop3), isDateUnavailable = prop($$props, "isDateUnavailable", 3, () => false), onInvalid = prop($$props, "onInvalid", 3, noop3), disabled = prop($$props, "disabled", 3, false), readonly = prop($$props, "readonly", 3, false), readonlySegments = prop($$props, "readonlySegments", 19, () => []), hideTimeZone = prop($$props, "hideTimeZone", 3, false), required = prop($$props, "required", 3, false), calendarLabel = prop($$props, "calendarLabel", 3, "Event"), disableDaysOutsideMonth = prop($$props, "disableDaysOutsideMonth", 3, true), preventDeselect = prop($$props, "preventDeselect", 3, false), pagedNavigation = prop($$props, "pagedNavigation", 3, false), weekdayFormat = prop($$props, "weekdayFormat", 3, "narrow"), isDateDisabled = prop($$props, "isDateDisabled", 3, () => false), fixedWeeks = prop($$props, "fixedWeeks", 3, false), numberOfMonths = prop($$props, "numberOfMonths", 3, 1), closeOnRangeSelect = prop($$props, "closeOnRangeSelect", 3, true), onStartValueChange = prop($$props, "onStartValueChange", 3, noop3), onEndValueChange = prop($$props, "onEndValueChange", 3, noop3), validate = prop($$props, "validate", 3, noop3), excludeDisabled = prop($$props, "excludeDisabled", 3, false), monthFormat = prop($$props, "monthFormat", 3, "long"), yearFormat = prop($$props, "yearFormat", 3, "numeric"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "open",
      "onOpenChange",
      "onOpenChangeComplete",
      "value",
      "id",
      "ref",
      "onValueChange",
      "placeholder",
      "onPlaceholderChange",
      "isDateUnavailable",
      "onInvalid",
      "minValue",
      "maxValue",
      "disabled",
      "readonly",
      "granularity",
      "readonlySegments",
      "hourCycle",
      "locale",
      "hideTimeZone",
      "required",
      "calendarLabel",
      "disableDaysOutsideMonth",
      "preventDeselect",
      "pagedNavigation",
      "weekStartsOn",
      "weekdayFormat",
      "isDateDisabled",
      "fixedWeeks",
      "numberOfMonths",
      "closeOnRangeSelect",
      "onStartValueChange",
      "onEndValueChange",
      "validate",
      "errorMessageId",
      "minDays",
      "maxDays",
      "excludeDisabled",
      "child",
      "children",
      "monthFormat",
      "yearFormat"
    ],
    "restProps"
  );
  let startValue = tag(state(proxy(value()?.start)), "startValue");
  let endValue = tag(state(proxy(value()?.end)), "endValue");
  function handleDefaultValue() {
    if (strict_equals(value(), void 0, false)) return;
    value({ start: void 0, end: void 0 });
  }
  handleDefaultValue();
  watch.pre(() => value(), () => {
    handleDefaultValue();
  });
  const defaultPlaceholder = getDefaultDate({
    granularity: $$props.granularity,
    defaultValue: value()?.start
  });
  function handleDefaultPlaceholder() {
    if (strict_equals(placeholder(), void 0, false)) return;
    placeholder(defaultPlaceholder);
  }
  handleDefaultPlaceholder();
  watch.pre(() => placeholder(), () => {
    handleDefaultPlaceholder();
  });
  function onRangeSelect() {
    if (closeOnRangeSelect()) {
      open(false);
    }
  }
  const pickerRootState = DateRangePickerRootState.create({
    open: box.with(() => open(), (v) => {
      open(v);
      onOpenChange()(v);
    }),
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    placeholder: box.with(() => placeholder(), (v) => {
      placeholder(v);
      onPlaceholderChange()(v);
    }),
    isDateUnavailable: box.with(() => isDateUnavailable()),
    minValue: box.with(() => $$props.minValue),
    maxValue: box.with(() => $$props.maxValue),
    minDays: box.with(() => $$props.minDays),
    maxDays: box.with(() => $$props.maxDays),
    disabled: box.with(() => disabled()),
    readonly: box.with(() => readonly()),
    granularity: box.with(() => $$props.granularity),
    readonlySegments: box.with(() => readonlySegments()),
    hourCycle: box.with(() => $$props.hourCycle),
    locale: resolveLocaleProp(() => $$props.locale),
    hideTimeZone: box.with(() => hideTimeZone()),
    required: box.with(() => required()),
    calendarLabel: box.with(() => calendarLabel()),
    disableDaysOutsideMonth: box.with(() => disableDaysOutsideMonth()),
    preventDeselect: box.with(() => preventDeselect()),
    pagedNavigation: box.with(() => pagedNavigation()),
    weekStartsOn: box.with(() => $$props.weekStartsOn),
    weekdayFormat: box.with(() => weekdayFormat()),
    isDateDisabled: box.with(() => isDateDisabled()),
    fixedWeeks: box.with(() => fixedWeeks()),
    numberOfMonths: box.with(() => numberOfMonths()),
    excludeDisabled: box.with(() => excludeDisabled()),
    onRangeSelect: box.with(() => onRangeSelect),
    startValue: box.with(() => get(startValue), (v) => {
      set(startValue, v, true);
      onStartValueChange()(v);
    }),
    endValue: box.with(() => get(endValue), (v) => {
      set(endValue, v, true);
      onEndValueChange()(v);
    }),
    monthFormat: box.with(() => monthFormat()),
    yearFormat: box.with(() => yearFormat()),
    defaultPlaceholder
  });
  PopoverRootState.create({
    open: pickerRootState.opts.open,
    onOpenChangeComplete: box.with(() => onOpenChangeComplete())
  });
  const fieldRootState = DateRangeFieldRootState.create({
    value: pickerRootState.opts.value,
    disabled: pickerRootState.opts.disabled,
    readonly: pickerRootState.opts.readonly,
    readonlySegments: pickerRootState.opts.readonlySegments,
    validate: box.with(() => validate()),
    minValue: pickerRootState.opts.minValue,
    maxValue: pickerRootState.opts.maxValue,
    granularity: pickerRootState.opts.granularity,
    hideTimeZone: pickerRootState.opts.hideTimeZone,
    hourCycle: pickerRootState.opts.hourCycle,
    locale: pickerRootState.opts.locale,
    required: pickerRootState.opts.required,
    placeholder: pickerRootState.opts.placeholder,
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    startValue: pickerRootState.opts.startValue,
    endValue: pickerRootState.opts.endValue,
    onInvalid: box.with(() => onInvalid()),
    errorMessageId: box.with(() => $$props.errorMessageId)
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, fieldRootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => floating_layer_default(node, {
      children: wrap_snippet(Date_range_picker, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        {
          var consequent = ($$anchor3) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            add_svelte_meta(() => snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Date_range_picker, 216, 2);
            append($$anchor3, fragment_2);
          };
          var alternate = ($$anchor3) => {
            var div = root_314();
            attribute_effect(div, () => ({ ...get(mergedProps) }));
            var node_3 = child(div);
            add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop), "render", Date_range_picker, 219, 3);
            reset(div);
            append($$anchor3, div);
          };
          add_svelte_meta(
            () => if_block(node_1, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            }),
            "if",
            Date_range_picker,
            215,
            1
          );
        }
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }),
    "component",
    Date_range_picker,
    214,
    0,
    { componentTag: "FloatingLayer" }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_range_picker = hmr(Date_range_picker, () => Date_range_picker[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_range_picker[HMR].source;
    set(Date_range_picker[HMR].source, module.default[HMR].original);
  });
}
var date_range_picker_default = Date_range_picker;

// node_modules/bits-ui/dist/bits/range-calendar/range-calendar.svelte.js
var RangeCalendarCellContext = new Context("RangeCalendar.Cell");
var RangeCalendarRootState = class _RangeCalendarRootState {
  static create(opts) {
    return CalendarRootContext.set(new _RangeCalendarRootState(opts));
  }
  opts;
  attachment;
  #visibleMonths = tag(user_derived(() => this.months.map((month) => month.value)), "RangeCalendarRootState.visibleMonths");
  get visibleMonths() {
    return get(this.#visibleMonths);
  }
  set visibleMonths(value) {
    set(this.#visibleMonths, value);
  }
  #months = tag(state(proxy([])), "RangeCalendarRootState.months");
  get months() {
    return get(this.#months);
  }
  set months(value) {
    set(this.#months, value, true);
  }
  announcer;
  formatter;
  accessibleHeadingId = useId();
  #focusedValue = tag(state(void 0), "RangeCalendarRootState.focusedValue");
  get focusedValue() {
    return get(this.#focusedValue);
  }
  set focusedValue(value) {
    set(this.#focusedValue, value, true);
  }
  lastPressedDateValue = void 0;
  domContext;
  #weekdays = tag(
    user_derived(() => {
      return getWeekdays({
        months: this.months,
        formatter: this.formatter,
        weekdayFormat: this.opts.weekdayFormat.current
      });
    }),
    "RangeCalendarRootState.weekdays"
  );
  get weekdays() {
    return get(this.#weekdays);
  }
  set weekdays(value) {
    set(this.#weekdays, value);
  }
  #isStartInvalid = tag(
    user_derived(() => {
      if (!this.opts.startValue.current) return false;
      return this.isDateUnavailable(this.opts.startValue.current) || this.isDateDisabled(this.opts.startValue.current);
    }),
    "RangeCalendarRootState.isStartInvalid"
  );
  get isStartInvalid() {
    return get(this.#isStartInvalid);
  }
  set isStartInvalid(value) {
    set(this.#isStartInvalid, value);
  }
  #isEndInvalid = tag(
    user_derived(() => {
      if (!this.opts.endValue.current) return false;
      return this.isDateUnavailable(this.opts.endValue.current) || this.isDateDisabled(this.opts.endValue.current);
    }),
    "RangeCalendarRootState.isEndInvalid"
  );
  get isEndInvalid() {
    return get(this.#isEndInvalid);
  }
  set isEndInvalid(value) {
    set(this.#isEndInvalid, value);
  }
  #isInvalid = tag(
    user_derived(() => {
      if (this.isStartInvalid || this.isEndInvalid) return true;
      if (this.opts.endValue.current && this.opts.startValue.current && isBefore(this.opts.endValue.current, this.opts.startValue.current)) return true;
      return false;
    }),
    "RangeCalendarRootState.isInvalid"
  );
  get isInvalid() {
    return get(this.#isInvalid);
  }
  set isInvalid(value) {
    set(this.#isInvalid, value);
  }
  #isNextButtonDisabled = tag(
    user_derived(() => {
      return getIsNextButtonDisabled({
        maxValue: this.opts.maxValue.current,
        months: this.months,
        disabled: this.opts.disabled.current
      });
    }),
    "RangeCalendarRootState.isNextButtonDisabled"
  );
  get isNextButtonDisabled() {
    return get(this.#isNextButtonDisabled);
  }
  set isNextButtonDisabled(value) {
    set(this.#isNextButtonDisabled, value);
  }
  #isPrevButtonDisabled = tag(
    user_derived(() => {
      return getIsPrevButtonDisabled({
        minValue: this.opts.minValue.current,
        months: this.months,
        disabled: this.opts.disabled.current
      });
    }),
    "RangeCalendarRootState.isPrevButtonDisabled"
  );
  get isPrevButtonDisabled() {
    return get(this.#isPrevButtonDisabled);
  }
  set isPrevButtonDisabled(value) {
    set(this.#isPrevButtonDisabled, value);
  }
  #headingValue = tag(
    user_derived(() => {
      this.opts.monthFormat.current;
      this.opts.yearFormat.current;
      return getCalendarHeadingValue({
        months: this.months,
        formatter: this.formatter,
        locale: this.opts.locale.current
      });
    }),
    "RangeCalendarRootState.headingValue"
  );
  get headingValue() {
    return get(this.#headingValue);
  }
  set headingValue(value) {
    set(this.#headingValue, value);
  }
  #fullCalendarLabel = tag(user_derived(() => `${this.opts.calendarLabel.current} ${this.headingValue}`), "RangeCalendarRootState.fullCalendarLabel");
  get fullCalendarLabel() {
    return get(this.#fullCalendarLabel);
  }
  set fullCalendarLabel(value) {
    set(this.#fullCalendarLabel, value);
  }
  #highlightedRange = tag(
    user_derived(() => {
      if (this.opts.startValue.current && this.opts.endValue.current) return null;
      if (!this.opts.startValue.current || !this.focusedValue) return null;
      const isStartBeforeFocused = isBefore(this.opts.startValue.current, this.focusedValue);
      const start = isStartBeforeFocused ? this.opts.startValue.current : this.focusedValue;
      const end = isStartBeforeFocused ? this.focusedValue : this.opts.startValue.current;
      const range = { start, end };
      if ($14e0f24ef4ac5c92$export$ea39ec197993aef0(start.add({ days: 1 }), end) || $14e0f24ef4ac5c92$export$ea39ec197993aef0(start, end)) {
        return range;
      }
      const isValid = areAllDaysBetweenValid(start, end, this.isDateUnavailable, this.isDateDisabled);
      if (isValid) return range;
      return null;
    }),
    "RangeCalendarRootState.highlightedRange"
  );
  get highlightedRange() {
    return get(this.#highlightedRange);
  }
  set highlightedRange(value) {
    set(this.#highlightedRange, value);
  }
  #initialPlaceholderYear = tag(user_derived(() => untrack(() => this.opts.placeholder.current.year)), "RangeCalendarRootState.initialPlaceholderYear");
  get initialPlaceholderYear() {
    return get(this.#initialPlaceholderYear);
  }
  set initialPlaceholderYear(value) {
    set(this.#initialPlaceholderYear, value);
  }
  #defaultYears = tag(
    user_derived(() => {
      return getDefaultYears({
        minValue: this.opts.minValue.current,
        maxValue: this.opts.maxValue.current,
        placeholderYear: this.initialPlaceholderYear
      });
    }),
    "RangeCalendarRootState.defaultYears"
  );
  get defaultYears() {
    return get(this.#defaultYears);
  }
  set defaultYears(value) {
    set(this.#defaultYears, value);
  }
  constructor(opts) {
    this.opts = opts;
    this.attachment = attachRef(opts.ref);
    this.domContext = new DOMContext(opts.ref);
    this.announcer = getAnnouncer(null);
    this.formatter = createFormatter({
      initialLocale: this.opts.locale.current,
      monthFormat: this.opts.monthFormat,
      yearFormat: this.opts.yearFormat
    });
    this.months = createMonths({
      dateObj: this.opts.placeholder.current,
      weekStartsOn: this.opts.weekStartsOn.current,
      locale: this.opts.locale.current,
      fixedWeeks: this.opts.fixedWeeks.current,
      numberOfMonths: this.opts.numberOfMonths.current
    });
    user_pre_effect(() => {
      if (strict_equals(this.formatter.getLocale(), this.opts.locale.current)) return;
      this.formatter.setLocale(this.opts.locale.current);
    });
    onMount(() => {
      this.announcer = getAnnouncer(this.domContext.getDocument());
    });
    useMonthViewPlaceholderSync({
      placeholder: this.opts.placeholder,
      getVisibleMonths: () => this.visibleMonths,
      weekStartsOn: this.opts.weekStartsOn,
      locale: this.opts.locale,
      fixedWeeks: this.opts.fixedWeeks,
      numberOfMonths: this.opts.numberOfMonths,
      setMonths: this.setMonths
    });
    useMonthViewOptionsSync({
      fixedWeeks: this.opts.fixedWeeks,
      locale: this.opts.locale,
      numberOfMonths: this.opts.numberOfMonths,
      placeholder: this.opts.placeholder,
      setMonths: this.setMonths,
      weekStartsOn: this.opts.weekStartsOn
    });
    user_effect(() => {
      const node = this.domContext.getElementById(this.accessibleHeadingId);
      if (!node) return;
      node.textContent = this.fullCalendarLabel;
    });
    watch(() => this.opts.value.current, (value) => {
      if (value.start && value.end) {
        this.opts.startValue.current = value.start;
        this.opts.endValue.current = value.end;
      } else if (value.start) {
        this.opts.startValue.current = value.start;
        this.opts.endValue.current = void 0;
      } else if (strict_equals(value.start, void 0) && strict_equals(value.end, void 0)) {
        this.opts.startValue.current = void 0;
        this.opts.endValue.current = void 0;
      }
    });
    watch(() => this.opts.value.current, (value) => {
      const startValue = value.start;
      if (startValue && strict_equals(this.opts.placeholder.current, startValue, false)) {
        this.opts.placeholder.current = startValue;
      }
    });
    watch(
      [
        () => this.opts.startValue.current,
        () => this.opts.endValue.current,
        () => this.opts.excludeDisabled.current
      ],
      ([startValue, endValue, excludeDisabled]) => {
        if (!excludeDisabled || !startValue || !endValue) return;
        if (this.#hasDisabledDatesInRange(startValue, endValue)) {
          this.#setStartValue(void 0);
          this.#setEndValue(void 0);
          this.#announceEmpty();
        }
      }
    );
    watch(
      [
        () => this.opts.startValue.current,
        () => this.opts.endValue.current
      ],
      ([startValue, endValue]) => {
        if (this.opts.value.current && strict_equals(this.opts.value.current.start, startValue) && strict_equals(this.opts.value.current.end, endValue)) {
          return;
        }
        if (startValue && endValue) {
          this.#updateValue((prev2) => {
            if (strict_equals(prev2.start, startValue) && strict_equals(prev2.end, endValue)) {
              return prev2;
            }
            if (isBefore(endValue, startValue)) {
              const start = startValue;
              const end = endValue;
              this.#setStartValue(end);
              this.#setEndValue(start);
              if (!this.#isRangeValid(endValue, startValue)) {
                this.#setStartValue(startValue);
                this.#setEndValue(void 0);
                return { start: startValue, end: void 0 };
              }
              return { start: endValue, end: startValue };
            } else {
              if (!this.#isRangeValid(startValue, endValue)) {
                this.#setStartValue(endValue);
                this.#setEndValue(void 0);
                return { start: endValue, end: void 0 };
              }
              return { start: startValue, end: endValue };
            }
          });
        } else if (this.opts.value.current && this.opts.value.current.start && this.opts.value.current.end) {
          this.opts.value.current.start = void 0;
          this.opts.value.current.end = void 0;
        }
      }
    );
    this.shiftFocus = this.shiftFocus.bind(this);
    this.handleCellClick = this.handleCellClick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
    this.nextPage = this.nextPage.bind(this);
    this.prevPage = this.prevPage.bind(this);
    this.nextYear = this.nextYear.bind(this);
    this.prevYear = this.prevYear.bind(this);
    this.setYear = this.setYear.bind(this);
    this.setMonth = this.setMonth.bind(this);
    this.isDateDisabled = this.isDateDisabled.bind(this);
    this.isDateUnavailable = this.isDateUnavailable.bind(this);
    this.isOutsideVisibleMonths = this.isOutsideVisibleMonths.bind(this);
    this.isSelected = this.isSelected.bind(this);
    useEnsureNonDisabledPlaceholder({
      placeholder: opts.placeholder,
      defaultPlaceholder: opts.defaultPlaceholder,
      isDateDisabled: opts.isDateDisabled,
      maxValue: opts.maxValue,
      minValue: opts.minValue,
      ref: opts.ref
    });
  }
  #updateValue(cb) {
    const value = this.opts.value.current;
    const newValue = cb(value);
    this.opts.value.current = newValue;
    if (newValue.start && newValue.end) {
      this.opts.onRangeSelect?.current?.();
    }
  }
  #setStartValue(value) {
    this.opts.startValue.current = value;
    this.#updateValue((prev2) => ({ ...prev2, start: value }));
  }
  #setEndValue(value) {
    this.opts.endValue.current = value;
    this.#updateValue((prev2) => ({ ...prev2, end: value }));
  }
  setMonths = (months) => {
    this.months = months;
  };
  isOutsideVisibleMonths(date) {
    return !this.visibleMonths.some((month) => $14e0f24ef4ac5c92$export$a18c89cbd24170ff(date, month));
  }
  isDateDisabled(date) {
    if (this.opts.isDateDisabled.current(date) || this.opts.disabled.current) return true;
    const minValue = this.opts.minValue.current;
    const maxValue = this.opts.maxValue.current;
    if (minValue && isBefore(date, minValue)) return true;
    if (maxValue && isAfter(date, maxValue)) return true;
    return false;
  }
  isDateUnavailable(date) {
    if (this.opts.isDateUnavailable.current(date)) return true;
    return false;
  }
  isSelectionStart(date) {
    if (!this.opts.startValue.current) return false;
    return $14e0f24ef4ac5c92$export$ea39ec197993aef0(date, this.opts.startValue.current);
  }
  isSelectionEnd(date) {
    if (!this.opts.endValue.current) return false;
    return $14e0f24ef4ac5c92$export$ea39ec197993aef0(date, this.opts.endValue.current);
  }
  isSelected(date) {
    if (this.opts.startValue.current && $14e0f24ef4ac5c92$export$ea39ec197993aef0(this.opts.startValue.current, date)) return true;
    if (this.opts.endValue.current && $14e0f24ef4ac5c92$export$ea39ec197993aef0(this.opts.endValue.current, date)) return true;
    if (this.opts.startValue.current && this.opts.endValue.current) {
      return isBetweenInclusive(date, this.opts.startValue.current, this.opts.endValue.current);
    }
    return false;
  }
  #isRangeValid(start, end) {
    const orderedStart = isBefore(end, start) ? end : start;
    const orderedEnd = isBefore(end, start) ? start : end;
    const startDate = orderedStart.toDate($14e0f24ef4ac5c92$export$aa8b41735afcabd2());
    const endDate = orderedEnd.toDate($14e0f24ef4ac5c92$export$aa8b41735afcabd2());
    const timeDifference = endDate.getTime() - startDate.getTime();
    const daysDifference = Math.floor(timeDifference / (1e3 * 60 * 60 * 24));
    const daysInRange = daysDifference + 1;
    if (this.opts.minDays.current && daysInRange < this.opts.minDays.current) return false;
    if (this.opts.maxDays.current && daysInRange > this.opts.maxDays.current) return false;
    if (this.opts.excludeDisabled.current && this.#hasDisabledDatesInRange(orderedStart, orderedEnd)) {
      return false;
    }
    return true;
  }
  shiftFocus(node, add) {
    return shiftCalendarFocus({
      node,
      add,
      placeholder: this.opts.placeholder,
      calendarNode: this.opts.ref.current,
      isPrevButtonDisabled: this.isPrevButtonDisabled,
      isNextButtonDisabled: this.isNextButtonDisabled,
      months: this.months,
      numberOfMonths: this.opts.numberOfMonths.current
    });
  }
  #announceEmpty() {
    this.announcer.announce("Selected date is now empty.", "polite");
  }
  #announceSelectedDate(date) {
    this.announcer.announce(`Selected Date: ${this.formatter.selectedDate(date, false)}`, "polite");
  }
  #announceSelectedRange(start, end) {
    this.announcer.announce(`Selected Dates: ${this.formatter.selectedDate(start, false)} to ${this.formatter.selectedDate(end, false)}`, "polite");
  }
  handleCellClick(e, date) {
    if (this.isDateDisabled(date) || this.isDateUnavailable(date)) return;
    const prevLastPressedDate = this.lastPressedDateValue;
    this.lastPressedDateValue = date;
    if (this.opts.startValue.current && strict_equals(this.highlightedRange, null)) {
      if ($14e0f24ef4ac5c92$export$ea39ec197993aef0(this.opts.startValue.current, date) && !this.opts.preventDeselect.current && !this.opts.endValue.current) {
        this.#setStartValue(void 0);
        this.opts.placeholder.current = date;
        this.#announceEmpty();
        return;
      } else if (!this.opts.endValue.current) {
        e.preventDefault();
        if (prevLastPressedDate && $14e0f24ef4ac5c92$export$ea39ec197993aef0(prevLastPressedDate, date)) {
          this.#setStartValue(date);
          this.#announceSelectedDate(date);
        }
      }
    }
    if (this.opts.startValue.current && this.opts.endValue.current && $14e0f24ef4ac5c92$export$ea39ec197993aef0(this.opts.endValue.current, date) && !this.opts.preventDeselect.current) {
      this.#setStartValue(void 0);
      this.#setEndValue(void 0);
      this.opts.placeholder.current = date;
      this.#announceEmpty();
      return;
    }
    if (!this.opts.startValue.current) {
      this.#announceSelectedDate(date);
      this.#setStartValue(date);
    } else if (!this.opts.endValue.current) {
      const startDate = this.opts.startValue.current;
      const endDate = date;
      const orderedStart = isBefore(endDate, startDate) ? endDate : startDate;
      const orderedEnd = isBefore(endDate, startDate) ? startDate : endDate;
      if (!this.#isRangeValid(orderedStart, orderedEnd)) {
        this.#setStartValue(date);
        this.#setEndValue(void 0);
        this.#announceSelectedDate(date);
      } else {
        if (isBefore(endDate, startDate)) {
          this.#setStartValue(endDate);
          this.#setEndValue(startDate);
          this.#announceSelectedRange(endDate, startDate);
        } else {
          this.#setEndValue(date);
          this.#announceSelectedRange(this.opts.startValue.current, date);
        }
      }
    } else if (this.opts.endValue.current && this.opts.startValue.current) {
      this.#setEndValue(void 0);
      this.#announceSelectedDate(date);
      this.#setStartValue(date);
    }
  }
  onkeydown(event) {
    return handleCalendarKeydown({
      event,
      handleCellClick: this.handleCellClick,
      placeholderValue: this.opts.placeholder.current,
      shiftFocus: this.shiftFocus
    });
  }
  /**
   * Navigates to the next page of the calendar.
   */
  nextPage() {
    handleCalendarNextPage({
      fixedWeeks: this.opts.fixedWeeks.current,
      locale: this.opts.locale.current,
      numberOfMonths: this.opts.numberOfMonths.current,
      pagedNavigation: this.opts.pagedNavigation.current,
      setMonths: this.setMonths,
      setPlaceholder: (date) => this.opts.placeholder.current = date,
      weekStartsOn: this.opts.weekStartsOn.current,
      months: this.months
    });
  }
  /**
   * Navigates to the previous page of the calendar.
   */
  prevPage() {
    handleCalendarPrevPage({
      fixedWeeks: this.opts.fixedWeeks.current,
      locale: this.opts.locale.current,
      numberOfMonths: this.opts.numberOfMonths.current,
      pagedNavigation: this.opts.pagedNavigation.current,
      setMonths: this.setMonths,
      setPlaceholder: (date) => this.opts.placeholder.current = date,
      weekStartsOn: this.opts.weekStartsOn.current,
      months: this.months
    });
  }
  nextYear() {
    this.opts.placeholder.current = this.opts.placeholder.current.add({ years: 1 });
  }
  prevYear() {
    this.opts.placeholder.current = this.opts.placeholder.current.subtract({ years: 1 });
  }
  setYear(year) {
    this.opts.placeholder.current = this.opts.placeholder.current.set({ year });
  }
  setMonth(month) {
    this.opts.placeholder.current = this.opts.placeholder.current.set({ month });
  }
  getBitsAttr = (part) => {
    return calendarAttrs.getAttr(part, "range-calendar");
  };
  #snippetProps = tag(user_derived(() => ({ months: this.months, weekdays: this.weekdays })), "RangeCalendarRootState.snippetProps");
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
  #props = tag(
    user_derived(() => ({
      ...getCalendarElementProps({
        fullCalendarLabel: this.fullCalendarLabel,
        id: this.opts.id.current,
        isInvalid: this.isInvalid,
        disabled: this.opts.disabled.current,
        readonly: this.opts.readonly.current
      }),
      [this.getBitsAttr("root")]: "",
      onkeydown: this.onkeydown,
      ...this.attachment
    })),
    "RangeCalendarRootState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
  #hasDisabledDatesInRange(start, end) {
    for (let date = start; isBefore(date, end) || $14e0f24ef4ac5c92$export$ea39ec197993aef0(date, end); date = date.add({ days: 1 })) {
      if (this.isDateDisabled(date)) return true;
    }
    return false;
  }
};
var RangeCalendarCellState = class _RangeCalendarCellState {
  static create(opts) {
    return RangeCalendarCellContext.set(new _RangeCalendarCellState(opts, CalendarRootContext.get()));
  }
  opts;
  root;
  attachment;
  #cellDate = tag(user_derived(() => toDate(this.opts.date.current)), "RangeCalendarCellState.cellDate");
  get cellDate() {
    return get(this.#cellDate);
  }
  set cellDate(value) {
    set(this.#cellDate, value);
  }
  #isOutsideMonth = tag(user_derived(() => !$14e0f24ef4ac5c92$export$a18c89cbd24170ff(this.opts.date.current, this.opts.month.current)), "RangeCalendarCellState.isOutsideMonth");
  get isOutsideMonth() {
    return get(this.#isOutsideMonth);
  }
  set isOutsideMonth(value) {
    set(this.#isOutsideMonth, value);
  }
  #isDisabled = tag(user_derived(() => this.root.isDateDisabled(this.opts.date.current) || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current), "RangeCalendarCellState.isDisabled");
  get isDisabled() {
    return get(this.#isDisabled);
  }
  set isDisabled(value) {
    set(this.#isDisabled, value);
  }
  #isUnavailable = tag(user_derived(() => this.root.opts.isDateUnavailable.current(this.opts.date.current)), "RangeCalendarCellState.isUnavailable");
  get isUnavailable() {
    return get(this.#isUnavailable);
  }
  set isUnavailable(value) {
    set(this.#isUnavailable, value);
  }
  #isDateToday = tag(user_derived(() => $14e0f24ef4ac5c92$export$629b0a497aa65267(this.opts.date.current, $14e0f24ef4ac5c92$export$aa8b41735afcabd2())), "RangeCalendarCellState.isDateToday");
  get isDateToday() {
    return get(this.#isDateToday);
  }
  set isDateToday(value) {
    set(this.#isDateToday, value);
  }
  #isOutsideVisibleMonths = tag(user_derived(() => this.root.isOutsideVisibleMonths(this.opts.date.current)), "RangeCalendarCellState.isOutsideVisibleMonths");
  get isOutsideVisibleMonths() {
    return get(this.#isOutsideVisibleMonths);
  }
  set isOutsideVisibleMonths(value) {
    set(this.#isOutsideVisibleMonths, value);
  }
  #isFocusedDate = tag(user_derived(() => $14e0f24ef4ac5c92$export$ea39ec197993aef0(this.opts.date.current, this.root.opts.placeholder.current)), "RangeCalendarCellState.isFocusedDate");
  get isFocusedDate() {
    return get(this.#isFocusedDate);
  }
  set isFocusedDate(value) {
    set(this.#isFocusedDate, value);
  }
  #isSelectedDate = tag(user_derived(() => this.root.isSelected(this.opts.date.current)), "RangeCalendarCellState.isSelectedDate");
  get isSelectedDate() {
    return get(this.#isSelectedDate);
  }
  set isSelectedDate(value) {
    set(this.#isSelectedDate, value);
  }
  #isSelectionStart = tag(user_derived(() => this.root.isSelectionStart(this.opts.date.current)), "RangeCalendarCellState.isSelectionStart");
  get isSelectionStart() {
    return get(this.#isSelectionStart);
  }
  set isSelectionStart(value) {
    set(this.#isSelectionStart, value);
  }
  #isRangeStart = tag(user_derived(() => this.root.isSelectionStart(this.opts.date.current)), "RangeCalendarCellState.isRangeStart");
  get isRangeStart() {
    return get(this.#isRangeStart);
  }
  set isRangeStart(value) {
    set(this.#isRangeStart, value);
  }
  #isRangeEnd = tag(
    user_derived(() => {
      if (!this.root.opts.endValue.current) return this.root.isSelectionStart(this.opts.date.current);
      return this.root.isSelectionEnd(this.opts.date.current);
    }),
    "RangeCalendarCellState.isRangeEnd"
  );
  get isRangeEnd() {
    return get(this.#isRangeEnd);
  }
  set isRangeEnd(value) {
    set(this.#isRangeEnd, value);
  }
  #isRangeMiddle = tag(user_derived(() => this.isSelectionMiddle), "RangeCalendarCellState.isRangeMiddle");
  get isRangeMiddle() {
    return get(this.#isRangeMiddle);
  }
  set isRangeMiddle(value) {
    set(this.#isRangeMiddle, value);
  }
  #isSelectionMiddle = tag(
    user_derived(() => {
      return this.isSelectedDate && !this.isSelectionStart && !this.isSelectionEnd;
    }),
    "RangeCalendarCellState.isSelectionMiddle"
  );
  get isSelectionMiddle() {
    return get(this.#isSelectionMiddle);
  }
  set isSelectionMiddle(value) {
    set(this.#isSelectionMiddle, value);
  }
  #isSelectionEnd = tag(user_derived(() => this.root.isSelectionEnd(this.opts.date.current)), "RangeCalendarCellState.isSelectionEnd");
  get isSelectionEnd() {
    return get(this.#isSelectionEnd);
  }
  set isSelectionEnd(value) {
    set(this.#isSelectionEnd, value);
  }
  #isHighlighted = tag(
    user_derived(() => this.root.highlightedRange ? isBetweenInclusive(this.opts.date.current, this.root.highlightedRange.start, this.root.highlightedRange.end) : false),
    "RangeCalendarCellState.isHighlighted"
  );
  get isHighlighted() {
    return get(this.#isHighlighted);
  }
  set isHighlighted(value) {
    set(this.#isHighlighted, value);
  }
  #labelText = tag(
    user_derived(() => this.root.formatter.custom(this.cellDate, {
      weekday: "long",
      month: "long",
      day: "numeric",
      year: "numeric"
    })),
    "RangeCalendarCellState.labelText"
  );
  get labelText() {
    return get(this.#labelText);
  }
  set labelText(value) {
    set(this.#labelText, value);
  }
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
  }
  #snippetProps = tag(
    user_derived(() => ({
      disabled: this.isDisabled,
      unavailable: this.isUnavailable,
      selected: this.isSelectedDate
    })),
    "RangeCalendarCellState.snippetProps"
  );
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
  #ariaDisabled = tag(
    user_derived(() => {
      return this.isDisabled || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current || this.isUnavailable;
    }),
    "RangeCalendarCellState.ariaDisabled"
  );
  get ariaDisabled() {
    return get(this.#ariaDisabled);
  }
  set ariaDisabled(value) {
    set(this.#ariaDisabled, value);
  }
  #sharedDataAttrs = tag(
    user_derived(() => ({
      "data-unavailable": getDataUnavailable(this.isUnavailable),
      "data-today": this.isDateToday ? "" : void 0,
      "data-outside-month": this.isOutsideMonth ? "" : void 0,
      "data-outside-visible-months": this.isOutsideVisibleMonths ? "" : void 0,
      "data-focused": this.isFocusedDate ? "" : void 0,
      "data-selection-start": this.isSelectionStart ? "" : void 0,
      "data-selection-end": this.isSelectionEnd ? "" : void 0,
      "data-range-start": this.isRangeStart ? "" : void 0,
      "data-range-end": this.isRangeEnd ? "" : void 0,
      "data-range-middle": this.isRangeMiddle ? "" : void 0,
      "data-highlighted": this.isHighlighted ? "" : void 0,
      "data-selected": getDataSelected(this.isSelectedDate),
      "data-value": this.opts.date.current.toString(),
      "data-type": getDateValueType(this.opts.date.current),
      "data-disabled": getDataDisabled(this.isDisabled || this.isOutsideMonth && this.root.opts.disableDaysOutsideMonth.current)
    })),
    "RangeCalendarCellState.sharedDataAttrs"
  );
  get sharedDataAttrs() {
    return get(this.#sharedDataAttrs);
  }
  set sharedDataAttrs(value) {
    set(this.#sharedDataAttrs, value);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "gridcell",
      "aria-selected": getAriaSelected(this.isSelectedDate),
      "aria-disabled": getAriaDisabled(this.ariaDisabled),
      ...this.sharedDataAttrs,
      [this.root.getBitsAttr("cell")]: "",
      ...this.attachment
    })),
    "RangeCalendarCellState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var RangeCalendarDayState = class _RangeCalendarDayState {
  static create(opts) {
    return new _RangeCalendarDayState(opts, RangeCalendarCellContext.get());
  }
  opts;
  cell;
  attachment;
  constructor(opts, cell) {
    this.opts = opts;
    this.cell = cell;
    this.attachment = attachRef(opts.ref);
    this.onclick = this.onclick.bind(this);
    this.onmouseenter = this.onmouseenter.bind(this);
    this.onfocusin = this.onfocusin.bind(this);
  }
  #tabindex = tag(user_derived(() => this.cell.isOutsideMonth && this.cell.root.opts.disableDaysOutsideMonth.current || this.cell.isDisabled ? void 0 : this.cell.isFocusedDate ? 0 : -1), "RangeCalendarDayState.#tabindex");
  onclick(e) {
    if (this.cell.isDisabled) return;
    this.cell.root.handleCellClick(e, this.cell.opts.date.current);
  }
  onmouseenter(_) {
    if (this.cell.isDisabled) return;
    this.cell.root.focusedValue = this.cell.opts.date.current;
  }
  onfocusin(_) {
    if (this.cell.isDisabled) return;
    this.cell.root.focusedValue = this.cell.opts.date.current;
  }
  #snippetProps = tag(
    user_derived(() => ({
      disabled: this.cell.isDisabled,
      unavailable: this.cell.isUnavailable,
      selected: this.cell.isSelectedDate,
      day: `${this.cell.opts.date.current.day}`
    })),
    "RangeCalendarDayState.snippetProps"
  );
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "button",
      "aria-label": this.cell.labelText,
      "aria-disabled": getAriaDisabled(this.cell.ariaDisabled),
      ...this.cell.sharedDataAttrs,
      tabindex: get(this.#tabindex),
      [this.cell.root.getBitsAttr("day")]: "",
      "data-bits-day": "",
      onclick: this.onclick,
      onmouseenter: this.onmouseenter,
      onfocusin: this.onfocusin,
      ...this.attachment
    })),
    "RangeCalendarDayState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-calendar.svelte
Date_range_picker_calendar[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-calendar.svelte";
var root_263 = add_locations(from_html(`<div><!></div>`), Date_range_picker_calendar[FILENAME], [[60, 1]]);
function Date_range_picker_calendar($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Date_range_picker_calendar);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref"
    ],
    "restProps"
  );
  const dateRangePickerRootState = DateRangePickerRootContext.get();
  const rangeCalendarState = RangeCalendarRootState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    calendarLabel: dateRangePickerRootState.opts.calendarLabel,
    fixedWeeks: dateRangePickerRootState.opts.fixedWeeks,
    isDateDisabled: dateRangePickerRootState.opts.isDateDisabled,
    isDateUnavailable: dateRangePickerRootState.opts.isDateUnavailable,
    locale: dateRangePickerRootState.opts.locale,
    numberOfMonths: dateRangePickerRootState.opts.numberOfMonths,
    pagedNavigation: dateRangePickerRootState.opts.pagedNavigation,
    preventDeselect: dateRangePickerRootState.opts.preventDeselect,
    readonly: dateRangePickerRootState.opts.readonly,
    weekStartsOn: dateRangePickerRootState.opts.weekStartsOn,
    weekdayFormat: dateRangePickerRootState.opts.weekdayFormat,
    disabled: dateRangePickerRootState.opts.disabled,
    disableDaysOutsideMonth: dateRangePickerRootState.opts.disableDaysOutsideMonth,
    maxValue: dateRangePickerRootState.opts.maxValue,
    minValue: dateRangePickerRootState.opts.minValue,
    placeholder: dateRangePickerRootState.opts.placeholder,
    value: dateRangePickerRootState.opts.value,
    excludeDisabled: dateRangePickerRootState.opts.excludeDisabled,
    onRangeSelect: dateRangePickerRootState.opts.onRangeSelect,
    startValue: dateRangePickerRootState.opts.startValue,
    endValue: dateRangePickerRootState.opts.endValue,
    defaultPlaceholder: dateRangePickerRootState.opts.defaultPlaceholder,
    minDays: dateRangePickerRootState.opts.minDays,
    maxDays: dateRangePickerRootState.opts.maxDays,
    monthFormat: dateRangePickerRootState.opts.monthFormat,
    yearFormat: dateRangePickerRootState.opts.yearFormat
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rangeCalendarState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => ({
          props: get(mergedProps),
          ...rangeCalendarState.snippetProps
        }));
        add_svelte_meta(() => snippet(node_1, () => $$props.child, () => get($0)), "render", Date_range_picker_calendar, 58, 1);
      }
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_263();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => rangeCalendarState.snippetProps), "render", Date_range_picker_calendar, 61, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Date_range_picker_calendar,
      57,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_range_picker_calendar = hmr(Date_range_picker_calendar, () => Date_range_picker_calendar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_range_picker_calendar[HMR].source;
    set(Date_range_picker_calendar[HMR].source, module.default[HMR].original);
  });
}
var date_range_picker_calendar_default = Date_range_picker_calendar;

// node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-trigger.svelte
Date_range_picker_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/date-range-picker/components/date-range-picker-trigger.svelte";
function Date_range_picker_trigger($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Date_range_picker_trigger);
  var $$ownership_validator = create_ownership_validator($$props);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "ref", "onkeydown"], "restProps");
  function onKeydown(e) {
    if (isSegmentNavigationKey(e.key)) {
      const currNode = e.currentTarget;
      const dateFieldInputNode = currNode.closest(dateRangeFieldAttrs.selector("root"));
      if (!dateFieldInputNode) return;
      handleSegmentNavigation(e, dateFieldInputNode);
    }
  }
  const mergedProps = tag(user_derived(() => mergeProps({ onkeydown: $$props.onkeydown }, { onkeydown: onKeydown })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    $$ownership_validator.binding("ref", popover_trigger_default, ref);
    add_svelte_meta(
      () => popover_trigger_default(node, spread_props(() => restProps, { "data-segment": "trigger" }, () => get(mergedProps), {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        }
      })),
      "component",
      Date_range_picker_trigger,
      27,
      0,
      { componentTag: "PopoverTrigger" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Date_range_picker_trigger = hmr(Date_range_picker_trigger, () => Date_range_picker_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Date_range_picker_trigger[HMR].source;
    set(Date_range_picker_trigger[HMR].source, module.default[HMR].original);
  });
}
var date_range_picker_trigger_default = Date_range_picker_trigger;

// node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-cell.svelte
Range_calendar_cell[FILENAME] = "node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-cell.svelte";
var root_264 = add_locations(from_html(`<td><!></td>`), Range_calendar_cell[FILENAME], [[35, 1]]);
function Range_calendar_cell($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Range_calendar_cell);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "date",
      "month"
    ],
    "restProps"
  );
  const cellState = RangeCalendarCellState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    date: box.with(() => $$props.date),
    month: box.with(() => $$props.month)
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, cellState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => ({ props: get(mergedProps), ...cellState.snippetProps }));
        add_svelte_meta(() => snippet(node_1, () => $$props.child, () => get($0)), "render", Range_calendar_cell, 33, 1);
      }
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var td = root_264();
      attribute_effect(td, () => ({ ...get(mergedProps) }));
      var node_2 = child(td);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => cellState.snippetProps), "render", Range_calendar_cell, 36, 2);
      reset(td);
      append($$anchor2, td);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Range_calendar_cell,
      32,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Range_calendar_cell = hmr(Range_calendar_cell, () => Range_calendar_cell[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Range_calendar_cell[HMR].source;
    set(Range_calendar_cell[HMR].source, module.default[HMR].original);
  });
}
var range_calendar_cell_default = Range_calendar_cell;

// node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-day.svelte
Range_calendar_day[FILENAME] = "node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar-day.svelte";
var root_265 = add_locations(from_html(`<div><!></div>`), Range_calendar_day[FILENAME], [[31, 1]]);
function Range_calendar_day($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Range_calendar_day);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref"
    ],
    "restProps"
  );
  const dayState = RangeCalendarDayState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, dayState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => ({ props: get(mergedProps), ...dayState.snippetProps }));
        add_svelte_meta(() => snippet(node_1, () => $$props.child, () => get($0)), "render", Range_calendar_day, 29, 1);
      }
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2) => {
      var div = root_265();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop, () => dayState.snippetProps), "render", Range_calendar_day, 33, 3);
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, dayState.cell.opts.date.current.day));
          append($$anchor3, text2);
        };
        add_svelte_meta(
          () => if_block(node_2, ($$render) => {
            if ($$props.children) $$render(consequent_1);
            else $$render(alternate, false);
          }),
          "if",
          Range_calendar_day,
          32,
          2
        );
      }
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate_1, false);
      }),
      "if",
      Range_calendar_day,
      28,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Range_calendar_day = hmr(Range_calendar_day, () => Range_calendar_day[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Range_calendar_day[HMR].source;
    set(Range_calendar_day[HMR].source, module.default[HMR].original);
  });
}
var range_calendar_day_default = Range_calendar_day;

// node_modules/bits-ui/dist/bits/dialog/exports.js
var exports_exports16 = {};
__export(exports_exports16, {
  Close: () => dialog_close_default,
  Content: () => dialog_content_default,
  Description: () => dialog_description_default,
  Overlay: () => dialog_overlay_default,
  Portal: () => portal_default,
  Root: () => dialog_default,
  Title: () => dialog_title_default,
  Trigger: () => dialog_trigger_default
});

// node_modules/bits-ui/dist/bits/dialog/components/dialog.svelte
Dialog[FILENAME] = "node_modules/bits-ui/dist/bits/dialog/components/dialog.svelte";
function Dialog($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Dialog);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3);
  DialogRootState.create({
    variant: box.with(() => "dialog"),
    open: box.with(() => open(), (v) => {
      open(v);
      onOpenChange()(v);
    }),
    onOpenChangeComplete: box.with(() => onOpenChangeComplete())
  });
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop), "render", Dialog, 27, 0);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dialog = hmr(Dialog, () => Dialog[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dialog[HMR].source;
    set(Dialog[HMR].source, module.default[HMR].original);
  });
}
var dialog_default = Dialog;

// node_modules/bits-ui/dist/bits/dialog/components/dialog-close.svelte
Dialog_close[FILENAME] = "node_modules/bits-ui/dist/bits/dialog/components/dialog-close.svelte";
var root_266 = add_locations(from_html(`<button><!></button>`), Dialog_close[FILENAME], [[34, 1]]);
function Dialog_close($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Dialog_close);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "disabled"
    ],
    "restProps"
  );
  const closeState = DialogCloseState.create({
    variant: box.with(() => "close"),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => Boolean(disabled()))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, closeState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Dialog_close, 32, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_266();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Dialog_close, 35, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Dialog_close,
      31,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dialog_close = hmr(Dialog_close, () => Dialog_close[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dialog_close[HMR].source;
    set(Dialog_close[HMR].source, module.default[HMR].original);
  });
}
var dialog_close_default = Dialog_close;

// node_modules/bits-ui/dist/bits/dialog/components/dialog-content.svelte
Dialog_content[FILENAME] = "node_modules/bits-ui/dist/bits/dialog/components/dialog-content.svelte";
var root_62 = add_locations(from_html(`<!> <!>`, 1), Dialog_content[FILENAME], []);
var root_82 = add_locations(from_html(`<!> <div><!></div>`, 1), Dialog_content[FILENAME], [[102, 8]]);
function Dialog_content($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Dialog_content);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), onOpenAutoFocus = prop($$props, "onOpenAutoFocus", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), trapFocus = prop($$props, "trapFocus", 3, true), preventScroll = prop($$props, "preventScroll", 3, true), restoreScrollDelay = prop($$props, "restoreScrollDelay", 3, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "children",
      "child",
      "ref",
      "forceMount",
      "onCloseAutoFocus",
      "onOpenAutoFocus",
      "onEscapeKeydown",
      "onInteractOutside",
      "trapFocus",
      "preventScroll",
      "restoreScrollDelay"
    ],
    "restProps"
  );
  const contentState = DialogContentState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    const presence = wrap_snippet(Dialog_content, function($$anchor2) {
      validate_snippet_args(...arguments);
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const focusScope = wrap_snippet(Dialog_content, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let focusScopeProps = () => $$arg0?.().props;
          focusScopeProps();
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          add_svelte_meta(
            () => escape_layer_default(node_2, spread_props(() => get(mergedProps), {
              get enabled() {
                return contentState.root.opts.open.current;
              },
              get ref() {
                return contentState.opts.ref;
              },
              onEscapeKeydown: (e) => {
                onEscapeKeydown()(e);
                if (e.defaultPrevented) return;
                contentState.root.handleClose();
              },
              children: wrap_snippet(Dialog_content, ($$anchor4, $$slotProps) => {
                var fragment_3 = comment();
                var node_3 = first_child(fragment_3);
                add_svelte_meta(
                  () => dismissible_layer_default(node_3, spread_props(() => get(mergedProps), {
                    get ref() {
                      return contentState.opts.ref;
                    },
                    get enabled() {
                      return contentState.root.opts.open.current;
                    },
                    onInteractOutside: (e) => {
                      onInteractOutside()(e);
                      if (e.defaultPrevented) return;
                      contentState.root.handleClose();
                    },
                    children: wrap_snippet(Dialog_content, ($$anchor5, $$slotProps2) => {
                      var fragment_4 = comment();
                      var node_4 = first_child(fragment_4);
                      add_svelte_meta(
                        () => text_selection_layer_default(node_4, spread_props(() => get(mergedProps), {
                          get ref() {
                            return contentState.opts.ref;
                          },
                          get enabled() {
                            return contentState.root.opts.open.current;
                          },
                          children: wrap_snippet(Dialog_content, ($$anchor6, $$slotProps3) => {
                            var fragment_5 = comment();
                            var node_5 = first_child(fragment_5);
                            {
                              var consequent_1 = ($$anchor7) => {
                                var fragment_6 = root_62();
                                var node_6 = first_child(fragment_6);
                                {
                                  var consequent = ($$anchor8) => {
                                    var fragment_7 = comment();
                                    var node_7 = first_child(fragment_7);
                                    add_svelte_meta(
                                      () => scroll_lock_default(node_7, {
                                        get preventScroll() {
                                          return preventScroll();
                                        },
                                        get restoreScrollDelay() {
                                          return restoreScrollDelay();
                                        }
                                      }),
                                      "component",
                                      Dialog_content,
                                      94,
                                      9,
                                      { componentTag: "ScrollLock" }
                                    );
                                    append($$anchor8, fragment_7);
                                  };
                                  add_svelte_meta(
                                    () => if_block(node_6, ($$render) => {
                                      if (contentState.root.opts.open.current) $$render(consequent);
                                    }),
                                    "if",
                                    Dialog_content,
                                    93,
                                    8
                                  );
                                }
                                var node_8 = sibling(node_6, 2);
                                {
                                  let $03 = user_derived(() => ({
                                    props: mergeProps(get(mergedProps), focusScopeProps()),
                                    ...contentState.snippetProps
                                  }));
                                  add_svelte_meta(() => snippet(node_8, () => $$props.child, () => get($03)), "render", Dialog_content, 96, 8);
                                }
                                append($$anchor7, fragment_6);
                              };
                              var alternate = ($$anchor7) => {
                                var fragment_8 = root_82();
                                var node_9 = first_child(fragment_8);
                                add_svelte_meta(
                                  () => scroll_lock_default(node_9, {
                                    get preventScroll() {
                                      return preventScroll();
                                    }
                                  }),
                                  "component",
                                  Dialog_content,
                                  101,
                                  8,
                                  { componentTag: "ScrollLock" }
                                );
                                var div = sibling(node_9, 2);
                                attribute_effect(div, ($03) => ({ ...$03 }), [() => mergeProps(get(mergedProps), focusScopeProps())]);
                                var node_10 = child(div);
                                add_svelte_meta(() => snippet(node_10, () => $$props.children ?? noop), "render", Dialog_content, 103, 9);
                                reset(div);
                                append($$anchor7, fragment_8);
                              };
                              add_svelte_meta(
                                () => if_block(node_5, ($$render) => {
                                  if ($$props.child) $$render(consequent_1);
                                  else $$render(alternate, false);
                                }),
                                "if",
                                Dialog_content,
                                92,
                                7
                              );
                            }
                            append($$anchor6, fragment_5);
                          }),
                          $$slots: { default: true }
                        })),
                        "component",
                        Dialog_content,
                        87,
                        6,
                        { componentTag: "TextSelectionLayer" }
                      );
                      append($$anchor5, fragment_4);
                    }),
                    $$slots: { default: true }
                  })),
                  "component",
                  Dialog_content,
                  77,
                  5,
                  { componentTag: "DismissibleLayer" }
                );
                append($$anchor4, fragment_3);
              }),
              $$slots: { default: true }
            })),
            "component",
            Dialog_content,
            67,
            4,
            { componentTag: "EscapeLayer" }
          );
          append($$anchor3, fragment_2);
        });
        let $02 = user_derived(() => shouldEnableFocusTrap({
          forceMount: forceMount(),
          present: contentState.root.opts.open.current,
          open: contentState.root.opts.open.current
        }));
        add_svelte_meta(
          () => focus_scope_default(node_1, {
            get ref() {
              return contentState.opts.ref;
            },
            loop: true,
            get trapFocus() {
              return trapFocus();
            },
            get enabled() {
              return get($02);
            },
            get onOpenAutoFocus() {
              return onOpenAutoFocus();
            },
            onCloseAutoFocus: (e) => {
              onCloseAutoFocus()(e);
              if (e.defaultPrevented) return;
              afterSleep(1, () => contentState.root.triggerNode?.focus());
            },
            focusScope,
            $$slots: { focusScope: true }
          }),
          "component",
          Dialog_content,
          50,
          2,
          { componentTag: "FocusScope" }
        );
      }
      append($$anchor2, fragment_1);
    });
    let $0 = user_derived(() => contentState.root.opts.open.current || forceMount());
    add_svelte_meta(
      () => presence_layer_default(node, spread_props(() => get(mergedProps), {
        get forceMount() {
          return forceMount();
        },
        get open() {
          return get($0);
        },
        get ref() {
          return contentState.opts.ref;
        },
        presence,
        $$slots: { presence: true }
      })),
      "component",
      Dialog_content,
      43,
      0,
      { componentTag: "PresenceLayer" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dialog_content = hmr(Dialog_content, () => Dialog_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dialog_content[HMR].source;
    set(Dialog_content[HMR].source, module.default[HMR].original);
  });
}
var dialog_content_default = Dialog_content;

// node_modules/bits-ui/dist/bits/dropdown-menu/exports.js
var exports_exports17 = {};
__export(exports_exports17, {
  Arrow: () => menu_arrow_default,
  CheckboxGroup: () => menu_checkbox_group_default,
  CheckboxItem: () => menu_checkbox_item_default,
  Content: () => dropdown_menu_content_default,
  ContentStatic: () => dropdown_menu_content_static_default,
  Group: () => menu_group_default,
  GroupHeading: () => menu_group_heading_default,
  Item: () => menu_item_default,
  Portal: () => portal_default,
  RadioGroup: () => menu_radio_group_default,
  RadioItem: () => menu_radio_item_default,
  Root: () => menu_default,
  Separator: () => menu_separator_default,
  Sub: () => menu_sub_default,
  SubContent: () => menu_sub_content_default,
  SubContentStatic: () => menu_sub_content_static_default,
  SubTrigger: () => menu_sub_trigger_default,
  Trigger: () => menu_trigger_default
});

// node_modules/bits-ui/dist/bits/menu/components/menu.svelte
Menu[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu.svelte";
function Menu($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Menu);
  let open = prop($$props, "open", 15, false), dir = prop($$props, "dir", 3, "ltr"), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3), variant = prop($$props, "_internal_variant", 3, "dropdown-menu");
  const root18 = MenuRootState.create({
    variant: box.with(() => variant()),
    dir: box.with(() => dir()),
    onClose: () => {
      open(false);
      onOpenChange()(false);
    }
  });
  MenuMenuState.create(
    {
      open: box.with(() => open(), (v) => {
        open(v);
        onOpenChange()(v);
      }),
      onOpenChangeComplete: box.with(() => onOpenChangeComplete())
    },
    root18
  );
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => floating_layer_default(node, {
      children: wrap_snippet(Menu, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop), "render", Menu, 44, 1);
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }),
    "component",
    Menu,
    43,
    0,
    { componentTag: "FloatingLayer" }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu = hmr(Menu, () => Menu[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu[HMR].source;
    set(Menu[HMR].source, module.default[HMR].original);
  });
}
var menu_default = Menu;

// node_modules/bits-ui/dist/bits/dropdown-menu/components/dropdown-menu-content.svelte
Dropdown_menu_content[FILENAME] = "node_modules/bits-ui/dist/bits/dropdown-menu/components/dropdown-menu-content.svelte";
var root_413 = add_locations(from_html(`<div><div><!></div></div>`), Dropdown_menu_content[FILENAME], [[79, 4, [[80, 5]]]]);
var root_99 = add_locations(from_html(`<div><div><!></div></div>`), Dropdown_menu_content[FILENAME], [[107, 4, [[108, 5]]]]);
function Dropdown_menu_content($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Dropdown_menu_content);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), trapFocus = prop($$props, "trapFocus", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "child",
      "children",
      "ref",
      "loop",
      "onInteractOutside",
      "onEscapeKeydown",
      "onCloseAutoFocus",
      "forceMount",
      "trapFocus"
    ],
    "restProps"
  );
  const contentState = MenuContentState.create({
    id: box.with(() => id()),
    loop: box.with(() => loop()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onCloseAutoFocus: box.with(() => onCloseAutoFocus())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  function handleInteractOutside(e) {
    contentState.handleInteractOutside(e);
    if (e.defaultPrevented) return;
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    if (e.target && e.target instanceof Element) {
      const subContentSelector = `[${contentState.parentMenu.root.getBitsAttr("sub-content")}]`;
      if (e.target.closest(subContentSelector)) return;
    }
    contentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Dropdown_menu_content, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0?.().props;
          props();
          let wrapperProps = () => $$arg0?.().wrapperProps;
          wrapperProps();
          var fragment_2 = comment();
          const finalProps = tag(user_derived(() => mergeProps(props(), { style: getFloatingContentCSSVars("dropdown-menu") })), "finalProps");
          get(finalProps);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              {
                let $0 = user_derived(() => ({
                  props: get(finalProps),
                  wrapperProps: wrapperProps(),
                  ...contentState.snippetProps
                }));
                add_svelte_meta(() => snippet(node_3, () => $$props.child, () => get($0)), "render", Dropdown_menu_content, 77, 4);
              }
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_413();
              attribute_effect(div, () => ({ ...wrapperProps() }));
              var div_1 = child(div);
              attribute_effect(div_1, () => ({ ...get(finalProps) }));
              var node_4 = child(div_1);
              add_svelte_meta(() => snippet(node_4, () => $$props.children ?? noop), "render", Dropdown_menu_content, 81, 6);
              reset(div_1);
              reset(div);
              append($$anchor4, div);
            };
            add_svelte_meta(
              () => if_block(node_2, ($$render) => {
                if ($$props.child) $$render(consequent);
                else $$render(alternate, false);
              }),
              "if",
              Dropdown_menu_content,
              76,
              3
            );
          }
          append($$anchor3, fragment_2);
        });
        add_svelte_meta(
          () => popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), () => contentState.popperProps, {
            get ref() {
              return contentState.opts.ref;
            },
            get enabled() {
              return contentState.parentMenu.opts.open.current;
            },
            onInteractOutside: handleInteractOutside,
            onEscapeKeydown: handleEscapeKeydown,
            get trapFocus() {
              return trapFocus();
            },
            get loop() {
              return loop();
            },
            forceMount: true,
            get id() {
              return id();
            },
            popper,
            $$slots: { popper: true }
          })),
          "component",
          Dropdown_menu_content,
          60,
          1,
          { componentTag: "PopperLayerForceMount" }
        );
      }
      append($$anchor2, fragment_1);
    };
    var alternate_2 = ($$anchor2) => {
      var fragment_4 = comment();
      var node_5 = first_child(fragment_4);
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_5 = comment();
          var node_6 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Dropdown_menu_content, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0?.().props;
              props();
              let wrapperProps = () => $$arg0?.().wrapperProps;
              wrapperProps();
              var fragment_6 = comment();
              const finalProps = tag(user_derived(() => mergeProps(props(), { style: getFloatingContentCSSVars("dropdown-menu") })), "finalProps");
              get(finalProps);
              var node_7 = first_child(fragment_6);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_8 = first_child(fragment_7);
                  {
                    let $0 = user_derived(() => ({
                      props: get(finalProps),
                      wrapperProps: wrapperProps(),
                      ...contentState.snippetProps
                    }));
                    add_svelte_meta(() => snippet(node_8, () => $$props.child, () => get($0)), "render", Dropdown_menu_content, 105, 4);
                  }
                  append($$anchor5, fragment_7);
                };
                var alternate_1 = ($$anchor5) => {
                  var div_2 = root_99();
                  attribute_effect(div_2, () => ({ ...wrapperProps() }));
                  var div_3 = child(div_2);
                  attribute_effect(div_3, () => ({ ...get(finalProps) }));
                  var node_9 = child(div_3);
                  add_svelte_meta(() => snippet(node_9, () => $$props.children ?? noop), "render", Dropdown_menu_content, 109, 6);
                  reset(div_3);
                  reset(div_2);
                  append($$anchor5, div_2);
                };
                add_svelte_meta(
                  () => if_block(node_7, ($$render) => {
                    if ($$props.child) $$render(consequent_2);
                    else $$render(alternate_1, false);
                  }),
                  "if",
                  Dropdown_menu_content,
                  104,
                  3
                );
              }
              append($$anchor4, fragment_6);
            });
            add_svelte_meta(
              () => popper_layer_default(node_6, spread_props(() => get(mergedProps), () => contentState.popperProps, {
                get ref() {
                  return contentState.opts.ref;
                },
                get open() {
                  return contentState.parentMenu.opts.open.current;
                },
                onInteractOutside: handleInteractOutside,
                onEscapeKeydown: handleEscapeKeydown,
                get trapFocus() {
                  return trapFocus();
                },
                get loop() {
                  return loop();
                },
                forceMount: false,
                get id() {
                  return id();
                },
                popper,
                $$slots: { popper: true }
              })),
              "component",
              Dropdown_menu_content,
              88,
              1,
              { componentTag: "PopperLayer" }
            );
          }
          append($$anchor3, fragment_5);
        };
        add_svelte_meta(
          () => if_block(
            node_5,
            ($$render) => {
              if (!forceMount()) $$render(consequent_3);
            },
            true
          ),
          "if",
          Dropdown_menu_content,
          87,
          0
        );
      }
      append($$anchor2, fragment_4);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (forceMount()) $$render(consequent_1);
        else $$render(alternate_2, false);
      }),
      "if",
      Dropdown_menu_content,
      59,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dropdown_menu_content = hmr(Dropdown_menu_content, () => Dropdown_menu_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dropdown_menu_content[HMR].source;
    set(Dropdown_menu_content[HMR].source, module.default[HMR].original);
  });
}
var dropdown_menu_content_default = Dropdown_menu_content;

// node_modules/bits-ui/dist/bits/dropdown-menu/components/dropdown-menu-content-static.svelte
Dropdown_menu_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/dropdown-menu/components/dropdown-menu-content-static.svelte";
var root_414 = add_locations(from_html(`<div><!></div>`), Dropdown_menu_content_static[FILENAME], [[73, 4]]);
var root_910 = add_locations(from_html(`<div><!></div>`), Dropdown_menu_content_static[FILENAME], [[100, 4]]);
function Dropdown_menu_content_static($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Dropdown_menu_content_static);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "child",
      "children",
      "ref",
      "loop",
      "onInteractOutside",
      "onEscapeKeydown",
      "onCloseAutoFocus",
      "forceMount"
    ],
    "restProps"
  );
  const contentState = MenuContentState.create({
    id: box.with(() => id()),
    loop: box.with(() => loop()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onCloseAutoFocus: box.with(() => onCloseAutoFocus())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  function handleInteractOutside(e) {
    contentState.handleInteractOutside(e);
    if (e.defaultPrevented) return;
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Dropdown_menu_content_static, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0?.().props;
          props();
          var fragment_2 = comment();
          const finalProps = tag(user_derived(() => mergeProps(props(), { style: getFloatingContentCSSVars("dropdown-menu") })), "finalProps");
          get(finalProps);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              {
                let $0 = user_derived(() => ({ props: get(finalProps), ...contentState.snippetProps }));
                add_svelte_meta(() => snippet(node_3, () => $$props.child, () => get($0)), "render", Dropdown_menu_content_static, 71, 4);
              }
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_414();
              attribute_effect(div, () => ({ ...get(finalProps) }));
              var node_4 = child(div);
              add_svelte_meta(() => snippet(node_4, () => $$props.children ?? noop), "render", Dropdown_menu_content_static, 74, 5);
              reset(div);
              append($$anchor4, div);
            };
            add_svelte_meta(
              () => if_block(node_2, ($$render) => {
                if ($$props.child) $$render(consequent);
                else $$render(alternate, false);
              }),
              "if",
              Dropdown_menu_content_static,
              70,
              3
            );
          }
          append($$anchor3, fragment_2);
        });
        add_svelte_meta(
          () => popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), () => contentState.popperProps, {
            get ref() {
              return contentState.opts.ref;
            },
            get enabled() {
              return contentState.parentMenu.opts.open.current;
            },
            onInteractOutside: handleInteractOutside,
            onEscapeKeydown: handleEscapeKeydown,
            trapFocus: true,
            get loop() {
              return loop();
            },
            forceMount: true,
            isStatic: true,
            get id() {
              return id();
            },
            popper,
            $$slots: { popper: true }
          })),
          "component",
          Dropdown_menu_content_static,
          53,
          1,
          { componentTag: "PopperLayerForceMount" }
        );
      }
      append($$anchor2, fragment_1);
    };
    var alternate_2 = ($$anchor2) => {
      var fragment_4 = comment();
      var node_5 = first_child(fragment_4);
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_5 = comment();
          var node_6 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Dropdown_menu_content_static, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0?.().props;
              props();
              var fragment_6 = comment();
              const finalProps = tag(user_derived(() => mergeProps(props(), { style: getFloatingContentCSSVars("dropdown-menu") })), "finalProps");
              get(finalProps);
              var node_7 = first_child(fragment_6);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_8 = first_child(fragment_7);
                  {
                    let $0 = user_derived(() => ({ props: get(finalProps), ...contentState.snippetProps }));
                    add_svelte_meta(() => snippet(node_8, () => $$props.child, () => get($0)), "render", Dropdown_menu_content_static, 98, 4);
                  }
                  append($$anchor5, fragment_7);
                };
                var alternate_1 = ($$anchor5) => {
                  var div_1 = root_910();
                  attribute_effect(div_1, () => ({ ...get(finalProps) }));
                  var node_9 = child(div_1);
                  add_svelte_meta(() => snippet(node_9, () => $$props.children ?? noop), "render", Dropdown_menu_content_static, 101, 5);
                  reset(div_1);
                  append($$anchor5, div_1);
                };
                add_svelte_meta(
                  () => if_block(node_7, ($$render) => {
                    if ($$props.child) $$render(consequent_2);
                    else $$render(alternate_1, false);
                  }),
                  "if",
                  Dropdown_menu_content_static,
                  97,
                  3
                );
              }
              append($$anchor4, fragment_6);
            });
            add_svelte_meta(
              () => popper_layer_default(node_6, spread_props(() => get(mergedProps), () => contentState.popperProps, {
                get ref() {
                  return contentState.opts.ref;
                },
                get open() {
                  return contentState.parentMenu.opts.open.current;
                },
                onInteractOutside: handleInteractOutside,
                onEscapeKeydown: handleEscapeKeydown,
                trapFocus: true,
                get loop() {
                  return loop();
                },
                forceMount: false,
                isStatic: true,
                get id() {
                  return id();
                },
                popper,
                $$slots: { popper: true }
              })),
              "component",
              Dropdown_menu_content_static,
              80,
              1,
              { componentTag: "PopperLayer" }
            );
          }
          append($$anchor3, fragment_5);
        };
        add_svelte_meta(
          () => if_block(
            node_5,
            ($$render) => {
              if (!forceMount()) $$render(consequent_3);
            },
            true
          ),
          "if",
          Dropdown_menu_content_static,
          79,
          0
        );
      }
      append($$anchor2, fragment_4);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (forceMount()) $$render(consequent_1);
        else $$render(alternate_2, false);
      }),
      "if",
      Dropdown_menu_content_static,
      52,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Dropdown_menu_content_static = hmr(Dropdown_menu_content_static, () => Dropdown_menu_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Dropdown_menu_content_static[HMR].source;
    set(Dropdown_menu_content_static[HMR].source, module.default[HMR].original);
  });
}
var dropdown_menu_content_static_default = Dropdown_menu_content_static;

// node_modules/bits-ui/dist/bits/menu/components/menu-trigger.svelte
Menu_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-trigger.svelte";
var root_315 = add_locations(from_html(`<button><!></button>`), Menu_trigger[FILENAME], [[36, 2]]);
function Menu_trigger($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menu_trigger);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), type = prop($$props, "type", 3, "button"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "children",
      "disabled",
      "type"
    ],
    "restProps"
  );
  const triggerState = DropdownMenuTriggerState.create({
    id: box.with(() => id()),
    disabled: box.with(() => disabled() ?? false),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, triggerState.props, { type: type() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => floating_layer_anchor_default(node, {
      get id() {
        return id();
      },
      get ref() {
        return triggerState.opts.ref;
      },
      children: wrap_snippet(Menu_trigger, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        {
          var consequent = ($$anchor3) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            add_svelte_meta(() => snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Menu_trigger, 34, 2);
            append($$anchor3, fragment_2);
          };
          var alternate = ($$anchor3) => {
            var button = root_315();
            attribute_effect(button, () => ({ ...get(mergedProps) }));
            var node_3 = child(button);
            add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop), "render", Menu_trigger, 37, 3);
            reset(button);
            append($$anchor3, button);
          };
          add_svelte_meta(
            () => if_block(node_1, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            }),
            "if",
            Menu_trigger,
            33,
            1
          );
        }
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }),
    "component",
    Menu_trigger,
    32,
    0,
    { componentTag: "FloatingLayerAnchor" }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_trigger = hmr(Menu_trigger, () => Menu_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_trigger[HMR].source;
    set(Menu_trigger[HMR].source, module.default[HMR].original);
  });
}
var menu_trigger_default = Menu_trigger;

// node_modules/bits-ui/dist/bits/label/exports.js
var exports_exports18 = {};
__export(exports_exports18, {
  Root: () => label_default
});

// node_modules/bits-ui/dist/bits/label/label.svelte.js
var labelAttrs = createBitsAttrs({ component: "label", parts: ["root"] });
var LabelRootState = class _LabelRootState {
  static create(opts) {
    return new _LabelRootState(opts);
  }
  opts;
  attachment;
  constructor(opts) {
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.onmousedown = this.onmousedown.bind(this);
  }
  onmousedown(e) {
    if (e.detail > 1) e.preventDefault();
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      [labelAttrs.root]: "",
      onmousedown: this.onmousedown,
      ...this.attachment
    })),
    "LabelRootState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};

// node_modules/bits-ui/dist/bits/label/components/label.svelte
Label[FILENAME] = "node_modules/bits-ui/dist/bits/label/components/label.svelte";
var root_267 = add_locations(from_html(`<label><!></label>`), Label[FILENAME], [[31, 1]]);
function Label($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Label);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "for"
    ],
    "restProps"
  );
  const rootState = LabelRootState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props, { for: $$props.for })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Label, 29, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var label = root_267();
      attribute_effect(label, () => ({ ...get(mergedProps), for: $$props.for }));
      var node_2 = child(label);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Label, 32, 2);
      reset(label);
      append($$anchor2, label);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Label,
      28,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Label = hmr(Label, () => Label[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Label[HMR].source;
    set(Label[HMR].source, module.default[HMR].original);
  });
}
var label_default = Label;

// node_modules/bits-ui/dist/bits/link-preview/exports.js
var exports_exports19 = {};
__export(exports_exports19, {
  Arrow: () => floating_layer_arrow_default,
  Content: () => link_preview_content_default,
  ContentStatic: () => link_preview_content_static_default,
  Portal: () => portal_default,
  Root: () => link_preview_default,
  Trigger: () => link_preview_trigger_default
});

// node_modules/bits-ui/dist/bits/link-preview/link-preview.svelte.js
var linkPreviewAttrs = createBitsAttrs({ component: "link-preview", parts: ["content", "trigger"] });
var LinkPreviewRootContext = new Context("LinkPreview.Root");
var LinkPreviewRootState = class _LinkPreviewRootState {
  static create(opts) {
    return LinkPreviewRootContext.set(new _LinkPreviewRootState(opts));
  }
  opts;
  #hasSelection = tag(state(false), "LinkPreviewRootState.hasSelection");
  get hasSelection() {
    return get(this.#hasSelection);
  }
  set hasSelection(value) {
    set(this.#hasSelection, value, true);
  }
  #isPointerDownOnContent = tag(state(false), "LinkPreviewRootState.isPointerDownOnContent");
  get isPointerDownOnContent() {
    return get(this.#isPointerDownOnContent);
  }
  set isPointerDownOnContent(value) {
    set(this.#isPointerDownOnContent, value, true);
  }
  #containsSelection = tag(state(false), "LinkPreviewRootState.containsSelection");
  get containsSelection() {
    return get(this.#containsSelection);
  }
  set containsSelection(value) {
    set(this.#containsSelection, value, true);
  }
  timeout = null;
  #contentNode = tag(state(null), "LinkPreviewRootState.contentNode");
  get contentNode() {
    return get(this.#contentNode);
  }
  set contentNode(value) {
    set(this.#contentNode, value, true);
  }
  #contentMounted = tag(state(false), "LinkPreviewRootState.contentMounted");
  get contentMounted() {
    return get(this.#contentMounted);
  }
  set contentMounted(value) {
    set(this.#contentMounted, value, true);
  }
  #triggerNode = tag(state(null), "LinkPreviewRootState.triggerNode");
  get triggerNode() {
    return get(this.#triggerNode);
  }
  set triggerNode(value) {
    set(this.#triggerNode, value, true);
  }
  isOpening = false;
  domContext = new DOMContext(() => null);
  constructor(opts) {
    this.opts = opts;
    new OpenChangeComplete({
      ref: box.with(() => this.contentNode),
      open: this.opts.open,
      onComplete: () => {
        this.opts.onOpenChangeComplete.current(this.opts.open.current);
      }
    });
    watch(() => this.opts.open.current, (isOpen) => {
      if (!isOpen) {
        this.hasSelection = false;
        return;
      }
      if (!this.domContext) return;
      const handlePointerUp = () => {
        this.containsSelection = false;
        this.isPointerDownOnContent = false;
        afterSleep(1, () => {
          const isSelection = strict_equals(this.domContext.getDocument().getSelection()?.toString(), "", false);
          if (isSelection) {
            this.hasSelection = true;
          } else {
            this.hasSelection = false;
          }
        });
      };
      const unsubListener = on(this.domContext.getDocument(), "pointerup", handlePointerUp);
      if (!this.contentNode) return;
      const tabCandidates = getTabbableCandidates(this.contentNode);
      for (const candidate of tabCandidates) {
        candidate.setAttribute("tabindex", "-1");
      }
      return () => {
        unsubListener();
        this.hasSelection = false;
        this.isPointerDownOnContent = false;
      };
    });
  }
  clearTimeout() {
    if (this.timeout) {
      this.domContext.clearTimeout(this.timeout);
      this.timeout = null;
    }
  }
  handleOpen() {
    this.clearTimeout();
    if (this.opts.open.current) return;
    this.isOpening = true;
    this.timeout = this.domContext.setTimeout(
      () => {
        if (this.isOpening) {
          this.opts.open.current = true;
          this.isOpening = false;
        }
      },
      this.opts.openDelay.current
    );
  }
  immediateClose() {
    this.clearTimeout();
    this.isOpening = false;
    this.opts.open.current = false;
  }
  handleClose() {
    this.isOpening = false;
    this.clearTimeout();
    if (!this.isPointerDownOnContent && !this.hasSelection) {
      this.timeout = this.domContext.setTimeout(
        () => {
          this.opts.open.current = false;
        },
        this.opts.closeDelay.current
      );
    }
  }
};
var LinkPreviewTriggerState = class _LinkPreviewTriggerState {
  static create(opts) {
    return new _LinkPreviewTriggerState(opts, LinkPreviewRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.triggerNode = v);
    this.root.domContext = new DOMContext(opts.ref);
    this.onpointerenter = this.onpointerenter.bind(this);
    this.onpointerleave = this.onpointerleave.bind(this);
    this.onfocus = this.onfocus.bind(this);
    this.onblur = this.onblur.bind(this);
  }
  onpointerenter(e) {
    if (isTouch(e)) return;
    this.root.handleOpen();
  }
  onpointerleave(e) {
    if (isTouch(e)) return;
    if (!this.root.contentMounted) {
      this.root.immediateClose();
    }
  }
  onfocus(e) {
    if (!isFocusVisible(e.currentTarget)) return;
    this.root.handleOpen();
  }
  onblur(_) {
    this.root.handleClose();
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "aria-haspopup": "dialog",
      "aria-expanded": getAriaExpanded(this.root.opts.open.current),
      "data-state": getDataOpenClosed(this.root.opts.open.current),
      "aria-controls": this.root.contentNode?.id,
      role: "button",
      [linkPreviewAttrs.trigger]: "",
      onpointerenter: this.onpointerenter,
      onfocus: this.onfocus,
      onblur: this.onblur,
      onpointerleave: this.onpointerleave,
      ...this.attachment
    })),
    "LinkPreviewTriggerState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var LinkPreviewContentState = class _LinkPreviewContentState {
  static create(opts) {
    return new _LinkPreviewContentState(opts, LinkPreviewRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.contentNode = v);
    this.root.domContext = new DOMContext(opts.ref);
    this.onpointerdown = this.onpointerdown.bind(this);
    this.onpointerenter = this.onpointerenter.bind(this);
    this.onfocusout = this.onfocusout.bind(this);
    new GraceArea({
      triggerNode: () => this.root.triggerNode,
      contentNode: () => this.opts.ref.current,
      enabled: () => this.root.opts.open.current,
      onPointerExit: () => {
        this.root.handleClose();
      }
    });
    onDestroyEffect(() => {
      this.root.clearTimeout();
    });
  }
  onpointerdown(e) {
    const target = e.target;
    if (!isElement2(target)) return;
    if (e.currentTarget.contains(target)) {
      this.root.containsSelection = true;
    }
    this.root.hasSelection = true;
    this.root.isPointerDownOnContent = true;
  }
  onpointerenter(e) {
    if (isTouch(e)) return;
    this.root.handleOpen();
  }
  onfocusout(e) {
    e.preventDefault();
  }
  onInteractOutside = (e) => {
    this.opts.onInteractOutside.current(e);
    if (e.defaultPrevented) return;
    this.root.handleClose();
  };
  onEscapeKeydown = (e) => {
    this.opts.onEscapeKeydown.current?.(e);
    if (e.defaultPrevented) return;
    this.root.handleClose();
  };
  onOpenAutoFocus = (e) => {
    e.preventDefault();
  };
  onCloseAutoFocus = (e) => {
    e.preventDefault();
  };
  #snippetProps = tag(user_derived(() => ({ open: this.root.opts.open.current })), "LinkPreviewContentState.snippetProps");
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      tabindex: -1,
      "data-state": getDataOpenClosed(this.root.opts.open.current),
      [linkPreviewAttrs.content]: "",
      onpointerdown: this.onpointerdown,
      onpointerenter: this.onpointerenter,
      onfocusout: this.onfocusout,
      ...this.attachment
    })),
    "LinkPreviewContentState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
  popperProps = {
    onInteractOutside: this.onInteractOutside,
    onEscapeKeydown: this.onEscapeKeydown,
    onOpenAutoFocus: this.onOpenAutoFocus,
    onCloseAutoFocus: this.onCloseAutoFocus
  };
};

// node_modules/bits-ui/dist/bits/link-preview/components/link-preview.svelte
Link_preview[FILENAME] = "node_modules/bits-ui/dist/bits/link-preview/components/link-preview.svelte";
function Link_preview($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Link_preview);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3), openDelay = prop($$props, "openDelay", 3, 700), closeDelay = prop($$props, "closeDelay", 3, 300);
  LinkPreviewRootState.create({
    open: box.with(() => open(), (v) => {
      open(v);
      onOpenChange()(v);
    }),
    openDelay: box.with(() => openDelay()),
    closeDelay: box.with(() => closeDelay()),
    onOpenChangeComplete: box.with(() => onOpenChangeComplete())
  });
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => component(node, () => components_exports.Root, ($$anchor2, FloatingLayer_Root) => {
      FloatingLayer_Root($$anchor2, {
        children: wrap_snippet(Link_preview, ($$anchor3, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop), "render", Link_preview, 32, 1);
          append($$anchor3, fragment_1);
        }),
        $$slots: { default: true }
      });
    }),
    "component",
    Link_preview,
    31,
    0,
    { componentTag: "FloatingLayer.Root" }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Link_preview = hmr(Link_preview, () => Link_preview[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Link_preview[HMR].source;
    set(Link_preview[HMR].source, module.default[HMR].original);
  });
}
var link_preview_default = Link_preview;

// node_modules/bits-ui/dist/bits/link-preview/components/link-preview-content.svelte
Link_preview_content[FILENAME] = "node_modules/bits-ui/dist/bits/link-preview/components/link-preview-content.svelte";
var root_415 = add_locations(from_html(`<div><div><!></div></div>`), Link_preview_content[FILENAME], [[76, 4, [[77, 5]]]]);
var root_911 = add_locations(from_html(`<div><div><!></div></div>`), Link_preview_content[FILENAME], [[103, 4, [[104, 5]]]]);
var root_7 = add_locations(from_html(`<!> <!>`, 1), Link_preview_content[FILENAME], []);
function Link_preview_content($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Link_preview_content);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), side = prop($$props, "side", 3, "top"), sideOffset = prop($$props, "sideOffset", 3, 0), align = prop($$props, "align", 3, "center"), avoidCollisions = prop($$props, "avoidCollisions", 3, true), arrowPadding = prop($$props, "arrowPadding", 3, 0), sticky = prop($$props, "sticky", 3, "partial"), hideWhenDetached = prop($$props, "hideWhenDetached", 3, false), collisionPadding = prop($$props, "collisionPadding", 3, 0), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "side",
      "sideOffset",
      "align",
      "avoidCollisions",
      "arrowPadding",
      "sticky",
      "hideWhenDetached",
      "collisionPadding",
      "onInteractOutside",
      "onEscapeKeydown",
      "forceMount"
    ],
    "restProps"
  );
  const contentState = LinkPreviewContentState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onInteractOutside: box.with(() => onInteractOutside()),
    onEscapeKeydown: box.with(() => onEscapeKeydown())
  });
  const floatingProps = tag(
    user_derived(() => ({
      side: side(),
      sideOffset: sideOffset(),
      align: align(),
      avoidCollisions: avoidCollisions(),
      arrowPadding: arrowPadding(),
      sticky: sticky(),
      hideWhenDetached: hideWhenDetached(),
      collisionPadding: collisionPadding()
    })),
    "floatingProps"
  );
  const mergedProps = tag(user_derived(() => mergeProps(restProps, get(floatingProps), contentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Link_preview_content, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0?.().props;
          props();
          let wrapperProps = () => $$arg0?.().wrapperProps;
          wrapperProps();
          var fragment_2 = comment();
          const mergedProps2 = tag(user_derived(() => mergeProps(props(), { style: getFloatingContentCSSVars("link-preview") })), "mergedProps");
          get(mergedProps2);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              {
                let $0 = user_derived(() => ({
                  props: get(mergedProps2),
                  wrapperProps: wrapperProps(),
                  ...contentState.snippetProps
                }));
                add_svelte_meta(() => snippet(node_3, () => $$props.child, () => get($0)), "render", Link_preview_content, 74, 4);
              }
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_415();
              attribute_effect(div, () => ({ ...wrapperProps() }));
              var div_1 = child(div);
              attribute_effect(div_1, () => ({ ...get(mergedProps2) }));
              var node_4 = child(div_1);
              add_svelte_meta(() => snippet(node_4, () => $$props.children ?? noop), "render", Link_preview_content, 78, 6);
              reset(div_1);
              reset(div);
              append($$anchor4, div);
            };
            add_svelte_meta(
              () => if_block(node_2, ($$render) => {
                if ($$props.child) $$render(consequent);
                else $$render(alternate, false);
              }),
              "if",
              Link_preview_content,
              73,
              3
            );
          }
          append($$anchor3, fragment_2);
        });
        add_svelte_meta(
          () => popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), () => contentState.popperProps, {
            get ref() {
              return contentState.opts.ref;
            },
            get enabled() {
              return contentState.root.opts.open.current;
            },
            get id() {
              return id();
            },
            trapFocus: false,
            loop: false,
            preventScroll: false,
            forceMount: true,
            popper,
            $$slots: { popper: true }
          })),
          "component",
          Link_preview_content,
          58,
          1,
          { componentTag: "PopperLayerForceMount" }
        );
      }
      append($$anchor2, fragment_1);
    };
    var alternate_2 = ($$anchor2) => {
      var fragment_4 = comment();
      var node_5 = first_child(fragment_4);
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_5 = comment();
          var node_6 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Link_preview_content, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0?.().props;
              props();
              let wrapperProps = () => $$arg0?.().wrapperProps;
              wrapperProps();
              var fragment_6 = root_7();
              const mergedProps2 = tag(user_derived(() => mergeProps(props(), { style: getFloatingContentCSSVars("link-preview") })), "mergedProps");
              get(mergedProps2);
              var node_7 = first_child(fragment_6);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_8 = first_child(fragment_7);
                  {
                    let $0 = user_derived(() => ({
                      props: get(mergedProps2),
                      wrapperProps: wrapperProps(),
                      ...contentState.snippetProps
                    }));
                    add_svelte_meta(() => snippet(node_8, () => $$props.child, () => get($0)), "render", Link_preview_content, 101, 4);
                  }
                  append($$anchor5, fragment_7);
                };
                var alternate_1 = ($$anchor5) => {
                  var div_2 = root_911();
                  attribute_effect(div_2, () => ({ ...wrapperProps() }));
                  var div_3 = child(div_2);
                  attribute_effect(div_3, () => ({ ...get(mergedProps2) }));
                  var node_9 = child(div_3);
                  add_svelte_meta(() => snippet(node_9, () => $$props.children ?? noop), "render", Link_preview_content, 105, 6);
                  reset(div_3);
                  reset(div_2);
                  append($$anchor5, div_2);
                };
                add_svelte_meta(
                  () => if_block(node_7, ($$render) => {
                    if ($$props.child) $$render(consequent_2);
                    else $$render(alternate_1, false);
                  }),
                  "if",
                  Link_preview_content,
                  100,
                  3
                );
              }
              var node_10 = sibling(node_7, 2);
              validate_binding("bind:mounted={contentState.root.contentMounted}", () => contentState.root, () => "contentMounted", 109, 12);
              add_svelte_meta(
                () => mounted_default(node_10, {
                  get mounted() {
                    return contentState.root.contentMounted;
                  },
                  set mounted($$value) {
                    contentState.root.contentMounted = $$value;
                  }
                }),
                "component",
                Link_preview_content,
                109,
                3,
                { componentTag: "Mounted" }
              );
              append($$anchor4, fragment_6);
            });
            add_svelte_meta(
              () => popper_layer_default(node_6, spread_props(() => get(mergedProps), () => contentState.popperProps, {
                get ref() {
                  return contentState.opts.ref;
                },
                get open() {
                  return contentState.root.opts.open.current;
                },
                get id() {
                  return id();
                },
                trapFocus: false,
                loop: false,
                preventScroll: false,
                forceMount: false,
                popper,
                $$slots: { popper: true }
              })),
              "component",
              Link_preview_content,
              85,
              1,
              { componentTag: "PopperLayer" }
            );
          }
          append($$anchor3, fragment_5);
        };
        add_svelte_meta(
          () => if_block(
            node_5,
            ($$render) => {
              if (!forceMount()) $$render(consequent_3);
            },
            true
          ),
          "if",
          Link_preview_content,
          84,
          0
        );
      }
      append($$anchor2, fragment_4);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (forceMount()) $$render(consequent_1);
        else $$render(alternate_2, false);
      }),
      "if",
      Link_preview_content,
      57,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Link_preview_content = hmr(Link_preview_content, () => Link_preview_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Link_preview_content[HMR].source;
    set(Link_preview_content[HMR].source, module.default[HMR].original);
  });
}
var link_preview_content_default = Link_preview_content;

// node_modules/bits-ui/dist/bits/link-preview/components/link-preview-trigger.svelte
Link_preview_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/link-preview/components/link-preview-trigger.svelte";
var root_316 = add_locations(from_html(`<a><!></a>`), Link_preview_trigger[FILENAME], [[33, 2]]);
function Link_preview_trigger($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Link_preview_trigger);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "child",
      "children"
    ],
    "restProps"
  );
  const triggerState = LinkPreviewTriggerState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, triggerState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => component(node, () => components_exports.Anchor, ($$anchor2, FloatingLayer_Anchor) => {
      FloatingLayer_Anchor($$anchor2, {
        get id() {
          return id();
        },
        get ref() {
          return triggerState.opts.ref;
        },
        children: wrap_snippet(Link_preview_trigger, ($$anchor3, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          {
            var consequent = ($$anchor4) => {
              var fragment_2 = comment();
              var node_2 = first_child(fragment_2);
              add_svelte_meta(() => snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Link_preview_trigger, 31, 2);
              append($$anchor4, fragment_2);
            };
            var alternate = ($$anchor4) => {
              var a2 = root_316();
              attribute_effect(a2, () => ({ ...get(mergedProps) }));
              var node_3 = child(a2);
              add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop), "render", Link_preview_trigger, 34, 3);
              reset(a2);
              append($$anchor4, a2);
            };
            add_svelte_meta(
              () => if_block(node_1, ($$render) => {
                if ($$props.child) $$render(consequent);
                else $$render(alternate, false);
              }),
              "if",
              Link_preview_trigger,
              30,
              1
            );
          }
          append($$anchor3, fragment_1);
        }),
        $$slots: { default: true }
      });
    }),
    "component",
    Link_preview_trigger,
    29,
    0,
    { componentTag: "FloatingLayer.Anchor" }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Link_preview_trigger = hmr(Link_preview_trigger, () => Link_preview_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Link_preview_trigger[HMR].source;
    set(Link_preview_trigger[HMR].source, module.default[HMR].original);
  });
}
var link_preview_trigger_default = Link_preview_trigger;

// node_modules/bits-ui/dist/bits/link-preview/components/link-preview-content-static.svelte
Link_preview_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/link-preview/components/link-preview-content-static.svelte";
var root_416 = add_locations(from_html(`<div><!></div>`), Link_preview_content_static[FILENAME], [[57, 4]]);
var root_912 = add_locations(from_html(`<div><!></div>`), Link_preview_content_static[FILENAME], [[83, 4]]);
function Link_preview_content_static($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Link_preview_content_static);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "onInteractOutside",
      "onEscapeKeydown",
      "forceMount"
    ],
    "restProps"
  );
  const contentState = LinkPreviewContentState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onInteractOutside: box.with(() => onInteractOutside()),
    onEscapeKeydown: box.with(() => onEscapeKeydown())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Link_preview_content_static, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0?.().props;
          props();
          var fragment_2 = comment();
          const mergedProps2 = tag(user_derived(() => mergeProps(props(), { style: getFloatingContentCSSVars("link-preview") })), "mergedProps");
          get(mergedProps2);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              {
                let $0 = user_derived(() => ({ props: get(mergedProps2), ...contentState.snippetProps }));
                add_svelte_meta(() => snippet(node_3, () => $$props.child, () => get($0)), "render", Link_preview_content_static, 55, 4);
              }
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_416();
              attribute_effect(div, () => ({ ...get(mergedProps2) }));
              var node_4 = child(div);
              add_svelte_meta(() => snippet(node_4, () => $$props.children ?? noop), "render", Link_preview_content_static, 58, 5);
              reset(div);
              append($$anchor4, div);
            };
            add_svelte_meta(
              () => if_block(node_2, ($$render) => {
                if ($$props.child) $$render(consequent);
                else $$render(alternate, false);
              }),
              "if",
              Link_preview_content_static,
              54,
              3
            );
          }
          append($$anchor3, fragment_2);
        });
        add_svelte_meta(
          () => popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), () => contentState.popperProps, {
            get ref() {
              return contentState.opts.ref;
            },
            get enabled() {
              return contentState.root.opts.open.current;
            },
            isStatic: true,
            get id() {
              return id();
            },
            trapFocus: false,
            loop: false,
            preventScroll: false,
            forceMount: true,
            popper,
            $$slots: { popper: true }
          })),
          "component",
          Link_preview_content_static,
          38,
          1,
          { componentTag: "PopperLayerForceMount" }
        );
      }
      append($$anchor2, fragment_1);
    };
    var alternate_2 = ($$anchor2) => {
      var fragment_4 = comment();
      var node_5 = first_child(fragment_4);
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_5 = comment();
          var node_6 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Link_preview_content_static, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0?.().props;
              props();
              var fragment_6 = comment();
              const mergedProps2 = tag(user_derived(() => mergeProps(props(), { style: getFloatingContentCSSVars("link-preview") })), "mergedProps");
              get(mergedProps2);
              var node_7 = first_child(fragment_6);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_8 = first_child(fragment_7);
                  {
                    let $0 = user_derived(() => ({ props: get(mergedProps2), ...contentState.snippetProps }));
                    add_svelte_meta(() => snippet(node_8, () => $$props.child, () => get($0)), "render", Link_preview_content_static, 81, 4);
                  }
                  append($$anchor5, fragment_7);
                };
                var alternate_1 = ($$anchor5) => {
                  var div_1 = root_912();
                  attribute_effect(div_1, () => ({ ...get(mergedProps2) }));
                  var node_9 = child(div_1);
                  add_svelte_meta(() => snippet(node_9, () => $$props.children ?? noop), "render", Link_preview_content_static, 84, 5);
                  reset(div_1);
                  append($$anchor5, div_1);
                };
                add_svelte_meta(
                  () => if_block(node_7, ($$render) => {
                    if ($$props.child) $$render(consequent_2);
                    else $$render(alternate_1, false);
                  }),
                  "if",
                  Link_preview_content_static,
                  80,
                  3
                );
              }
              append($$anchor4, fragment_6);
            });
            add_svelte_meta(
              () => popper_layer_default(node_6, spread_props(() => get(mergedProps), () => contentState.popperProps, {
                get ref() {
                  return contentState.opts.ref;
                },
                get open() {
                  return contentState.root.opts.open.current;
                },
                isStatic: true,
                get id() {
                  return id();
                },
                trapFocus: false,
                loop: false,
                preventScroll: false,
                forceMount: false,
                popper,
                $$slots: { popper: true }
              })),
              "component",
              Link_preview_content_static,
              64,
              1,
              { componentTag: "PopperLayer" }
            );
          }
          append($$anchor3, fragment_5);
        };
        add_svelte_meta(
          () => if_block(
            node_5,
            ($$render) => {
              if (!forceMount()) $$render(consequent_3);
            },
            true
          ),
          "if",
          Link_preview_content_static,
          63,
          0
        );
      }
      append($$anchor2, fragment_4);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (forceMount()) $$render(consequent_1);
        else $$render(alternate_2, false);
      }),
      "if",
      Link_preview_content_static,
      37,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Link_preview_content_static = hmr(Link_preview_content_static, () => Link_preview_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Link_preview_content_static[HMR].source;
    set(Link_preview_content_static[HMR].source, module.default[HMR].original);
  });
}
var link_preview_content_static_default = Link_preview_content_static;

// node_modules/bits-ui/dist/bits/menubar/exports.js
var exports_exports20 = {};
__export(exports_exports20, {
  Arrow: () => menu_arrow_default,
  CheckboxGroup: () => menu_checkbox_group_default,
  CheckboxItem: () => menu_checkbox_item_default,
  Content: () => menubar_content_default,
  ContentStatic: () => menubar_content_static_default,
  Group: () => menu_group_default,
  GroupHeading: () => menu_group_heading_default,
  Item: () => menu_item_default,
  Menu: () => menubar_menu_default,
  Portal: () => portal_default,
  RadioGroup: () => menu_radio_group_default,
  RadioItem: () => menu_radio_item_default,
  Root: () => menubar_default,
  Separator: () => menu_separator_default,
  Sub: () => menu_sub_default,
  SubContent: () => menu_sub_content_default,
  SubContentStatic: () => menu_sub_content_static_default,
  SubTrigger: () => menu_sub_trigger_default,
  Trigger: () => menubar_trigger_default
});

// node_modules/bits-ui/dist/bits/menubar/menubar.svelte.js
var menubarAttrs = createBitsAttrs({ component: "menubar", parts: ["root", "trigger", "content"] });
var MenubarRootContext = new Context("Menubar.Root");
var MenubarMenuContext = new Context("Menubar.Menu");
var MenubarRootState = class _MenubarRootState {
  static create(opts) {
    return MenubarRootContext.set(new _MenubarRootState(opts));
  }
  opts;
  rovingFocusGroup;
  attachment;
  #wasOpenedByKeyboard = tag(state(false), "MenubarRootState.wasOpenedByKeyboard");
  get wasOpenedByKeyboard() {
    return get(this.#wasOpenedByKeyboard);
  }
  set wasOpenedByKeyboard(value) {
    set(this.#wasOpenedByKeyboard, value, true);
  }
  #triggerIds = tag(state(proxy([])), "MenubarRootState.triggerIds");
  get triggerIds() {
    return get(this.#triggerIds);
  }
  set triggerIds(value) {
    set(this.#triggerIds, value, true);
  }
  valueToChangeHandler = /* @__PURE__ */ new Map();
  constructor(opts) {
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.rovingFocusGroup = new RovingFocusGroup({
      rootNode: this.opts.ref,
      candidateAttr: menubarAttrs.trigger,
      loop: this.opts.loop,
      orientation: box.with(() => "horizontal")
    });
  }
  /**
   * @param id - the id of the trigger to register
   * @returns - a function to de-register the trigger
   */
  registerTrigger = (id) => {
    this.triggerIds.push(id);
    return () => {
      this.triggerIds = this.triggerIds.filter((triggerId) => strict_equals(triggerId, id, false));
    };
  };
  /**
   * @param value - the value of the menu to register
   * @param contentId - the content id to associate with the value
   * @returns - a function to de-register the menu
   */
  registerMenu = (value, onOpenChange) => {
    this.valueToChangeHandler.set(value, onOpenChange);
    return () => {
      this.valueToChangeHandler.delete(value);
    };
  };
  updateValue = (value) => {
    const currValue = this.opts.value.current;
    const currHandler = this.valueToChangeHandler.get(currValue)?.current;
    const nextHandler = this.valueToChangeHandler.get(value)?.current;
    this.opts.value.current = value;
    if (currHandler && strict_equals(currValue, value, false)) {
      currHandler(false);
    }
    if (nextHandler) {
      nextHandler(true);
    }
  };
  getTriggers = () => {
    const node = this.opts.ref.current;
    if (!node) return [];
    return Array.from(node.querySelectorAll(menubarAttrs.selector("trigger")));
  };
  onMenuOpen = (id, triggerId) => {
    this.updateValue(id);
    this.rovingFocusGroup.setCurrentTabStopId(triggerId);
  };
  onMenuClose = () => {
    this.updateValue("");
  };
  onMenuToggle = (id) => {
    this.updateValue(this.opts.value.current ? "" : id);
  };
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "menubar",
      [menubarAttrs.root]: "",
      ...this.attachment
    })),
    "MenubarRootState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var MenubarMenuState = class _MenubarMenuState {
  static create(opts) {
    return MenubarMenuContext.set(new _MenubarMenuState(opts, MenubarRootContext.get()));
  }
  opts;
  root;
  #open = tag(user_derived(() => strict_equals(this.root.opts.value.current, this.opts.value.current)), "MenubarMenuState.open");
  get open() {
    return get(this.#open);
  }
  set open(value) {
    set(this.#open, value);
  }
  wasOpenedByKeyboard = false;
  #triggerNode = tag(state(null), "MenubarMenuState.triggerNode");
  get triggerNode() {
    return get(this.#triggerNode);
  }
  set triggerNode(value) {
    set(this.#triggerNode, value, true);
  }
  #triggerId = tag(user_derived(() => this.triggerNode?.id), "MenubarMenuState.triggerId");
  get triggerId() {
    return get(this.#triggerId);
  }
  set triggerId(value) {
    set(this.#triggerId, value);
  }
  #contentId = tag(user_derived(() => this.contentNode?.id), "MenubarMenuState.contentId");
  get contentId() {
    return get(this.#contentId);
  }
  set contentId(value) {
    set(this.#contentId, value);
  }
  #contentNode = tag(state(null), "MenubarMenuState.contentNode");
  get contentNode() {
    return get(this.#contentNode);
  }
  set contentNode(value) {
    set(this.#contentNode, value, true);
  }
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    watch(() => this.open, () => {
      if (!this.open) {
        this.wasOpenedByKeyboard = false;
      }
    });
    onMount(() => {
      return this.root.registerMenu(this.opts.value.current, opts.onOpenChange);
    });
  }
  getTriggerNode() {
    return this.triggerNode;
  }
  toggleMenu() {
    this.root.onMenuToggle(this.opts.value.current);
  }
  openMenu() {
    this.root.onMenuOpen(this.opts.value.current, this.triggerNode?.id ?? "");
  }
};
var MenubarTriggerState = class _MenubarTriggerState {
  static create(opts) {
    return new _MenubarTriggerState(opts, MenubarMenuContext.get());
  }
  opts;
  menu;
  root;
  attachment;
  #isFocused = tag(state(false), "MenubarTriggerState.isFocused");
  get isFocused() {
    return get(this.#isFocused);
  }
  set isFocused(value) {
    set(this.#isFocused, value, true);
  }
  #tabIndex = tag(state(0), "MenubarTriggerState.#tabIndex");
  constructor(opts, menu) {
    this.opts = opts;
    this.menu = menu;
    this.root = menu.root;
    this.attachment = attachRef(this.opts.ref, (v) => this.menu.triggerNode = v);
    onMount(() => {
      return this.root.registerTrigger(opts.id.current);
    });
    user_effect(() => {
      if (this.root.triggerIds.length) {
        set(this.#tabIndex, this.root.rovingFocusGroup.getTabIndex(this.menu.getTriggerNode()), true);
      }
    });
  }
  onpointerdown = (e) => {
    if (!this.opts.disabled.current && strict_equals(e.button, 0) && strict_equals(e.ctrlKey, false)) {
      if (!this.menu.open) {
        e.preventDefault();
      }
      this.menu.toggleMenu();
    }
  };
  onpointerenter = () => {
    const isMenubarOpen = Boolean(this.root.opts.value.current);
    if (isMenubarOpen && !this.menu.open) {
      this.menu.openMenu();
      this.menu.getTriggerNode()?.focus();
    }
  };
  onkeydown = (e) => {
    if (this.opts.disabled.current) return;
    if (strict_equals(e.key, kbd_constants_exports.TAB)) return;
    if (strict_equals(e.key, kbd_constants_exports.ENTER) || strict_equals(e.key, kbd_constants_exports.SPACE)) {
      this.root.onMenuToggle(this.menu.opts.value.current);
    }
    if (strict_equals(e.key, kbd_constants_exports.ARROW_DOWN)) {
      this.menu.openMenu();
    }
    if (strict_equals(e.key, kbd_constants_exports.ENTER) || strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ARROW_DOWN)) {
      this.menu.wasOpenedByKeyboard = true;
      e.preventDefault();
    }
    this.root.rovingFocusGroup.handleKeydown(this.menu.getTriggerNode(), e);
  };
  onfocus = () => {
    this.isFocused = true;
  };
  onblur = () => {
    this.isFocused = false;
  };
  #props = tag(
    user_derived(() => ({
      type: "button",
      role: "menuitem",
      id: this.opts.id.current,
      "aria-haspopup": "menu",
      "aria-expanded": getAriaExpanded(this.menu.open),
      "aria-controls": this.menu.open ? this.menu.contentId : void 0,
      "data-highlighted": this.isFocused ? "" : void 0,
      "data-state": getDataOpenClosed(this.menu.open),
      "data-disabled": getDataDisabled(this.opts.disabled.current),
      "data-menu-value": this.menu.opts.value.current,
      disabled: this.opts.disabled.current ? true : void 0,
      tabindex: get(this.#tabIndex),
      [menubarAttrs.trigger]: "",
      onpointerdown: this.onpointerdown,
      onpointerenter: this.onpointerenter,
      onkeydown: this.onkeydown,
      onfocus: this.onfocus,
      onblur: this.onblur,
      ...this.attachment
    })),
    "MenubarTriggerState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var MenubarContentState = class _MenubarContentState {
  static create(opts) {
    return new _MenubarContentState(opts, MenubarMenuContext.get());
  }
  opts;
  menu;
  root;
  attachment;
  constructor(opts, menu) {
    this.opts = opts;
    this.menu = menu;
    this.root = menu.root;
    this.attachment = attachRef(this.opts.ref, (v) => this.menu.contentNode = v);
  }
  onCloseAutoFocus = (e) => {
    this.opts.onCloseAutoFocus.current?.(e);
    if (e.defaultPrevented) return;
  };
  onFocusOutside = (e) => {
    const target = e.target;
    const isMenubarTrigger = this.root.getTriggers().some((trigger) => trigger.contains(target));
    if (isMenubarTrigger) e.preventDefault();
    this.opts.onFocusOutside.current(e);
  };
  onInteractOutside = (e) => {
    this.opts.onInteractOutside.current(e);
  };
  onOpenAutoFocus = (e) => {
    this.opts.onOpenAutoFocus.current(e);
    if (e.defaultPrevented) return;
    afterTick(() => this.opts.ref.current?.focus());
  };
  onkeydown = (e) => {
    if (strict_equals(e.key, kbd_constants_exports.ARROW_LEFT, false) && strict_equals(e.key, kbd_constants_exports.ARROW_RIGHT, false)) return;
    const target = e.target;
    const targetIsSubTrigger = target.hasAttribute("data-menu-sub-trigger");
    const isKeydownInsideSubMenu = strict_equals(target.closest("[data-menu-content]"), e.currentTarget, false);
    const prevMenuKey = strict_equals(this.root.opts.dir.current, "rtl") ? kbd_constants_exports.ARROW_RIGHT : kbd_constants_exports.ARROW_LEFT;
    const isPrevKey = strict_equals(prevMenuKey, e.key);
    const isNextKey = !isPrevKey;
    if (isNextKey && targetIsSubTrigger) return;
    if (isKeydownInsideSubMenu && isPrevKey) return;
    const items = this.root.getTriggers().filter((trigger) => !trigger.disabled);
    let candidates = items.map((item) => ({
      value: item.getAttribute("data-menu-value"),
      triggerId: item.id ?? ""
    }));
    if (isPrevKey) candidates.reverse();
    const candidateValues = candidates.map(({ value }) => value);
    const currentIndex = candidateValues.indexOf(this.menu.opts.value.current);
    candidates = this.root.opts.loop.current ? wrapArray(candidates, currentIndex + 1) : candidates.slice(currentIndex + 1);
    const [nextValue] = candidates;
    if (nextValue) this.menu.root.onMenuOpen(nextValue.value, nextValue.triggerId);
  };
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "aria-labelledby": this.menu.triggerId,
      style: getFloatingContentCSSVars("menubar"),
      onkeydown: this.onkeydown,
      "data-menu-content": "",
      [menubarAttrs.content]: "",
      ...this.attachment
    })),
    "MenubarContentState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
  popperProps = {
    onCloseAutoFocus: this.onCloseAutoFocus,
    onFocusOutside: this.onFocusOutside,
    onInteractOutside: this.onInteractOutside,
    onOpenAutoFocus: this.onOpenAutoFocus
  };
};

// node_modules/bits-ui/dist/bits/menubar/components/menubar.svelte
Menubar[FILENAME] = "node_modules/bits-ui/dist/bits/menubar/components/menubar.svelte";
var root_268 = add_locations(from_html(`<div><!></div>`), Menubar[FILENAME], [[45, 1]]);
function Menubar($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menubar);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 7, ""), dir = prop($$props, "dir", 3, "ltr"), loop = prop($$props, "loop", 3, true), onValueChange = prop($$props, "onValueChange", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "children",
      "child",
      "ref",
      "value",
      "dir",
      "loop",
      "onValueChange"
    ],
    "restProps"
  );
  const rootState = MenubarRootState.create({
    id: box.with(() => id()),
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()?.(v);
    }),
    dir: box.with(() => dir()),
    loop: box.with(() => loop()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Menubar, 43, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_268();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Menubar, 46, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Menubar,
      42,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menubar = hmr(Menubar, () => Menubar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menubar[HMR].source;
    set(Menubar[HMR].source, module.default[HMR].original);
  });
}
var menubar_default = Menubar;

// node_modules/bits-ui/dist/bits/menubar/components/menubar-menu.svelte
Menubar_menu[FILENAME] = "node_modules/bits-ui/dist/bits/menubar/components/menubar-menu.svelte";
function Menubar_menu($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menubar_menu);
  let value = prop($$props, "value", 19, () => createId(uid)), onOpenChange = prop($$props, "onOpenChange", 3, noop3), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "value", "onOpenChange"], "restProps");
  const menuState = MenubarMenuState.create({
    value: box.with(() => value()),
    onOpenChange: box.with(() => onOpenChange())
  });
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => menu_default(node, spread_props(
      {
        get open() {
          return menuState.open;
        },
        onOpenChange: (open) => {
          if (!open) menuState.root.onMenuClose();
        },
        get dir() {
          return menuState.root.opts.dir.current;
        },
        _internal_variant: "menubar"
      },
      () => restProps
    )),
    "component",
    Menubar_menu,
    19,
    0,
    { componentTag: "Menu" }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menubar_menu = hmr(Menubar_menu, () => Menubar_menu[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menubar_menu[HMR].source;
    set(Menubar_menu[HMR].source, module.default[HMR].original);
  });
}
var menubar_menu_default = Menubar_menu;

// node_modules/bits-ui/dist/bits/menu/components/menu-content.svelte
Menu_content[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-content.svelte";
var root_417 = add_locations(from_html(`<div><div><!></div></div>`), Menu_content[FILENAME], [[83, 4, [[84, 5]]]]);
var root_913 = add_locations(from_html(`<div><div><!></div></div>`), Menu_content[FILENAME], [[114, 4, [[115, 5]]]]);
function Menu_content($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menu_content);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), onCloseAutoFocusProp = prop($$props, "onCloseAutoFocus", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "child",
      "children",
      "ref",
      "loop",
      "onInteractOutside",
      "onEscapeKeydown",
      "onCloseAutoFocus",
      "forceMount"
    ],
    "restProps"
  );
  const contentState = MenuContentState.create({
    id: box.with(() => id()),
    loop: box.with(() => loop()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onCloseAutoFocus: box.with(() => onCloseAutoFocusProp())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props, { style: { outline: "none" } })), "mergedProps");
  function handleInteractOutside(e) {
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    if (e.target && e.target instanceof Element) {
      const subContentSelector = `[${contentState.parentMenu.root.getBitsAttr("sub-content")}]`;
      if (e.target.closest(subContentSelector)) return;
    }
    contentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Menu_content, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0?.().props;
          props();
          let wrapperProps = () => $$arg0?.().wrapperProps;
          wrapperProps();
          var fragment_2 = comment();
          const finalProps = tag(
            user_derived(() => mergeProps(props(), {
              style: { outline: "none", ...getFloatingContentCSSVars("menu") }
            })),
            "finalProps"
          );
          get(finalProps);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              {
                let $0 = user_derived(() => ({
                  props: get(finalProps),
                  wrapperProps: wrapperProps(),
                  ...contentState.snippetProps
                }));
                add_svelte_meta(() => snippet(node_3, () => $$props.child, () => get($0)), "render", Menu_content, 81, 4);
              }
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_417();
              attribute_effect(div, () => ({ ...wrapperProps() }));
              var div_1 = child(div);
              attribute_effect(div_1, () => ({ ...get(finalProps) }));
              var node_4 = child(div_1);
              add_svelte_meta(() => snippet(node_4, () => $$props.children ?? noop), "render", Menu_content, 85, 6);
              reset(div_1);
              reset(div);
              append($$anchor4, div);
            };
            add_svelte_meta(
              () => if_block(node_2, ($$render) => {
                if ($$props.child) $$render(consequent);
                else $$render(alternate, false);
              }),
              "if",
              Menu_content,
              80,
              3
            );
          }
          append($$anchor3, fragment_2);
        });
        add_svelte_meta(
          () => popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), () => contentState.popperProps, {
            get ref() {
              return contentState.opts.ref;
            },
            get enabled() {
              return contentState.parentMenu.opts.open.current;
            },
            onInteractOutside: handleInteractOutside,
            onEscapeKeydown: handleEscapeKeydown,
            trapFocus: true,
            get loop() {
              return loop();
            },
            forceMount: true,
            get id() {
              return id();
            },
            popper,
            $$slots: { popper: true }
          })),
          "component",
          Menu_content,
          61,
          1,
          { componentTag: "PopperLayerForceMount" }
        );
      }
      append($$anchor2, fragment_1);
    };
    var alternate_2 = ($$anchor2) => {
      var fragment_4 = comment();
      var node_5 = first_child(fragment_4);
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_5 = comment();
          var node_6 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Menu_content, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0?.().props;
              props();
              let wrapperProps = () => $$arg0?.().wrapperProps;
              wrapperProps();
              var fragment_6 = comment();
              const finalProps = tag(
                user_derived(() => mergeProps(props(), {
                  style: { outline: "none", ...getFloatingContentCSSVars("menu") }
                })),
                "finalProps"
              );
              get(finalProps);
              var node_7 = first_child(fragment_6);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_8 = first_child(fragment_7);
                  {
                    let $0 = user_derived(() => ({
                      props: get(finalProps),
                      wrapperProps: wrapperProps(),
                      ...contentState.snippetProps
                    }));
                    add_svelte_meta(() => snippet(node_8, () => $$props.child, () => get($0)), "render", Menu_content, 112, 4);
                  }
                  append($$anchor5, fragment_7);
                };
                var alternate_1 = ($$anchor5) => {
                  var div_2 = root_913();
                  attribute_effect(div_2, () => ({ ...wrapperProps() }));
                  var div_3 = child(div_2);
                  attribute_effect(div_3, () => ({ ...get(finalProps) }));
                  var node_9 = child(div_3);
                  add_svelte_meta(() => snippet(node_9, () => $$props.children ?? noop), "render", Menu_content, 116, 6);
                  reset(div_3);
                  reset(div_2);
                  append($$anchor5, div_2);
                };
                add_svelte_meta(
                  () => if_block(node_7, ($$render) => {
                    if ($$props.child) $$render(consequent_2);
                    else $$render(alternate_1, false);
                  }),
                  "if",
                  Menu_content,
                  111,
                  3
                );
              }
              append($$anchor4, fragment_6);
            });
            add_svelte_meta(
              () => popper_layer_default(node_6, spread_props(() => get(mergedProps), () => contentState.popperProps, {
                get ref() {
                  return contentState.opts.ref;
                },
                get open() {
                  return contentState.parentMenu.opts.open.current;
                },
                onInteractOutside: handleInteractOutside,
                onEscapeKeydown: handleEscapeKeydown,
                trapFocus: true,
                get loop() {
                  return loop();
                },
                forceMount: false,
                get id() {
                  return id();
                },
                popper,
                $$slots: { popper: true }
              })),
              "component",
              Menu_content,
              92,
              1,
              { componentTag: "PopperLayer" }
            );
          }
          append($$anchor3, fragment_5);
        };
        add_svelte_meta(
          () => if_block(
            node_5,
            ($$render) => {
              if (!forceMount()) $$render(consequent_3);
            },
            true
          ),
          "if",
          Menu_content,
          91,
          0
        );
      }
      append($$anchor2, fragment_4);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (forceMount()) $$render(consequent_1);
        else $$render(alternate_2, false);
      }),
      "if",
      Menu_content,
      60,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_content = hmr(Menu_content, () => Menu_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_content[HMR].source;
    set(Menu_content[HMR].source, module.default[HMR].original);
  });
}
var menu_content_default = Menu_content;

// node_modules/bits-ui/dist/bits/menubar/components/menubar-content.svelte
Menubar_content[FILENAME] = "node_modules/bits-ui/dist/bits/menubar/components/menubar-content.svelte";
function Menubar_content($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menubar_content);
  var $$ownership_validator = create_ownership_validator($$props);
  let ref = prop($$props, "ref", 15, null), interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), id = prop($$props, "id", 19, () => createId(uid)), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onFocusOutside = prop($$props, "onFocusOutside", 3, noop3), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), onOpenAutoFocus = prop($$props, "onOpenAutoFocus", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "interactOutsideBehavior",
      "id",
      "onInteractOutside",
      "onFocusOutside",
      "onCloseAutoFocus",
      "onOpenAutoFocus"
    ],
    "restProps"
  );
  const contentState = MenubarContentState.create({
    id: box.with(() => id()),
    interactOutsideBehavior: box.with(() => interactOutsideBehavior()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onInteractOutside: box.with(() => onInteractOutside()),
    onFocusOutside: box.with(() => onFocusOutside()),
    onCloseAutoFocus: box.with(() => onCloseAutoFocus()),
    onOpenAutoFocus: box.with(() => onOpenAutoFocus())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    $$ownership_validator.binding("ref", menu_content_default, ref);
    add_svelte_meta(
      () => menu_content_default(node, spread_props(() => get(mergedProps), () => contentState.popperProps, {
        preventScroll: false,
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        }
      })),
      "component",
      Menubar_content,
      38,
      0,
      { componentTag: "MenuContent" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menubar_content = hmr(Menubar_content, () => Menubar_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menubar_content[HMR].source;
    set(Menubar_content[HMR].source, module.default[HMR].original);
  });
}
var menubar_content_default = Menubar_content;

// node_modules/bits-ui/dist/bits/menu/components/menu-content-static.svelte
Menu_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/menu/components/menu-content-static.svelte";
var root_418 = add_locations(from_html(`<div><!></div>`), Menu_content_static[FILENAME], [[79, 4]]);
var root_914 = add_locations(from_html(`<div><!></div>`), Menu_content_static[FILENAME], [[109, 4]]);
function Menu_content_static($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menu_content_static);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), loop = prop($$props, "loop", 3, true), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), onCloseAutoFocusProp = prop($$props, "onCloseAutoFocus", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "child",
      "children",
      "ref",
      "loop",
      "onInteractOutside",
      "onEscapeKeydown",
      "onCloseAutoFocus",
      "forceMount"
    ],
    "restProps"
  );
  const contentState = MenuContentState.create({
    id: box.with(() => id()),
    loop: box.with(() => loop()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onCloseAutoFocus: box.with(() => onCloseAutoFocusProp())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props, { style: { outline: "none" } })), "mergedProps");
  function handleInteractOutside(e) {
    onInteractOutside()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  function handleEscapeKeydown(e) {
    onEscapeKeydown()(e);
    if (e.defaultPrevented) return;
    contentState.parentMenu.onClose();
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Menu_content_static, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0?.().props;
          props();
          var fragment_2 = comment();
          const finalProps = tag(
            user_derived(() => mergeProps(props(), {
              style: { outline: "none", ...getFloatingContentCSSVars("menu") }
            })),
            "finalProps"
          );
          get(finalProps);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              {
                let $0 = user_derived(() => ({ props: get(finalProps), ...contentState.snippetProps }));
                add_svelte_meta(() => snippet(node_3, () => $$props.child, () => get($0)), "render", Menu_content_static, 77, 4);
              }
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_418();
              attribute_effect(div, () => ({ ...get(finalProps) }));
              var node_4 = child(div);
              add_svelte_meta(() => snippet(node_4, () => $$props.children ?? noop), "render", Menu_content_static, 80, 5);
              reset(div);
              append($$anchor4, div);
            };
            add_svelte_meta(
              () => if_block(node_2, ($$render) => {
                if ($$props.child) $$render(consequent);
                else $$render(alternate, false);
              }),
              "if",
              Menu_content_static,
              76,
              3
            );
          }
          append($$anchor3, fragment_2);
        });
        add_svelte_meta(
          () => popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), () => contentState.popperProps, {
            get ref() {
              return contentState.opts.ref;
            },
            get enabled() {
              return contentState.parentMenu.opts.open.current;
            },
            onInteractOutside: handleInteractOutside,
            onEscapeKeydown: handleEscapeKeydown,
            trapFocus: true,
            get loop() {
              return loop();
            },
            forceMount: true,
            isStatic: true,
            get id() {
              return id();
            },
            popper,
            $$slots: { popper: true }
          })),
          "component",
          Menu_content_static,
          56,
          1,
          { componentTag: "PopperLayerForceMount" }
        );
      }
      append($$anchor2, fragment_1);
    };
    var alternate_2 = ($$anchor2) => {
      var fragment_4 = comment();
      var node_5 = first_child(fragment_4);
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_5 = comment();
          var node_6 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Menu_content_static, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0?.().props;
              props();
              var fragment_6 = comment();
              const finalProps = tag(
                user_derived(() => mergeProps(props(), {
                  style: { outline: "none", ...getFloatingContentCSSVars("menu") }
                })),
                "finalProps"
              );
              get(finalProps);
              var node_7 = first_child(fragment_6);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_8 = first_child(fragment_7);
                  {
                    let $0 = user_derived(() => ({ props: get(finalProps), ...contentState.snippetProps }));
                    add_svelte_meta(() => snippet(node_8, () => $$props.child, () => get($0)), "render", Menu_content_static, 107, 4);
                  }
                  append($$anchor5, fragment_7);
                };
                var alternate_1 = ($$anchor5) => {
                  var div_1 = root_914();
                  attribute_effect(div_1, () => ({ ...get(finalProps) }));
                  var node_9 = child(div_1);
                  add_svelte_meta(() => snippet(node_9, () => $$props.children ?? noop), "render", Menu_content_static, 110, 5);
                  reset(div_1);
                  append($$anchor5, div_1);
                };
                add_svelte_meta(
                  () => if_block(node_7, ($$render) => {
                    if ($$props.child) $$render(consequent_2);
                    else $$render(alternate_1, false);
                  }),
                  "if",
                  Menu_content_static,
                  106,
                  3
                );
              }
              append($$anchor4, fragment_6);
            });
            add_svelte_meta(
              () => popper_layer_default(node_6, spread_props(() => get(mergedProps), () => contentState.popperProps, {
                get ref() {
                  return contentState.opts.ref;
                },
                get open() {
                  return contentState.parentMenu.opts.open.current;
                },
                onInteractOutside: handleInteractOutside,
                onEscapeKeydown: handleEscapeKeydown,
                trapFocus: true,
                get loop() {
                  return loop();
                },
                forceMount: false,
                isStatic: true,
                get id() {
                  return id();
                },
                popper,
                $$slots: { popper: true }
              })),
              "component",
              Menu_content_static,
              86,
              1,
              { componentTag: "PopperLayer" }
            );
          }
          append($$anchor3, fragment_5);
        };
        add_svelte_meta(
          () => if_block(
            node_5,
            ($$render) => {
              if (!forceMount()) $$render(consequent_3);
            },
            true
          ),
          "if",
          Menu_content_static,
          85,
          0
        );
      }
      append($$anchor2, fragment_4);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (forceMount()) $$render(consequent_1);
        else $$render(alternate_2, false);
      }),
      "if",
      Menu_content_static,
      55,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menu_content_static = hmr(Menu_content_static, () => Menu_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menu_content_static[HMR].source;
    set(Menu_content_static[HMR].source, module.default[HMR].original);
  });
}
var menu_content_static_default = Menu_content_static;

// node_modules/bits-ui/dist/bits/menubar/components/menubar-content-static.svelte
Menubar_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/menubar/components/menubar-content-static.svelte";
function Menubar_content_static($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menubar_content_static);
  var $$ownership_validator = create_ownership_validator($$props);
  let ref = prop($$props, "ref", 15, null), interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), id = prop($$props, "id", 19, () => createId(uid)), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onCloseAutoFocus = prop($$props, "onCloseAutoFocus", 3, noop3), onFocusOutside = prop($$props, "onFocusOutside", 3, noop3), onOpenAutoFocus = prop($$props, "onOpenAutoFocus", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "interactOutsideBehavior",
      "id",
      "onInteractOutside",
      "onCloseAutoFocus",
      "onFocusOutside",
      "onOpenAutoFocus"
    ],
    "restProps"
  );
  const contentState = MenubarContentState.create({
    id: box.with(() => id()),
    interactOutsideBehavior: box.with(() => interactOutsideBehavior()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onInteractOutside: box.with(() => onInteractOutside()),
    onFocusOutside: box.with(() => onFocusOutside()),
    onCloseAutoFocus: box.with(() => onCloseAutoFocus()),
    onOpenAutoFocus: box.with(() => onOpenAutoFocus())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    $$ownership_validator.binding("ref", menu_content_static_default, ref);
    add_svelte_meta(
      () => menu_content_static_default(node, spread_props(() => get(mergedProps), () => contentState.popperProps, {
        preventScroll: false,
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        }
      })),
      "component",
      Menubar_content_static,
      38,
      0,
      { componentTag: "MenuContentStatic" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menubar_content_static = hmr(Menubar_content_static, () => Menubar_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menubar_content_static[HMR].source;
    set(Menubar_content_static[HMR].source, module.default[HMR].original);
  });
}
var menubar_content_static_default = Menubar_content_static;

// node_modules/bits-ui/dist/bits/menubar/components/menubar-trigger.svelte
Menubar_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/menubar/components/menubar-trigger.svelte";
var root_317 = add_locations(from_html(`<button><!></button>`), Menubar_trigger[FILENAME], [[45, 2]]);
function Menubar_trigger($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Menubar_trigger);
  let id = prop($$props, "id", 19, () => createId(uid)), disabled = prop($$props, "disabled", 3, false), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "disabled",
      "children",
      "child",
      "ref"
    ],
    "restProps"
  );
  const triggerState = MenubarTriggerState.create({
    id: box.with(() => id()),
    disabled: box.with(() => disabled() ?? false),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const dropdownTriggerState = DropdownMenuTriggerState.create(triggerState.opts);
  const triggerAttachment = attachRef((v) => assign(dropdownTriggerState.parentMenu, "triggerNode", v, "node_modules/bits-ui/dist/bits/menubar/components/menubar-trigger.svelte:31:30"));
  const mergedProps = tag(user_derived(() => mergeProps(restProps, triggerState.props, { ...triggerAttachment })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => floating_layer_anchor_default(node, {
      get id() {
        return id();
      },
      get ref() {
        return triggerState.opts.ref;
      },
      children: wrap_snippet(Menubar_trigger, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        {
          var consequent = ($$anchor3) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            add_svelte_meta(() => snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Menubar_trigger, 43, 2);
            append($$anchor3, fragment_2);
          };
          var alternate = ($$anchor3) => {
            var button = root_317();
            attribute_effect(button, () => ({ ...get(mergedProps) }));
            var node_3 = child(button);
            add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop), "render", Menubar_trigger, 46, 3);
            reset(button);
            append($$anchor3, button);
          };
          add_svelte_meta(
            () => if_block(node_1, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            }),
            "if",
            Menubar_trigger,
            42,
            1
          );
        }
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }),
    "component",
    Menubar_trigger,
    41,
    0,
    { componentTag: "FloatingLayerAnchor" }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Menubar_trigger = hmr(Menubar_trigger, () => Menubar_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Menubar_trigger[HMR].source;
    set(Menubar_trigger[HMR].source, module.default[HMR].original);
  });
}
var menubar_trigger_default = Menubar_trigger;

// node_modules/bits-ui/dist/bits/meter/exports.js
var exports_exports21 = {};
__export(exports_exports21, {
  Root: () => meter_default
});

// node_modules/bits-ui/dist/bits/meter/meter.svelte.js
var meterAttrs = createBitsAttrs({ component: "meter", parts: ["root"] });
var MeterRootState = class _MeterRootState {
  static create(opts) {
    return new _MeterRootState(opts);
  }
  opts;
  attachment;
  constructor(opts) {
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
  }
  #props = tag(
    user_derived(() => ({
      role: "meter",
      value: this.opts.value.current,
      "aria-valuemin": this.opts.min.current,
      "aria-valuemax": this.opts.max.current,
      "aria-valuenow": this.opts.value.current,
      "data-value": this.opts.value.current,
      "data-max": this.opts.max.current,
      "data-min": this.opts.min.current,
      [meterAttrs.root]: "",
      ...this.attachment
    })),
    "MeterRootState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};

// node_modules/bits-ui/dist/bits/meter/components/meter.svelte
Meter[FILENAME] = "node_modules/bits-ui/dist/bits/meter/components/meter.svelte";
var root_269 = add_locations(from_html(`<div><!></div>`), Meter[FILENAME], [[37, 1]]);
function Meter($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Meter);
  let value = prop($$props, "value", 3, 0), max = prop($$props, "max", 3, 100), min = prop($$props, "min", 3, 0), id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "value",
      "max",
      "min",
      "id",
      "ref"
    ],
    "restProps"
  );
  const rootState = MeterRootState.create({
    value: box.with(() => value()),
    max: box.with(() => max()),
    min: box.with(() => min()),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Meter, 35, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_269();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Meter, 38, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Meter,
      34,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Meter = hmr(Meter, () => Meter[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Meter[HMR].source;
    set(Meter[HMR].source, module.default[HMR].original);
  });
}
var meter_default = Meter;

// node_modules/bits-ui/dist/bits/navigation-menu/exports.js
var exports_exports22 = {};
__export(exports_exports22, {
  Content: () => navigation_menu_content_default,
  Indicator: () => navigation_menu_indicator_default,
  Item: () => navigation_menu_item_default,
  Link: () => navigation_menu_link_default,
  List: () => navigation_menu_list_default,
  Root: () => navigation_menu_default,
  Sub: () => navigation_menu_sub_default,
  Trigger: () => navigation_menu_trigger_default,
  Viewport: () => navigation_menu_viewport_default
});

// node_modules/bits-ui/dist/bits/pin-input/usePasswordManager.svelte.js
var PWM_BADGE_MARGIN_RIGHT = 18;
var PWM_BADGE_SPACE_WIDTH_PX = 40;
var PWM_BADGE_SPACE_WIDTH = `${PWM_BADGE_SPACE_WIDTH_PX}px`;
var PASSWORD_MANAGER_SELECTORS = [
  "[data-lastpass-icon-root]",
  "com-1password-button",
  "[data-dashlanecreated]",
  '[style$="2147483647 !important;"]'
].join(",");
function usePasswordManagerBadge({
  containerRef,
  inputRef,
  pushPasswordManagerStrategy,
  isFocused,
  domContext
}) {
  let hasPwmBadge = tag(state(false), "hasPwmBadge");
  let hasPwmBadgeSpace = tag(state(false), "hasPwmBadgeSpace");
  let done = tag(state(false), "done");
  function willPushPwmBadge() {
    const strategy = pushPasswordManagerStrategy.current;
    if (strict_equals(strategy, "none")) return false;
    const increaseWidthCase = strict_equals(strategy, "increase-width") && get(hasPwmBadge) && get(hasPwmBadgeSpace);
    return increaseWidthCase;
  }
  function trackPwmBadge() {
    const container = containerRef.current;
    const input = inputRef.current;
    if (!container || !input || get(done) || strict_equals(pushPasswordManagerStrategy.current, "none")) return;
    const elementToCompare = container;
    const rightCornerX = elementToCompare.getBoundingClientRect().left + elementToCompare.offsetWidth;
    const centeredY = elementToCompare.getBoundingClientRect().top + elementToCompare.offsetHeight / 2;
    const x = rightCornerX - PWM_BADGE_MARGIN_RIGHT;
    const y = centeredY;
    const passwordManagerStrategy = domContext.querySelectorAll(PASSWORD_MANAGER_SELECTORS);
    if (strict_equals(passwordManagerStrategy.length, 0)) {
      const maybeBadgeEl = domContext.getDocument().elementFromPoint(x, y);
      if (strict_equals(maybeBadgeEl, container)) return;
    }
    set(hasPwmBadge, true);
    set(done, true);
  }
  user_effect(() => {
    const container = containerRef.current;
    if (!container || strict_equals(pushPasswordManagerStrategy.current, "none")) return;
    function checkHasSpace() {
      const viewportWidth = getWindow(container).innerWidth;
      const distanceToRightEdge = viewportWidth - container.getBoundingClientRect().right;
      set(hasPwmBadgeSpace, distanceToRightEdge >= PWM_BADGE_SPACE_WIDTH_PX);
    }
    checkHasSpace();
    const interval = setInterval(checkHasSpace, 1e3);
    return () => {
      clearInterval(interval);
    };
  });
  user_effect(() => {
    const focused = isFocused.current || strict_equals(domContext.getActiveElement(), inputRef.current);
    if (strict_equals(pushPasswordManagerStrategy.current, "none") || !focused) return;
    const t1 = setTimeout(trackPwmBadge, 0);
    const t2 = setTimeout(trackPwmBadge, 2e3);
    const t3 = setTimeout(trackPwmBadge, 5e3);
    const t4 = setTimeout(
      () => {
        set(done, true);
      },
      6e3
    );
    return () => {
      clearTimeout(t1);
      clearTimeout(t2);
      clearTimeout(t3);
      clearTimeout(t4);
    };
  });
  return {
    get hasPwmBadge() {
      return get(hasPwmBadge);
    },
    get willPushPwmBadge() {
      return willPushPwmBadge();
    },
    PWM_BADGE_SPACE_WIDTH
  };
}

// node_modules/bits-ui/dist/bits/pin-input/pin-input.svelte.js
var REGEXP_ONLY_DIGITS = "^\\d+$";
var REGEXP_ONLY_CHARS = "^[a-zA-Z]+$";
var REGEXP_ONLY_DIGITS_AND_CHARS = "^[a-zA-Z0-9]+$";
var pinInputAttrs = createBitsAttrs({ component: "pin-input", parts: ["root", "cell"] });
var KEYS_TO_IGNORE = [
  "Backspace",
  "Delete",
  "ArrowLeft",
  "ArrowRight",
  "ArrowUp",
  "ArrowDown",
  "Home",
  "End",
  "Escape",
  "Enter",
  "Tab",
  "Shift",
  "Control",
  "Meta"
];
var PinInputRootState = class _PinInputRootState {
  static create(opts) {
    return new _PinInputRootState(opts);
  }
  opts;
  attachment;
  #inputRef = box(null);
  #isHoveringInput = tag(state(false), "PinInputRootState.#isHoveringInput");
  inputAttachment = attachRef(this.#inputRef);
  #isFocused = box(false);
  #mirrorSelectionStart = tag(state(null), "PinInputRootState.#mirrorSelectionStart");
  #mirrorSelectionEnd = tag(state(null), "PinInputRootState.#mirrorSelectionEnd");
  #previousValue = new Previous(() => this.opts.value.current ?? "");
  #regexPattern = tag(
    user_derived(() => {
      if (strict_equals(typeof this.opts.pattern.current, "string")) {
        return new RegExp(this.opts.pattern.current);
      } else {
        return this.opts.pattern.current;
      }
    }),
    "PinInputRootState.#regexPattern"
  );
  #prevInputMetadata = tag(state(proxy({ prev: [null, null, "none"], willSyntheticBlur: false })), "PinInputRootState.#prevInputMetadata");
  #pwmb;
  #initialLoad;
  domContext;
  constructor(opts) {
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.domContext = new DOMContext(opts.ref);
    this.#initialLoad = {
      value: this.opts.value,
      isIOS: strict_equals(typeof window, "undefined", false) && window?.CSS?.supports("-webkit-touch-callout", "none")
    };
    this.#pwmb = usePasswordManagerBadge({
      containerRef: this.opts.ref,
      inputRef: this.#inputRef,
      isFocused: this.#isFocused,
      pushPasswordManagerStrategy: this.opts.pushPasswordManagerStrategy,
      domContext: this.domContext
    });
    onMount(() => {
      const input = this.#inputRef.current;
      const container = this.opts.ref.current;
      if (!input || !container) return;
      if (strict_equals(this.#initialLoad.value.current, input.value, false)) {
        this.opts.value.current = input.value;
      }
      get(this.#prevInputMetadata).prev = [
        input.selectionStart,
        input.selectionEnd,
        input.selectionDirection ?? "none"
      ];
      const unsub = on(this.domContext.getDocument(), "selectionchange", this.#onDocumentSelectionChange, { capture: true });
      this.#onDocumentSelectionChange();
      if (strict_equals(this.domContext.getActiveElement(), input)) {
        this.#isFocused.current = true;
      }
      if (!this.domContext.getElementById("pin-input-style")) {
        this.#applyStyles();
      }
      const updateRootHeight = () => {
        if (container) {
          container.style.setProperty("--bits-pin-input-root-height", `${input.clientHeight}px`);
        }
      };
      updateRootHeight();
      const resizeObserver = new ResizeObserver(updateRootHeight);
      resizeObserver.observe(input);
      return () => {
        unsub();
        resizeObserver.disconnect();
      };
    });
    watch([() => this.opts.value.current, () => this.#inputRef.current], () => {
      syncTimeouts(
        () => {
          const input = this.#inputRef.current;
          if (!input) return;
          input.dispatchEvent(new Event("input"));
          const start = input.selectionStart;
          const end = input.selectionEnd;
          const dir = input.selectionDirection ?? "none";
          if (strict_equals(start, null, false) && strict_equals(end, null, false)) {
            set(this.#mirrorSelectionStart, start, true);
            set(this.#mirrorSelectionEnd, end, true);
            get(this.#prevInputMetadata).prev = [start, end, dir];
          }
        },
        this.domContext
      );
    });
    user_effect(() => {
      const value = this.opts.value.current;
      const prevValue = this.#previousValue.current;
      const maxLength = this.opts.maxLength.current;
      const onComplete = this.opts.onComplete.current;
      if (strict_equals(prevValue, void 0)) return;
      if (strict_equals(value, prevValue, false) && prevValue.length < maxLength && strict_equals(value.length, maxLength)) {
        onComplete(value);
      }
    });
  }
  onkeydown = (e) => {
    const key2 = e.key;
    if (KEYS_TO_IGNORE.includes(key2)) return;
    if (e.ctrlKey || e.metaKey) return;
    if (key2 && get(this.#regexPattern) && !get(this.#regexPattern).test(key2)) {
      e.preventDefault();
    }
  };
  #rootStyles = tag(
    user_derived(() => ({
      position: "relative",
      cursor: this.opts.disabled.current ? "default" : "text",
      userSelect: "none",
      WebkitUserSelect: "none",
      pointerEvents: "none"
    })),
    "PinInputRootState.#rootStyles"
  );
  #rootProps = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      [pinInputAttrs.root]: "",
      style: get(this.#rootStyles),
      ...this.attachment
    })),
    "PinInputRootState.rootProps"
  );
  get rootProps() {
    return get(this.#rootProps);
  }
  set rootProps(value) {
    set(this.#rootProps, value);
  }
  #inputWrapperProps = tag(
    user_derived(() => ({
      style: { position: "absolute", inset: 0, pointerEvents: "none" }
    })),
    "PinInputRootState.inputWrapperProps"
  );
  get inputWrapperProps() {
    return get(this.#inputWrapperProps);
  }
  set inputWrapperProps(value) {
    set(this.#inputWrapperProps, value);
  }
  #inputStyle = tag(
    user_derived(() => ({
      position: "absolute",
      inset: 0,
      width: this.#pwmb.willPushPwmBadge ? `calc(100% + ${this.#pwmb.PWM_BADGE_SPACE_WIDTH})` : "100%",
      clipPath: this.#pwmb.willPushPwmBadge ? `inset(0 ${this.#pwmb.PWM_BADGE_SPACE_WIDTH} 0 0)` : void 0,
      height: "100%",
      display: "flex",
      textAlign: this.opts.textAlign.current,
      opacity: "1",
      color: "transparent",
      pointerEvents: "all",
      background: "transparent",
      caretColor: "transparent",
      border: "0 solid transparent",
      outline: "0 solid transparent",
      boxShadow: "none",
      lineHeight: "1",
      letterSpacing: "-.5em",
      fontSize: "var(--bits-pin-input-root-height)",
      fontFamily: "monospace",
      fontVariantNumeric: "tabular-nums"
    })),
    "PinInputRootState.#inputStyle"
  );
  #applyStyles() {
    const doc = this.domContext.getDocument();
    const styleEl = doc.createElement("style");
    styleEl.id = "pin-input-style";
    doc.head.appendChild(styleEl);
    if (styleEl.sheet) {
      const autoFillStyles = "background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;";
      safeInsertRule(styleEl.sheet, "[data-pin-input-input]::selection { background: transparent !important; color: transparent !important; }");
      safeInsertRule(styleEl.sheet, `[data-pin-input-input]:autofill { ${autoFillStyles} }`);
      safeInsertRule(styleEl.sheet, `[data-pin-input-input]:-webkit-autofill { ${autoFillStyles} }`);
      safeInsertRule(styleEl.sheet, `@supports (-webkit-touch-callout: none) { [data-pin-input-input] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }`);
      safeInsertRule(styleEl.sheet, `[data-pin-input-input] + * { pointer-events: all !important; }`);
    }
  }
  #onDocumentSelectionChange = () => {
    const input = this.#inputRef.current;
    const container = this.opts.ref.current;
    if (!input || !container) return;
    if (strict_equals(this.domContext.getActiveElement(), input, false)) {
      set(this.#mirrorSelectionStart, null);
      set(this.#mirrorSelectionEnd, null);
      return;
    }
    const selStart = input.selectionStart;
    const selEnd = input.selectionEnd;
    const selDir = input.selectionDirection ?? "none";
    const maxLength = input.maxLength;
    const val = input.value;
    const prev2 = get(this.#prevInputMetadata).prev;
    let start = -1;
    let end = -1;
    let direction;
    if (strict_equals(val.length, 0, false) && strict_equals(selStart, null, false) && strict_equals(selEnd, null, false)) {
      const isSingleCaret = strict_equals(selStart, selEnd);
      const isInsertMode = strict_equals(selStart, val.length) && val.length < maxLength;
      if (isSingleCaret && !isInsertMode) {
        const c = selStart;
        if (strict_equals(c, 0)) {
          start = 0;
          end = 1;
          direction = "forward";
        } else if (strict_equals(c, maxLength)) {
          start = c - 1;
          end = c;
          direction = "backward";
        } else if (maxLength > 1 && val.length > 1) {
          let offset2 = 0;
          if (strict_equals(prev2[0], null, false) && strict_equals(prev2[1], null, false)) {
            direction = c < prev2[0] ? "backward" : "forward";
            const wasPreviouslyInserting = strict_equals(prev2[0], prev2[1]) && prev2[0] < maxLength;
            if (strict_equals(direction, "backward") && !wasPreviouslyInserting) {
              offset2 = -1;
            }
          }
          start = offset2 - c;
          end = offset2 + c + 1;
        }
      }
      if (strict_equals(start, -1, false) && strict_equals(end, -1, false) && strict_equals(start, end, false)) {
        this.#inputRef.current?.setSelectionRange(start, end, direction);
      }
    }
    const s = strict_equals(start, -1, false) ? start : selStart;
    const e = strict_equals(end, -1, false) ? end : selEnd;
    const dir = direction ?? selDir;
    set(this.#mirrorSelectionStart, s, true);
    set(this.#mirrorSelectionEnd, e, true);
    get(this.#prevInputMetadata).prev = [s, e, dir];
  };
  oninput = (e) => {
    const newValue = e.currentTarget.value.slice(0, this.opts.maxLength.current);
    if (newValue.length > 0 && get(this.#regexPattern) && !get(this.#regexPattern).test(newValue)) {
      e.preventDefault();
      return;
    }
    const maybeHasDeleted = strict_equals(typeof this.#previousValue.current, "string") && newValue.length < this.#previousValue.current.length;
    if (maybeHasDeleted) {
      this.domContext.getDocument().dispatchEvent(new Event("selectionchange"));
    }
    this.opts.value.current = newValue;
  };
  onfocus = (_) => {
    const input = this.#inputRef.current;
    if (input) {
      const start = Math.min(input.value.length, this.opts.maxLength.current - 1);
      const end = input.value.length;
      input.setSelectionRange(start, end);
      set(this.#mirrorSelectionStart, start, true);
      set(this.#mirrorSelectionEnd, end, true);
    }
    this.#isFocused.current = true;
  };
  onpaste = (e) => {
    const input = this.#inputRef.current;
    if (!input) return;
    const getNewValue = (finalContent) => {
      const start = strict_equals(input.selectionStart, null) ? void 0 : input.selectionStart;
      const end = strict_equals(input.selectionEnd, null) ? void 0 : input.selectionEnd;
      const isReplacing = strict_equals(start, end, false);
      const initNewVal = this.opts.value.current;
      const newValueUncapped = isReplacing ? initNewVal.slice(0, start) + finalContent + initNewVal.slice(end) : initNewVal.slice(0, start) + finalContent + initNewVal.slice(start);
      return newValueUncapped.slice(0, this.opts.maxLength.current);
    };
    const isValueInvalid = (newValue2) => {
      return newValue2.length > 0 && get(this.#regexPattern) && !get(this.#regexPattern).test(newValue2);
    };
    if (!this.opts.pasteTransformer?.current && (!this.#initialLoad.isIOS || !e.clipboardData || !input)) {
      const newValue2 = getNewValue(e.clipboardData?.getData("text/plain"));
      if (isValueInvalid(newValue2)) {
        e.preventDefault();
      }
      return;
    }
    const _content = e.clipboardData?.getData("text/plain") ?? "";
    const content = this.opts.pasteTransformer?.current ? this.opts.pasteTransformer.current(_content) : _content;
    e.preventDefault();
    const newValue = getNewValue(content);
    if (isValueInvalid(newValue)) return;
    input.value = newValue;
    this.opts.value.current = newValue;
    const selStart = Math.min(newValue.length, this.opts.maxLength.current - 1);
    const selEnd = newValue.length;
    input.setSelectionRange(selStart, selEnd);
    set(this.#mirrorSelectionStart, selStart, true);
    set(this.#mirrorSelectionEnd, selEnd, true);
  };
  onmouseover = (_) => {
    set(this.#isHoveringInput, true);
  };
  onmouseleave = (_) => {
    set(this.#isHoveringInput, false);
  };
  onblur = (_) => {
    if (get(this.#prevInputMetadata).willSyntheticBlur) {
      get(this.#prevInputMetadata).willSyntheticBlur = false;
      return;
    }
    this.#isFocused.current = false;
  };
  #inputProps = tag(
    user_derived(() => ({
      id: this.opts.inputId.current,
      style: get(this.#inputStyle),
      autocomplete: this.opts.autocomplete.current || "one-time-code",
      "data-pin-input-input": "",
      "data-pin-input-input-mss": get(this.#mirrorSelectionStart),
      "data-pin-input-input-mse": get(this.#mirrorSelectionEnd),
      inputmode: this.opts.inputmode.current,
      pattern: get(this.#regexPattern)?.source,
      maxlength: this.opts.maxLength.current,
      value: this.opts.value.current,
      disabled: getDisabled(this.opts.disabled.current),
      //
      onpaste: this.onpaste,
      oninput: this.oninput,
      onkeydown: this.onkeydown,
      onmouseover: this.onmouseover,
      onmouseleave: this.onmouseleave,
      onfocus: this.onfocus,
      onblur: this.onblur,
      ...this.inputAttachment
    })),
    "PinInputRootState.inputProps"
  );
  get inputProps() {
    return get(this.#inputProps);
  }
  set inputProps(value) {
    set(this.#inputProps, value);
  }
  #cells = tag(
    user_derived(() => Array.from({ length: this.opts.maxLength.current }).map((_, idx) => {
      const isActive = this.#isFocused.current && strict_equals(get(this.#mirrorSelectionStart), null, false) && strict_equals(get(this.#mirrorSelectionEnd), null, false) && (strict_equals(get(this.#mirrorSelectionStart), get(this.#mirrorSelectionEnd)) && strict_equals(idx, get(this.#mirrorSelectionStart)) || idx >= get(this.#mirrorSelectionStart) && idx < get(this.#mirrorSelectionEnd));
      const char = strict_equals(this.opts.value.current[idx], void 0, false) ? this.opts.value.current[idx] : null;
      return {
        char,
        isActive,
        hasFakeCaret: isActive && strict_equals(char, null)
      };
    })),
    "PinInputRootState.#cells"
  );
  #snippetProps = tag(
    user_derived(() => ({
      cells: get(this.#cells),
      isFocused: this.#isFocused.current,
      isHovering: get(this.#isHoveringInput)
    })),
    "PinInputRootState.snippetProps"
  );
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
};
var PinInputCellState = class _PinInputCellState {
  static create(opts) {
    return new _PinInputCellState(opts);
  }
  opts;
  attachment;
  constructor(opts) {
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      [pinInputAttrs.cell]: "",
      "data-active": this.opts.cell.current.isActive ? "" : void 0,
      "data-inactive": !this.opts.cell.current.isActive ? "" : void 0,
      ...this.attachment
    })),
    "PinInputCellState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
function syncTimeouts(cb, domContext) {
  const t1 = domContext.setTimeout(cb, 0);
  const t2 = domContext.setTimeout(cb, 10);
  const t3 = domContext.setTimeout(cb, 50);
  return [t1, t2, t3];
}
function safeInsertRule(sheet, rule) {
  try {
    sheet.insertRule(rule);
  } catch {
    console.error(...log_if_contains_state("error", "pin input could not insert CSS rule:", rule));
  }
}

// node_modules/bits-ui/dist/internal/use-arrow-navigation.js
var ignoredElement = ["INPUT", "TEXTAREA"];
function useArrowNavigation(e, currentElement, parentElement, options) {
  if (!currentElement || options.enableIgnoredElement && ignoredElement.includes(currentElement.nodeName)) {
    return null;
  }
  const { arrowKeyOptions = "both", candidateSelector: attributeName, itemsArray = [], loop = true, dir = "ltr", preventScroll = true, focus: focus2 = false } = options;
  const [right, left, up, down, home, end] = [
    e.key === "ArrowRight",
    e.key === "ArrowLeft",
    e.key === "ArrowUp",
    e.key === "ArrowDown",
    e.key === "Home",
    e.key === "End"
  ];
  const goingVertical = up || down;
  const goingHorizontal = right || left;
  if (!home && !end && (!goingVertical && !goingHorizontal || arrowKeyOptions === "vertical" && goingHorizontal || arrowKeyOptions === "horizontal" && goingVertical))
    return null;
  const allCollectionItems = parentElement ? Array.from(parentElement.querySelectorAll(attributeName)) : itemsArray;
  if (!allCollectionItems.length)
    return null;
  if (preventScroll)
    e.preventDefault();
  let item = null;
  if (goingHorizontal || goingVertical) {
    const goForward = goingVertical ? down : dir === "ltr" ? right : left;
    item = findNextFocusableElement(allCollectionItems, currentElement, {
      goForward,
      loop
    });
  } else if (home) {
    item = allCollectionItems.at(0) || null;
  } else if (end) {
    item = allCollectionItems.at(-1) || null;
  }
  if (focus2)
    item?.focus();
  return item;
}
function findNextFocusableElement(elements, currentElement, { goForward, loop }, iterations = elements.length) {
  if (--iterations === 0)
    return null;
  const index = elements.indexOf(currentElement);
  const newIndex = goForward ? index + 1 : index - 1;
  if (!loop && (newIndex < 0 || newIndex >= elements.length))
    return null;
  const adjustedNewIndex = (newIndex + elements.length) % elements.length;
  const candidate = elements[adjustedNewIndex];
  if (!candidate)
    return null;
  const isDisabled = candidate.hasAttribute("disabled") && candidate.getAttribute("disabled") !== "false";
  if (isDisabled) {
    return findNextFocusableElement(elements, candidate, { goForward, loop }, iterations);
  }
  return candidate;
}

// node_modules/bits-ui/dist/internal/svelte-resize-observer.svelte.js
var SvelteResizeObserver = class {
  #node;
  #onResize;
  constructor(node, onResize) {
    this.#node = node;
    this.#onResize = onResize;
    this.handler = this.handler.bind(this);
    user_effect(this.handler);
  }
  handler() {
    let rAF = 0;
    const _node = this.#node();
    if (!_node) return;
    const resizeObserver = new ResizeObserver(() => {
      cancelAnimationFrame(rAF);
      rAF = window.requestAnimationFrame(this.#onResize);
    });
    resizeObserver.observe(_node);
    return () => {
      window.cancelAnimationFrame(rAF);
      resizeObserver.unobserve(_node);
    };
  }
};

// node_modules/bits-ui/dist/bits/navigation-menu/navigation-menu.svelte.js
var navigationMenuAttrs = createBitsAttrs({
  component: "navigation-menu",
  parts: [
    "root",
    "sub",
    "item",
    "list",
    "trigger",
    "content",
    "link",
    "viewport",
    "menu",
    "indicator"
  ]
});
var NavigationMenuProviderContext = new Context("NavigationMenu.Root");
var NavigationMenuItemContext = new Context("NavigationMenu.Item");
var NavigationMenuListContext = new Context("NavigationMenu.List");
var NavigationMenuContentContext = new Context("NavigationMenu.Content");
var NavigationMenuSubContext = new Context("NavigationMenu.Sub");
var NavigationMenuProviderState = class _NavigationMenuProviderState {
  static create(opts) {
    return NavigationMenuProviderContext.set(new _NavigationMenuProviderState(opts));
  }
  opts;
  indicatorTrackRef = box(null);
  viewportRef = box(null);
  viewportContent = new SvelteMap();
  onTriggerEnter;
  onTriggerLeave = noop3;
  onContentEnter = noop3;
  onContentLeave = noop3;
  onItemSelect;
  onItemDismiss;
  activeItem = null;
  prevActiveItem = null;
  constructor(opts) {
    this.opts = opts;
    this.onTriggerEnter = opts.onTriggerEnter;
    this.onTriggerLeave = opts.onTriggerLeave ?? noop3;
    this.onContentEnter = opts.onContentEnter ?? noop3;
    this.onContentLeave = opts.onContentLeave ?? noop3;
    this.onItemDismiss = opts.onItemDismiss;
    this.onItemSelect = opts.onItemSelect;
  }
  setActiveItem = (item) => {
    this.prevActiveItem = this.activeItem;
    this.activeItem = item;
  };
};
var NavigationMenuRootState = class _NavigationMenuRootState {
  static create(opts) {
    return new _NavigationMenuRootState(opts);
  }
  opts;
  attachment;
  provider;
  previousValue = box("");
  isDelaySkipped;
  #derivedDelay = tag(
    user_derived(() => {
      const isOpen = strict_equals(this.opts?.value?.current, "", false);
      if (isOpen || this.isDelaySkipped.current) {
        return 100;
      } else {
        return this.opts.delayDuration.current;
      }
    }),
    "NavigationMenuRootState.#derivedDelay"
  );
  constructor(opts) {
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.isDelaySkipped = boxAutoReset(false, {
      afterMs: this.opts.skipDelayDuration.current,
      getWindow: () => getWindow(opts.ref.current)
    });
    this.provider = NavigationMenuProviderState.create({
      value: this.opts.value,
      previousValue: this.previousValue,
      dir: this.opts.dir,
      orientation: this.opts.orientation,
      rootNavigationMenuRef: this.opts.ref,
      isRootMenu: true,
      onTriggerEnter: (itemValue, itemState) => {
        this.#onTriggerEnter(itemValue, itemState);
      },
      onTriggerLeave: this.#onTriggerLeave,
      onContentEnter: this.#onContentEnter,
      onContentLeave: this.#onContentLeave,
      onItemSelect: this.#onItemSelect,
      onItemDismiss: this.#onItemDismiss
    });
  }
  #debouncedFn = useDebounce(
    (val, itemState) => {
      if (strict_equals(typeof val, "string")) {
        this.setValue(val, itemState);
      }
    },
    () => get(this.#derivedDelay)
  );
  #onTriggerEnter = (itemValue, itemState) => {
    this.#debouncedFn(itemValue, itemState);
  };
  #onTriggerLeave = () => {
    this.isDelaySkipped.current = false;
    this.#debouncedFn("", null);
  };
  #onContentEnter = () => {
    this.#debouncedFn(void 0, null);
  };
  #onContentLeave = () => {
    if (this.provider.activeItem && strict_equals(this.provider.activeItem.opts.openOnHover.current, false)) {
      return;
    }
    this.#debouncedFn("", null);
  };
  #onItemSelect = (itemValue, itemState) => {
    this.setValue(itemValue, itemState);
  };
  #onItemDismiss = () => {
    this.setValue("", null);
  };
  setValue = (newValue, itemState) => {
    this.previousValue.current = this.opts.value.current;
    this.opts.value.current = newValue;
    this.provider.setActiveItem(itemState);
    if (strict_equals(newValue, "")) {
      this.previousValue.current = "";
    }
  };
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "data-orientation": getDataOrientation(this.opts.orientation.current),
      dir: this.opts.dir.current,
      [navigationMenuAttrs.root]: "",
      [navigationMenuAttrs.menu]: "",
      ...this.attachment
    })),
    "NavigationMenuRootState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var NavigationMenuSubState = class _NavigationMenuSubState {
  static create(opts) {
    return new _NavigationMenuSubState(opts, NavigationMenuProviderContext.get());
  }
  opts;
  context;
  previousValue = box("");
  subProvider;
  attachment;
  constructor(opts, context) {
    this.opts = opts;
    this.context = context;
    this.attachment = attachRef(this.opts.ref);
    this.subProvider = NavigationMenuProviderState.create({
      isRootMenu: false,
      value: this.opts.value,
      dir: this.context.opts.dir,
      orientation: this.opts.orientation,
      rootNavigationMenuRef: this.opts.ref,
      onTriggerEnter: this.setValue,
      onItemSelect: this.setValue,
      onItemDismiss: () => this.setValue("", null),
      previousValue: this.previousValue
    });
  }
  setValue = (newValue, itemState) => {
    this.previousValue.current = this.opts.value.current;
    this.opts.value.current = newValue;
    this.subProvider.setActiveItem(itemState);
    if (strict_equals(newValue, "")) {
      this.previousValue.current = "";
    }
  };
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "data-orientation": getDataOrientation(this.opts.orientation.current),
      [navigationMenuAttrs.sub]: "",
      [navigationMenuAttrs.menu]: "",
      ...this.attachment
    })),
    "NavigationMenuSubState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var NavigationMenuListState = class _NavigationMenuListState {
  static create(opts) {
    return NavigationMenuListContext.set(new _NavigationMenuListState(opts, NavigationMenuProviderContext.get()));
  }
  wrapperId = box(useId());
  wrapperRef = box(null);
  opts;
  context;
  attachment;
  wrapperAttachment = attachRef(this.wrapperRef, (v) => this.context.indicatorTrackRef.current = v);
  #listTriggers = tag(state([]), "NavigationMenuListState.listTriggers");
  get listTriggers() {
    return get(this.#listTriggers);
  }
  set listTriggers(value) {
    set(this.#listTriggers, value);
  }
  rovingFocusGroup;
  #wrapperMounted = tag(state(false), "NavigationMenuListState.wrapperMounted");
  get wrapperMounted() {
    return get(this.#wrapperMounted);
  }
  set wrapperMounted(value) {
    set(this.#wrapperMounted, value, true);
  }
  constructor(opts, context) {
    this.opts = opts;
    this.context = context;
    this.attachment = attachRef(this.opts.ref);
    this.rovingFocusGroup = new RovingFocusGroup({
      rootNode: opts.ref,
      candidateSelector: `${navigationMenuAttrs.selector("trigger")}:not([data-disabled]), ${navigationMenuAttrs.selector("link")}:not([data-disabled])`,
      loop: box.with(() => false),
      orientation: this.context.opts.orientation
    });
  }
  registerTrigger(trigger) {
    if (trigger) this.listTriggers.push(trigger);
    return () => {
      this.listTriggers = this.listTriggers.filter((t) => strict_equals(t.id, trigger.id, false));
    };
  }
  #wrapperProps = tag(user_derived(() => ({ id: this.wrapperId.current, ...this.wrapperAttachment })), "NavigationMenuListState.wrapperProps");
  get wrapperProps() {
    return get(this.#wrapperProps);
  }
  set wrapperProps(value) {
    set(this.#wrapperProps, value);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "data-orientation": getDataOrientation(this.context.opts.orientation.current),
      [navigationMenuAttrs.list]: "",
      ...this.attachment
    })),
    "NavigationMenuListState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var NavigationMenuItemState = class _NavigationMenuItemState {
  static create(opts) {
    return NavigationMenuItemContext.set(new _NavigationMenuItemState(opts, NavigationMenuListContext.get()));
  }
  opts;
  attachment;
  listContext;
  #contentNode = tag(state(null), "NavigationMenuItemState.contentNode");
  get contentNode() {
    return get(this.#contentNode);
  }
  set contentNode(value) {
    set(this.#contentNode, value, true);
  }
  #triggerNode = tag(state(null), "NavigationMenuItemState.triggerNode");
  get triggerNode() {
    return get(this.#triggerNode);
  }
  set triggerNode(value) {
    set(this.#triggerNode, value, true);
  }
  #focusProxyNode = tag(state(null), "NavigationMenuItemState.focusProxyNode");
  get focusProxyNode() {
    return get(this.#focusProxyNode);
  }
  set focusProxyNode(value) {
    set(this.#focusProxyNode, value, true);
  }
  restoreContentTabOrder = noop3;
  wasEscapeClose = false;
  #contentId = tag(user_derived(() => this.contentNode?.id), "NavigationMenuItemState.contentId");
  get contentId() {
    return get(this.#contentId);
  }
  set contentId(value) {
    set(this.#contentId, value);
  }
  #triggerId = tag(user_derived(() => this.triggerNode?.id), "NavigationMenuItemState.triggerId");
  get triggerId() {
    return get(this.#triggerId);
  }
  set triggerId(value) {
    set(this.#triggerId, value);
  }
  contentChildren = box(void 0);
  contentChild = box(void 0);
  contentProps = box({});
  domContext;
  constructor(opts, listContext) {
    this.opts = opts;
    this.listContext = listContext;
    this.domContext = new DOMContext(opts.ref);
    this.attachment = attachRef(this.opts.ref);
  }
  #handleContentEntry = (side = "start") => {
    if (!this.contentNode) return;
    this.restoreContentTabOrder();
    const candidates = getTabbableCandidates(this.contentNode);
    if (candidates.length) focusFirst2(strict_equals(side, "start") ? candidates : candidates.reverse(), () => this.domContext.getActiveElement());
  };
  #handleContentExit = () => {
    if (!this.contentNode) return;
    const candidates = getTabbableCandidates(this.contentNode);
    if (candidates.length) this.restoreContentTabOrder = removeFromTabOrder(candidates);
  };
  onEntryKeydown = this.#handleContentEntry;
  onFocusProxyEnter = this.#handleContentEntry;
  onRootContentClose = this.#handleContentExit;
  onContentFocusOutside = this.#handleContentExit;
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      [navigationMenuAttrs.item]: "",
      ...this.attachment
    })),
    "NavigationMenuItemState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var NavigationMenuTriggerState = class _NavigationMenuTriggerState {
  static create(opts) {
    return new _NavigationMenuTriggerState(opts, {
      provider: NavigationMenuProviderContext.get(),
      item: NavigationMenuItemContext.get(),
      list: NavigationMenuListContext.get(),
      sub: NavigationMenuSubContext.getOr(null)
    });
  }
  opts;
  attachment;
  focusProxyId = box(useId());
  focusProxyRef = box(null);
  focusProxyAttachment = attachRef(this.focusProxyRef, (v) => this.itemContext.focusProxyNode = v);
  context;
  itemContext;
  listContext;
  hasPointerMoveOpened = box(false);
  wasClickClose = false;
  #focusProxyMounted = tag(state(false), "NavigationMenuTriggerState.focusProxyMounted");
  get focusProxyMounted() {
    return get(this.#focusProxyMounted);
  }
  set focusProxyMounted(value) {
    set(this.#focusProxyMounted, value, true);
  }
  #open = tag(user_derived(() => strict_equals(this.itemContext.opts.value.current, this.context.opts.value.current)), "NavigationMenuTriggerState.open");
  get open() {
    return get(this.#open);
  }
  set open(value) {
    set(this.#open, value);
  }
  constructor(opts, context) {
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref, (v) => this.itemContext.triggerNode = v);
    this.hasPointerMoveOpened = boxAutoReset(false, { afterMs: 300, getWindow: () => getWindow(opts.ref.current) });
    this.context = context.provider;
    this.itemContext = context.item;
    this.listContext = context.list;
    watch(() => this.opts.ref.current, () => {
      const node = this.opts.ref.current;
      if (!node) return;
      return this.listContext.registerTrigger(node);
    });
  }
  onpointerenter = (_) => {
    this.wasClickClose = false;
    this.itemContext.wasEscapeClose = false;
  };
  onpointermove = whenMouse(() => {
    if (this.opts.disabled.current || this.wasClickClose || this.itemContext.wasEscapeClose || this.hasPointerMoveOpened.current || !this.itemContext.opts.openOnHover.current) {
      return;
    }
    this.context.onTriggerEnter(this.itemContext.opts.value.current, this.itemContext);
    this.hasPointerMoveOpened.current = true;
  });
  onpointerleave = whenMouse(() => {
    if (this.opts.disabled.current || !this.itemContext.opts.openOnHover.current) return;
    this.context.onTriggerLeave();
    this.hasPointerMoveOpened.current = false;
  });
  onclick = () => {
    if (this.hasPointerMoveOpened.current) return;
    const shouldClose = this.open && (!this.itemContext.opts.openOnHover.current || this.context.opts.isRootMenu);
    if (shouldClose) {
      this.context.onItemSelect("", null);
    } else if (!this.open) {
      this.context.onItemSelect(this.itemContext.opts.value.current, this.itemContext);
    }
    this.wasClickClose = shouldClose;
  };
  onkeydown = (e) => {
    const verticalEntryKey = strict_equals(this.context.opts.dir.current, "rtl") ? kbd_constants_exports.ARROW_LEFT : kbd_constants_exports.ARROW_RIGHT;
    const entryKey = { horizontal: kbd_constants_exports.ARROW_DOWN, vertical: verticalEntryKey }[this.context.opts.orientation.current];
    if (this.open && strict_equals(e.key, entryKey)) {
      this.itemContext.onEntryKeydown();
      e.preventDefault();
      return;
    }
    this.itemContext.listContext.rovingFocusGroup.handleKeydown(this.opts.ref.current, e);
  };
  focusProxyOnFocus = (e) => {
    const content = this.itemContext.contentNode;
    const prevFocusedElement = e.relatedTarget;
    const wasTriggerFocused = this.opts.ref.current && strict_equals(prevFocusedElement, this.opts.ref.current);
    const wasFocusFromContent = content?.contains(prevFocusedElement);
    if (wasTriggerFocused || !wasFocusFromContent) {
      this.itemContext.onFocusProxyEnter(wasTriggerFocused ? "start" : "end");
    }
  };
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      disabled: this.opts.disabled.current,
      "data-disabled": getDataDisabled(Boolean(this.opts.disabled.current)),
      "data-state": getDataOpenClosed(this.open),
      "data-value": this.itemContext.opts.value.current,
      "aria-expanded": getAriaExpanded(this.open),
      "aria-controls": this.itemContext.contentId,
      [navigationMenuAttrs.trigger]: "",
      onpointermove: this.onpointermove,
      onpointerleave: this.onpointerleave,
      onpointerenter: this.onpointerenter,
      onclick: this.onclick,
      onkeydown: this.onkeydown,
      ...this.attachment
    })),
    "NavigationMenuTriggerState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
  #focusProxyProps = tag(
    user_derived(() => ({
      id: this.focusProxyId.current,
      tabindex: 0,
      onfocus: this.focusProxyOnFocus,
      ...this.focusProxyAttachment
    })),
    "NavigationMenuTriggerState.focusProxyProps"
  );
  get focusProxyProps() {
    return get(this.#focusProxyProps);
  }
  set focusProxyProps(value) {
    set(this.#focusProxyProps, value);
  }
};
var LINK_SELECT_EVENT = new CustomEventDispatcher("bitsLinkSelect", { bubbles: true, cancelable: true });
var ROOT_CONTENT_DISMISS_EVENT = new CustomEventDispatcher("bitsRootContentDismiss", { cancelable: true, bubbles: true });
var NavigationMenuLinkState = class _NavigationMenuLinkState {
  static create(opts) {
    return new _NavigationMenuLinkState(opts, {
      provider: NavigationMenuProviderContext.get(),
      item: NavigationMenuItemContext.get()
    });
  }
  opts;
  context;
  attachment;
  #isFocused = tag(state(false), "NavigationMenuLinkState.isFocused");
  get isFocused() {
    return get(this.#isFocused);
  }
  set isFocused(value) {
    set(this.#isFocused, value, true);
  }
  constructor(opts, context) {
    this.opts = opts;
    this.context = context;
    this.attachment = attachRef(this.opts.ref);
  }
  onclick = (e) => {
    const currTarget = e.currentTarget;
    LINK_SELECT_EVENT.listen(currTarget, (e2) => this.opts.onSelect.current(e2), { once: true });
    const linkSelectEvent = LINK_SELECT_EVENT.dispatch(currTarget);
    if (!linkSelectEvent.defaultPrevented && !e.metaKey) {
      ROOT_CONTENT_DISMISS_EVENT.dispatch(currTarget);
    }
  };
  onkeydown = (e) => {
    if (this.context.item.contentNode) return;
    this.context.item.listContext.rovingFocusGroup.handleKeydown(this.opts.ref.current, e);
  };
  onfocus = (_) => {
    this.isFocused = true;
  };
  onblur = (_) => {
    this.isFocused = false;
  };
  #handlePointerDismiss = () => {
    const currentlyOpenValue = this.context.provider.opts.value.current;
    const isInsideOpenSubmenu = strict_equals(this.context.item.opts.value.current, currentlyOpenValue);
    const activeItem = this.context.item.listContext.context.activeItem;
    if (activeItem && !activeItem.opts.openOnHover.current) return;
    if (currentlyOpenValue && !isInsideOpenSubmenu) {
      this.context.provider.onItemDismiss();
    }
  };
  onpointerenter = () => {
    this.#handlePointerDismiss();
  };
  onpointermove = whenMouse(() => {
    this.#handlePointerDismiss();
  });
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "data-active": this.opts.active.current ? "" : void 0,
      "aria-current": this.opts.active.current ? "page" : void 0,
      "data-focused": this.isFocused ? "" : void 0,
      onclick: this.onclick,
      onkeydown: this.onkeydown,
      onfocus: this.onfocus,
      onblur: this.onblur,
      onpointerenter: this.onpointerenter,
      onpointermove: this.onpointermove,
      [navigationMenuAttrs.link]: "",
      ...this.attachment
    })),
    "NavigationMenuLinkState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var NavigationMenuIndicatorState = class _NavigationMenuIndicatorState {
  static create() {
    return new _NavigationMenuIndicatorState(NavigationMenuProviderContext.get());
  }
  context;
  #isVisible = tag(user_derived(() => Boolean(this.context.opts.value.current)), "NavigationMenuIndicatorState.isVisible");
  get isVisible() {
    return get(this.#isVisible);
  }
  set isVisible(value) {
    set(this.#isVisible, value);
  }
  constructor(context) {
    this.context = context;
  }
};
var NavigationMenuIndicatorImplState = class _NavigationMenuIndicatorImplState {
  static create(opts) {
    return new _NavigationMenuIndicatorImplState(opts, {
      provider: NavigationMenuProviderContext.get(),
      list: NavigationMenuListContext.get()
    });
  }
  opts;
  attachment;
  context;
  listContext;
  #position = tag(state(null), "NavigationMenuIndicatorImplState.position");
  get position() {
    return get(this.#position);
  }
  set position(value) {
    set(this.#position, value);
  }
  #isHorizontal = tag(user_derived(() => strict_equals(this.context.opts.orientation.current, "horizontal")), "NavigationMenuIndicatorImplState.isHorizontal");
  get isHorizontal() {
    return get(this.#isHorizontal);
  }
  set isHorizontal(value) {
    set(this.#isHorizontal, value);
  }
  #isVisible = tag(user_derived(() => !!this.context.opts.value.current), "NavigationMenuIndicatorImplState.isVisible");
  get isVisible() {
    return get(this.#isVisible);
  }
  set isVisible(value) {
    set(this.#isVisible, value);
  }
  #activeTrigger = tag(
    user_derived(() => {
      const items = this.listContext.listTriggers;
      const triggerNode = items.find((item) => strict_equals(item.getAttribute("data-value"), this.context.opts.value.current));
      return triggerNode ?? null;
    }),
    "NavigationMenuIndicatorImplState.activeTrigger"
  );
  get activeTrigger() {
    return get(this.#activeTrigger);
  }
  set activeTrigger(value) {
    set(this.#activeTrigger, value);
  }
  #shouldRender = tag(user_derived(() => strict_equals(this.position, null, false)), "NavigationMenuIndicatorImplState.shouldRender");
  get shouldRender() {
    return get(this.#shouldRender);
  }
  set shouldRender(value) {
    set(this.#shouldRender, value);
  }
  constructor(opts, context) {
    this.opts = opts;
    this.context = context.provider;
    this.listContext = context.list;
    this.attachment = attachRef(this.opts.ref);
    new SvelteResizeObserver(() => this.activeTrigger, this.handlePositionChange);
    new SvelteResizeObserver(() => this.context.indicatorTrackRef.current, this.handlePositionChange);
  }
  handlePositionChange = () => {
    if (!this.activeTrigger) return;
    this.position = {
      size: this.isHorizontal ? this.activeTrigger.offsetWidth : this.activeTrigger.offsetHeight,
      offset: this.isHorizontal ? this.activeTrigger.offsetLeft : this.activeTrigger.offsetTop
    };
  };
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "data-state": this.isVisible ? "visible" : "hidden",
      "data-orientation": getDataOrientation(this.context.opts.orientation.current),
      style: {
        position: "absolute",
        ...this.isHorizontal ? {
          left: 0,
          width: `${this.position?.size}px`,
          transform: `translateX(${this.position?.offset}px)`
        } : {
          top: 0,
          height: `${this.position?.size}px`,
          transform: `translateY(${this.position?.offset}px)`
        }
      },
      [navigationMenuAttrs.indicator]: "",
      ...this.attachment
    })),
    "NavigationMenuIndicatorImplState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var NavigationMenuContentState = class _NavigationMenuContentState {
  static create(opts) {
    return NavigationMenuContentContext.set(new _NavigationMenuContentState(opts, {
      provider: NavigationMenuProviderContext.get(),
      item: NavigationMenuItemContext.get(),
      list: NavigationMenuListContext.get()
    }));
  }
  opts;
  context;
  itemContext;
  listContext;
  attachment;
  #mounted = tag(state(false), "NavigationMenuContentState.mounted");
  get mounted() {
    return get(this.#mounted);
  }
  set mounted(value) {
    set(this.#mounted, value, true);
  }
  #open = tag(user_derived(() => strict_equals(this.itemContext.opts.value.current, this.context.opts.value.current)), "NavigationMenuContentState.open");
  get open() {
    return get(this.#open);
  }
  set open(value) {
    set(this.#open, value);
  }
  #value = tag(user_derived(() => this.itemContext.opts.value.current), "NavigationMenuContentState.value");
  get value() {
    return get(this.#value);
  }
  set value(value) {
    set(this.#value, value);
  }
  #isLastActiveValue = tag(
    user_derived(() => {
      if (this.context.viewportRef.current) {
        if (!this.context.opts.value.current && this.context.opts.previousValue.current) {
          return strict_equals(this.context.opts.previousValue.current, this.itemContext.opts.value.current);
        }
      }
      return false;
    }),
    "NavigationMenuContentState.isLastActiveValue"
  );
  get isLastActiveValue() {
    return get(this.#isLastActiveValue);
  }
  set isLastActiveValue(value) {
    set(this.#isLastActiveValue, value);
  }
  constructor(opts, context) {
    this.opts = opts;
    this.context = context.provider;
    this.itemContext = context.item;
    this.listContext = context.list;
    this.attachment = attachRef(this.opts.ref, (v) => this.itemContext.contentNode = v);
  }
  onpointerenter = (_) => {
    this.context.onContentEnter();
  };
  onpointerleave = whenMouse(() => {
    if (!this.itemContext.opts.openOnHover.current) return;
    this.context.onContentLeave();
  });
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      onpointerenter: this.onpointerenter,
      onpointerleave: this.onpointerleave,
      ...this.attachment
    })),
    "NavigationMenuContentState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var NavigationMenuContentImplState = class _NavigationMenuContentImplState {
  static create(opts, itemState) {
    return new _NavigationMenuContentImplState(opts, itemState ?? NavigationMenuItemContext.get());
  }
  opts;
  itemContext;
  context;
  listContext;
  attachment;
  #prevMotionAttribute = tag(state(null), "NavigationMenuContentImplState.prevMotionAttribute");
  get prevMotionAttribute() {
    return get(this.#prevMotionAttribute);
  }
  set prevMotionAttribute(value) {
    set(this.#prevMotionAttribute, value, true);
  }
  #motionAttribute = tag(
    user_derived(() => {
      const items = this.listContext.listTriggers;
      const values = items.map((item) => item.getAttribute("data-value")).filter(Boolean);
      if (strict_equals(this.context.opts.dir.current, "rtl")) values.reverse();
      const index = values.indexOf(this.context.opts.value.current);
      const prevIndex = values.indexOf(this.context.opts.previousValue.current);
      const isSelected = strict_equals(this.itemContext.opts.value.current, this.context.opts.value.current);
      const wasSelected = strict_equals(prevIndex, values.indexOf(this.itemContext.opts.value.current));
      if (!this.context.opts.value.current && !this.context.opts.previousValue.current) {
        untrack(() => this.prevMotionAttribute = null);
        return null;
      }
      if (!isSelected && !wasSelected) return untrack(() => this.prevMotionAttribute);
      const attribute = (() => {
        if (strict_equals(index, prevIndex, false)) {
          if (isSelected && strict_equals(prevIndex, -1, false)) return index > prevIndex ? "from-end" : "from-start";
          if (wasSelected && strict_equals(index, -1, false)) return index > prevIndex ? "to-start" : "to-end";
        }
        return null;
      })();
      untrack(() => this.prevMotionAttribute = attribute);
      return attribute;
    }),
    "NavigationMenuContentImplState.motionAttribute"
  );
  get motionAttribute() {
    return get(this.#motionAttribute);
  }
  set motionAttribute(value) {
    set(this.#motionAttribute, value);
  }
  domContext;
  constructor(opts, itemContext) {
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.itemContext = itemContext;
    this.listContext = itemContext.listContext;
    this.context = itemContext.listContext.context;
    this.domContext = new DOMContext(opts.ref);
    watch(
      [
        () => this.itemContext.opts.value.current,
        () => this.itemContext.triggerNode,
        () => this.opts.ref.current
      ],
      () => {
        const content = this.opts.ref.current;
        if (!(content && this.context.opts.isRootMenu)) return;
        const handleClose = () => {
          this.context.onItemDismiss();
          this.itemContext.onRootContentClose();
          if (content.contains(this.domContext.getActiveElement())) {
            this.itemContext.triggerNode?.focus();
          }
        };
        const removeListener = ROOT_CONTENT_DISMISS_EVENT.listen(content, handleClose);
        return () => {
          removeListener();
        };
      }
    );
  }
  onFocusOutside = (e) => {
    this.itemContext.onContentFocusOutside();
    const target = e.target;
    if (this.context.opts.rootNavigationMenuRef.current?.contains(target)) {
      e.preventDefault();
      return;
    }
    this.context.onItemDismiss();
  };
  onInteractOutside = (e) => {
    const target = e.target;
    const isTrigger = this.listContext.listTriggers.some((trigger) => trigger.contains(target));
    const isRootViewport = this.context.opts.isRootMenu && this.context.viewportRef.current?.contains(target);
    if (!this.context.opts.isRootMenu && !isTrigger) {
      this.context.onItemDismiss();
      return;
    }
    if (isTrigger || isRootViewport) {
      e.preventDefault();
      return;
    }
    if (!this.itemContext.opts.openOnHover.current) {
      this.context.onItemSelect("", null);
    }
  };
  onkeydown = (e) => {
    const target = e.target;
    if (!isElement2(target)) return;
    if (strict_equals(target.closest(navigationMenuAttrs.selector("menu")), this.context.opts.rootNavigationMenuRef.current, false)) return;
    const isMetaKey = e.altKey || e.ctrlKey || e.metaKey;
    const isTabKey = strict_equals(e.key, kbd_constants_exports.TAB) && !isMetaKey;
    const candidates = getTabbableCandidates(e.currentTarget);
    if (isTabKey) {
      const focusedElement = this.domContext.getActiveElement();
      const index = candidates.findIndex((candidate) => strict_equals(candidate, focusedElement));
      const isMovingBackwards = e.shiftKey;
      const nextCandidates = isMovingBackwards ? candidates.slice(0, index).reverse() : candidates.slice(index + 1, candidates.length);
      if (focusFirst2(nextCandidates, () => this.domContext.getActiveElement())) {
        e.preventDefault();
        return;
      } else {
        handleProxyFocus(this.itemContext.focusProxyNode);
        return;
      }
    }
    let activeEl = this.domContext.getActiveElement();
    if (this.itemContext.contentNode) {
      const focusedNode = this.itemContext.contentNode.querySelector("[data-focused]");
      if (focusedNode) {
        activeEl = focusedNode;
      }
    }
    if (strict_equals(activeEl, this.itemContext.triggerNode)) return;
    const newSelectedElement = useArrowNavigation(e, activeEl, void 0, {
      itemsArray: candidates,
      candidateSelector: navigationMenuAttrs.selector("link"),
      loop: false,
      enableIgnoredElement: true
    });
    newSelectedElement?.focus();
  };
  onEscapeKeydown = (_) => {
    this.context.onItemDismiss();
    this.itemContext.triggerNode?.focus();
    this.itemContext.wasEscapeClose = true;
  };
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "aria-labelledby": this.itemContext.triggerId,
      "data-motion": this.motionAttribute ?? void 0,
      "data-orientation": getDataOrientation(this.context.opts.orientation.current),
      "data-state": getDataOpenClosed(strict_equals(this.context.opts.value.current, this.itemContext.opts.value.current)),
      onkeydown: this.onkeydown,
      [navigationMenuAttrs.content]: "",
      ...this.attachment
    })),
    "NavigationMenuContentImplState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var NavigationMenuViewportState = class _NavigationMenuViewportState {
  static create(opts) {
    return new _NavigationMenuViewportState(opts, NavigationMenuProviderContext.get());
  }
  opts;
  context;
  attachment;
  #open = tag(user_derived(() => !!this.context.opts.value.current), "NavigationMenuViewportState.open");
  get open() {
    return get(this.#open);
  }
  set open(value) {
    set(this.#open, value);
  }
  #viewportWidth = tag(user_derived(() => this.size ? `${this.size.width}px` : void 0), "NavigationMenuViewportState.viewportWidth");
  get viewportWidth() {
    return get(this.#viewportWidth);
  }
  set viewportWidth(value) {
    set(this.#viewportWidth, value);
  }
  #viewportHeight = tag(user_derived(() => this.size ? `${this.size.height}px` : void 0), "NavigationMenuViewportState.viewportHeight");
  get viewportHeight() {
    return get(this.#viewportHeight);
  }
  set viewportHeight(value) {
    set(this.#viewportHeight, value);
  }
  #activeContentValue = tag(user_derived(() => this.context.opts.value.current), "NavigationMenuViewportState.activeContentValue");
  get activeContentValue() {
    return get(this.#activeContentValue);
  }
  set activeContentValue(value) {
    set(this.#activeContentValue, value);
  }
  #size = tag(state(null), "NavigationMenuViewportState.size");
  get size() {
    return get(this.#size);
  }
  set size(value) {
    set(this.#size, value, true);
  }
  #contentNode = tag(state(null), "NavigationMenuViewportState.contentNode");
  get contentNode() {
    return get(this.#contentNode);
  }
  set contentNode(value) {
    set(this.#contentNode, value, true);
  }
  #mounted = tag(state(false), "NavigationMenuViewportState.mounted");
  get mounted() {
    return get(this.#mounted);
  }
  set mounted(value) {
    set(this.#mounted, value, true);
  }
  constructor(opts, context) {
    this.opts = opts;
    this.context = context;
    this.attachment = attachRef(this.opts.ref, (v) => this.context.viewportRef.current = v);
    watch([() => this.activeContentValue, () => this.open], () => {
      afterTick(() => {
        const currNode = this.context.viewportRef.current;
        if (!currNode) return;
        const el = currNode.querySelector("[data-state=open]")?.children?.[0] ?? null;
        this.contentNode = el;
      });
    });
    new SvelteResizeObserver(() => this.contentNode, () => {
      if (this.contentNode) {
        this.size = {
          width: this.contentNode.offsetWidth,
          height: this.contentNode.offsetHeight
        };
      }
    });
    watch(() => this.mounted, () => {
      if (!this.mounted && this.size) {
        this.size = null;
      }
    });
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "data-state": getDataOpenClosed(this.open),
      "data-orientation": getDataOrientation(this.context.opts.orientation.current),
      style: {
        pointerEvents: !this.open && this.context.opts.isRootMenu ? "none" : void 0,
        "--bits-navigation-menu-viewport-width": this.viewportWidth,
        "--bits-navigation-menu-viewport-height": this.viewportHeight
      },
      [navigationMenuAttrs.viewport]: "",
      onpointerenter: this.context.onContentEnter,
      onpointerleave: this.context.onContentLeave,
      ...this.attachment
    })),
    "NavigationMenuViewportState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
function focusFirst2(candidates, getActiveElement3) {
  const previouslyFocusedElement = getActiveElement3();
  return candidates.some((candidate) => {
    if (strict_equals(candidate, previouslyFocusedElement)) return true;
    candidate.focus();
    return strict_equals(getActiveElement3(), previouslyFocusedElement, false);
  });
}
function removeFromTabOrder(candidates) {
  candidates.forEach((candidate) => {
    candidate.dataset.tabindex = candidate.getAttribute("tabindex") || "";
    candidate.setAttribute("tabindex", "-1");
  });
  return () => {
    candidates.forEach((candidate) => {
      const prevTabIndex = candidate.dataset.tabindex;
      candidate.setAttribute("tabindex", prevTabIndex);
    });
  };
}
function whenMouse(handler) {
  return (e) => strict_equals(e.pointerType, "mouse") ? handler(e) : void 0;
}
function handleProxyFocus(guard, focusOptions) {
  if (!guard) return;
  const ariaHidden = guard.getAttribute("aria-hidden");
  guard.removeAttribute("aria-hidden");
  guard.focus(focusOptions);
  afterSleep(0, () => {
    if (strict_equals(ariaHidden, null)) {
      guard.setAttribute("aria-hidden", "");
    } else {
      guard.setAttribute("aria-hidden", ariaHidden);
    }
  });
}

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu.svelte
Navigation_menu[FILENAME] = "node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu.svelte";
var root_270 = add_locations(from_html(`<nav><!></nav>`), Navigation_menu[FILENAME], [[49, 1]]);
function Navigation_menu($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Navigation_menu);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15, ""), onValueChange = prop($$props, "onValueChange", 3, noop3), delayDuration = prop($$props, "delayDuration", 3, 200), skipDelayDuration = prop($$props, "skipDelayDuration", 3, 300), dir = prop($$props, "dir", 3, "ltr"), orientation = prop($$props, "orientation", 3, "horizontal"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "id",
      "ref",
      "value",
      "onValueChange",
      "delayDuration",
      "skipDelayDuration",
      "dir",
      "orientation"
    ],
    "restProps"
  );
  const rootState = NavigationMenuRootState.create({
    id: box.with(() => id()),
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    delayDuration: box.with(() => delayDuration()),
    skipDelayDuration: box.with(() => skipDelayDuration()),
    dir: box.with(() => dir()),
    orientation: box.with(() => orientation()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps({ "aria-label": "main" }, restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Navigation_menu, 47, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var nav = root_270();
      attribute_effect(nav, () => ({ ...get(mergedProps) }));
      var node_2 = child(nav);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Navigation_menu, 50, 2);
      reset(nav);
      append($$anchor2, nav);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Navigation_menu,
      46,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navigation_menu = hmr(Navigation_menu, () => Navigation_menu[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navigation_menu[HMR].source;
    set(Navigation_menu[HMR].source, module.default[HMR].original);
  });
}
var navigation_menu_default = Navigation_menu;

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-content-impl.svelte
Navigation_menu_content_impl[FILENAME] = "node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-content-impl.svelte";
var root_419 = add_locations(from_html(`<div><!></div>`), Navigation_menu_content_impl[FILENAME], [[88, 4]]);
function Navigation_menu_content_impl($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Navigation_menu_content_impl);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onFocusOutside = prop($$props, "onFocusOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), escapeKeydownBehavior = prop($$props, "escapeKeydownBehavior", 3, "close"), interactOutsideBehavior = prop($$props, "interactOutsideBehavior", 3, "close"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "child",
      "children",
      "onInteractOutside",
      "onFocusOutside",
      "onEscapeKeydown",
      "escapeKeydownBehavior",
      "interactOutsideBehavior",
      "itemState",
      "onRefChange"
    ],
    "restProps"
  );
  const contentImplState = NavigationMenuContentImplState.create(
    {
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v) => {
        ref(v);
        untrack(() => $$props.onRefChange?.(v));
      })
    },
    $$props.itemState
  );
  if ($$props.itemState) {
    NavigationMenuItemContext.set($$props.itemState);
  }
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentImplState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    const children = wrap_snippet(Navigation_menu_content_impl, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let dismissibleProps = () => $$arg0?.().props;
      dismissibleProps();
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => escape_layer_default(node_1, {
          enabled: true,
          get ref() {
            return contentImplState.opts.ref;
          },
          onEscapeKeydown: (e) => {
            onEscapeKeydown()(e);
            if (e.defaultPrevented) return;
            contentImplState.onEscapeKeydown(e);
          },
          get escapeKeydownBehavior() {
            return escapeKeydownBehavior();
          },
          children: wrap_snippet(Navigation_menu_content_impl, ($$anchor3, $$slotProps) => {
            var fragment_2 = comment();
            const finalProps = tag(user_derived(() => mergeProps(get(mergedProps), dismissibleProps())), "finalProps");
            get(finalProps);
            var node_2 = first_child(fragment_2);
            {
              var consequent = ($$anchor4) => {
                var fragment_3 = comment();
                var node_3 = first_child(fragment_3);
                add_svelte_meta(() => snippet(node_3, () => $$props.child, () => ({ props: get(finalProps) })), "render", Navigation_menu_content_impl, 86, 4);
                append($$anchor4, fragment_3);
              };
              var alternate = ($$anchor4) => {
                var div = root_419();
                attribute_effect(div, () => ({ ...get(finalProps) }));
                var node_4 = child(div);
                add_svelte_meta(() => snippet(node_4, () => $$props.children ?? noop), "render", Navigation_menu_content_impl, 89, 5);
                reset(div);
                append($$anchor4, div);
              };
              add_svelte_meta(
                () => if_block(node_2, ($$render) => {
                  if ($$props.child) $$render(consequent);
                  else $$render(alternate, false);
                }),
                "if",
                Navigation_menu_content_impl,
                85,
                3
              );
            }
            append($$anchor3, fragment_2);
          }),
          $$slots: { default: true }
        }),
        "component",
        Navigation_menu_content_impl,
        74,
        2,
        { componentTag: "EscapeLayer" }
      );
      append($$anchor2, fragment_1);
    });
    add_svelte_meta(
      () => dismissible_layer_default(node, {
        get id() {
          return id();
        },
        get ref() {
          return contentImplState.opts.ref;
        },
        enabled: true,
        onInteractOutside: (e) => {
          onInteractOutside()(e);
          if (e.defaultPrevented) return;
          contentImplState.onInteractOutside(e);
        },
        onFocusOutside: (e) => {
          onFocusOutside()(e);
          if (e.defaultPrevented) return;
          contentImplState.onFocusOutside(e);
        },
        get interactOutsideBehavior() {
          return interactOutsideBehavior();
        },
        children,
        $$slots: { default: true }
      }),
      "component",
      Navigation_menu_content_impl,
      57,
      0,
      { componentTag: "DismissibleLayer" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navigation_menu_content_impl = hmr(Navigation_menu_content_impl, () => Navigation_menu_content_impl[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navigation_menu_content_impl[HMR].source;
    set(Navigation_menu_content_impl[HMR].source, module.default[HMR].original);
  });
}
var navigation_menu_content_impl_default = Navigation_menu_content_impl;

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-content.svelte
Navigation_menu_content[FILENAME] = "node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-content.svelte";
var root_271 = add_locations(from_html(`<!> <!>`, 1), Navigation_menu_content[FILENAME], []);
function Navigation_menu_content($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Navigation_menu_content);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "children",
      "child",
      "forceMount"
    ],
    "restProps"
  );
  const contentState = NavigationMenuContentState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    let $0 = user_derived(() => contentState.context.viewportRef.current || void 0);
    let $1 = user_derived(() => !contentState.context.viewportRef.current);
    add_svelte_meta(
      () => portal_default(node, {
        get to() {
          return get($0);
        },
        get disabled() {
          return get($1);
        },
        children: wrap_snippet(Navigation_menu_content, ($$anchor2, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          {
            const presence = wrap_snippet(Navigation_menu_content, function($$anchor3) {
              validate_snippet_args(...arguments);
              var fragment_2 = root_271();
              var node_2 = first_child(fragment_2);
              add_svelte_meta(
                () => navigation_menu_content_impl_default(node_2, spread_props(() => get(mergedProps), {
                  get children() {
                    return $$props.children;
                  },
                  get child() {
                    return $$props.child;
                  }
                })),
                "component",
                Navigation_menu_content,
                42,
                3,
                { componentTag: "NavigationMenuContentImpl" }
              );
              var node_3 = sibling(node_2, 2);
              validate_binding("bind:mounted={contentState.mounted}", () => contentState, () => "mounted", 43, 12);
              add_svelte_meta(
                () => mounted_default(node_3, {
                  get mounted() {
                    return contentState.mounted;
                  },
                  set mounted($$value) {
                    contentState.mounted = $$value;
                  }
                }),
                "component",
                Navigation_menu_content,
                43,
                3,
                { componentTag: "Mounted" }
              );
              append($$anchor3, fragment_2);
            });
            let $02 = user_derived(() => forceMount() || contentState.open || contentState.isLastActiveValue);
            add_svelte_meta(
              () => presence_layer_default(node_1, {
                get open() {
                  return get($02);
                },
                get ref() {
                  return contentState.opts.ref;
                },
                presence,
                $$slots: { presence: true }
              }),
              "component",
              Navigation_menu_content,
              37,
              1,
              { componentTag: "PresenceLayer" }
            );
          }
          append($$anchor2, fragment_1);
        }),
        $$slots: { default: true }
      }),
      "component",
      Navigation_menu_content,
      33,
      0,
      { componentTag: "Portal" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navigation_menu_content = hmr(Navigation_menu_content, () => Navigation_menu_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navigation_menu_content[HMR].source;
    set(Navigation_menu_content[HMR].source, module.default[HMR].original);
  });
}
var navigation_menu_content_default = Navigation_menu_content;

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-indicator-impl.svelte
Navigation_menu_indicator_impl[FILENAME] = "node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-indicator-impl.svelte";
var root_272 = add_locations(from_html(`<div><!></div>`), Navigation_menu_indicator_impl[FILENAME], [[31, 1]]);
function Navigation_menu_indicator_impl($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Navigation_menu_indicator_impl);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const indicatorState = NavigationMenuIndicatorImplState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, indicatorState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Navigation_menu_indicator_impl, 29, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_272();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Navigation_menu_indicator_impl, 32, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Navigation_menu_indicator_impl,
      28,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navigation_menu_indicator_impl = hmr(Navigation_menu_indicator_impl, () => Navigation_menu_indicator_impl[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navigation_menu_indicator_impl[HMR].source;
    set(Navigation_menu_indicator_impl[HMR].source, module.default[HMR].original);
  });
}
var navigation_menu_indicator_impl_default = Navigation_menu_indicator_impl;

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-indicator.svelte
Navigation_menu_indicator[FILENAME] = "node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-indicator.svelte";
function Navigation_menu_indicator($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Navigation_menu_indicator);
  var $$ownership_validator = create_ownership_validator($$props);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child",
      "forceMount"
    ],
    "restProps"
  );
  const indicatorState = NavigationMenuIndicatorState.create();
  const mergedProps = tag(user_derived(() => mergeProps(restProps)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => portal_default(node_1, {
          get to() {
            return indicatorState.context.indicatorTrackRef.current;
          },
          children: wrap_snippet(Navigation_menu_indicator, ($$anchor3, $$slotProps) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            {
              const presence = wrap_snippet(Navigation_menu_indicator, function($$anchor4) {
                validate_snippet_args(...arguments);
                var fragment_3 = comment();
                var node_3 = first_child(fragment_3);
                {
                  $$ownership_validator.binding("ref", navigation_menu_indicator_impl_default, ref);
                  add_svelte_meta(
                    () => navigation_menu_indicator_impl_default(node_3, spread_props(() => get(mergedProps), {
                      get children() {
                        return $$props.children;
                      },
                      get child() {
                        return $$props.child;
                      },
                      get id() {
                        return id();
                      },
                      get ref() {
                        return ref();
                      },
                      set ref($$value) {
                        ref($$value);
                      }
                    })),
                    "component",
                    Navigation_menu_indicator,
                    29,
                    4,
                    { componentTag: "NavigationMenuIndicatorImpl" }
                  );
                }
                append($$anchor4, fragment_3);
              });
              let $0 = user_derived(() => forceMount() || indicatorState.isVisible);
              let $1 = user_derived(() => box.with(() => ref()));
              add_svelte_meta(
                () => presence_layer_default(node_2, {
                  get open() {
                    return get($0);
                  },
                  get ref() {
                    return get($1);
                  },
                  presence,
                  $$slots: { presence: true }
                }),
                "component",
                Navigation_menu_indicator,
                27,
                2,
                { componentTag: "PresenceLayer" }
              );
            }
            append($$anchor3, fragment_2);
          }),
          $$slots: { default: true }
        }),
        "component",
        Navigation_menu_indicator,
        26,
        1,
        { componentTag: "Portal" }
      );
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (indicatorState.context.indicatorTrackRef.current) $$render(consequent);
      }),
      "if",
      Navigation_menu_indicator,
      25,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navigation_menu_indicator = hmr(Navigation_menu_indicator, () => Navigation_menu_indicator[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navigation_menu_indicator[HMR].source;
    set(Navigation_menu_indicator[HMR].source, module.default[HMR].original);
  });
}
var navigation_menu_indicator_default = Navigation_menu_indicator;

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-item.svelte
Navigation_menu_item[FILENAME] = "node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-item.svelte";
var root_273 = add_locations(from_html(`<li><!></li>`), Navigation_menu_item[FILENAME], [[36, 1]]);
function Navigation_menu_item($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Navigation_menu_item);
  const defaultId = createId(uid);
  let id = prop($$props, "id", 3, defaultId), value = prop($$props, "value", 3, defaultId), ref = prop($$props, "ref", 15, null), openOnHover = prop($$props, "openOnHover", 3, true), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "value",
      "ref",
      "child",
      "children",
      "openOnHover"
    ],
    "restProps"
  );
  const itemState = NavigationMenuItemState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    value: box.with(() => value()),
    openOnHover: box.with(() => openOnHover())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, itemState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Navigation_menu_item, 34, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var li = root_273();
      attribute_effect(li, () => ({ ...get(mergedProps) }));
      var node_2 = child(li);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Navigation_menu_item, 37, 2);
      reset(li);
      append($$anchor2, li);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Navigation_menu_item,
      33,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navigation_menu_item = hmr(Navigation_menu_item, () => Navigation_menu_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navigation_menu_item[HMR].source;
    set(Navigation_menu_item[HMR].source, module.default[HMR].original);
  });
}
var navigation_menu_item_default = Navigation_menu_item;

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-link.svelte
Navigation_menu_link[FILENAME] = "node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-link.svelte";
var root_274 = add_locations(from_html(`<a><!></a>`), Navigation_menu_link[FILENAME], [[37, 1]]);
function Navigation_menu_link($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Navigation_menu_link);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), active = prop($$props, "active", 3, false), onSelect = prop($$props, "onSelect", 3, noop3), tabindex = prop($$props, "tabindex", 3, 0), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "children",
      "active",
      "onSelect",
      "tabindex"
    ],
    "restProps"
  );
  const linkState = NavigationMenuLinkState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    active: box.with(() => active()),
    onSelect: box.with(() => onSelect())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, linkState.props, { tabindex: tabindex() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Navigation_menu_link, 35, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var a2 = root_274();
      attribute_effect(a2, () => ({ ...get(mergedProps) }));
      var node_2 = child(a2);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Navigation_menu_link, 38, 2);
      reset(a2);
      append($$anchor2, a2);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Navigation_menu_link,
      34,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navigation_menu_link = hmr(Navigation_menu_link, () => Navigation_menu_link[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navigation_menu_link[HMR].source;
    set(Navigation_menu_link[HMR].source, module.default[HMR].original);
  });
}
var navigation_menu_link_default = Navigation_menu_link;

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-list.svelte
Navigation_menu_list[FILENAME] = "node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-list.svelte";
var root_17 = add_locations(from_html(`<!> <!>`, 1), Navigation_menu_list[FILENAME], []);
var root_275 = add_locations(from_html(`<div><ul><!></ul></div> <!>`, 1), Navigation_menu_list[FILENAME], [[34, 1, [[35, 2]]]]);
function Navigation_menu_list($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Navigation_menu_list);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "children",
      "child",
      "ref"
    ],
    "restProps"
  );
  const listState = NavigationMenuListState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, listState.props)), "mergedProps");
  const wrapperProps = tag(user_derived(() => mergeProps(listState.wrapperProps)), "wrapperProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = root_17();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps), wrapperProps: get(wrapperProps) })), "render", Navigation_menu_list, 31, 1);
      var node_2 = sibling(node_1, 2);
      validate_binding("bind:mounted={listState.wrapperMounted}", () => listState, () => "wrapperMounted", 32, 10);
      add_svelte_meta(
        () => mounted_default(node_2, {
          get mounted() {
            return listState.wrapperMounted;
          },
          set mounted($$value) {
            listState.wrapperMounted = $$value;
          }
        }),
        "component",
        Navigation_menu_list,
        32,
        1,
        { componentTag: "Mounted" }
      );
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_2 = root_275();
      var div = first_child(fragment_2);
      attribute_effect(div, () => ({ ...get(wrapperProps) }));
      var ul = child(div);
      attribute_effect(ul, () => ({ ...get(mergedProps) }));
      var node_3 = child(ul);
      add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop), "render", Navigation_menu_list, 36, 3);
      reset(ul);
      reset(div);
      var node_4 = sibling(div, 2);
      validate_binding("bind:mounted={listState.wrapperMounted}", () => listState, () => "wrapperMounted", 39, 10);
      add_svelte_meta(
        () => mounted_default(node_4, {
          get mounted() {
            return listState.wrapperMounted;
          },
          set mounted($$value) {
            listState.wrapperMounted = $$value;
          }
        }),
        "component",
        Navigation_menu_list,
        39,
        1,
        { componentTag: "Mounted" }
      );
      append($$anchor2, fragment_2);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Navigation_menu_list,
      30,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navigation_menu_list = hmr(Navigation_menu_list, () => Navigation_menu_list[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navigation_menu_list[HMR].source;
    set(Navigation_menu_list[HMR].source, module.default[HMR].original);
  });
}
var navigation_menu_list_default = Navigation_menu_list;

// node_modules/bits-ui/dist/bits/utilities/visually-hidden/visually-hidden.svelte
Visually_hidden[FILENAME] = "node_modules/bits-ui/dist/bits/utilities/visually-hidden/visually-hidden.svelte";
var root_276 = add_locations(from_html(`<span><!></span>`), Visually_hidden[FILENAME], [[28, 1]]);
function Visually_hidden($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Visually_hidden);
  let restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "children", "child"], "restProps");
  const style = {
    position: "absolute",
    border: 0,
    width: "1px",
    display: "inline-block",
    height: "1px",
    padding: 0,
    margin: "-1px",
    overflow: "hidden",
    clip: "rect(0 0 0 0)",
    whiteSpace: "nowrap",
    wordWrap: "normal"
  };
  const mergedProps = tag(user_derived(() => mergeProps(restProps, { style })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Visually_hidden, 26, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_276();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Visually_hidden, 29, 2);
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Visually_hidden,
      25,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Visually_hidden = hmr(Visually_hidden, () => Visually_hidden[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Visually_hidden[HMR].source;
    set(Visually_hidden[HMR].source, module.default[HMR].original);
  });
}
var visually_hidden_default = Visually_hidden;

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-trigger.svelte
Navigation_menu_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-trigger.svelte";
var root_277 = add_locations(from_html(`<button><!></button>`), Navigation_menu_trigger[FILENAME], [[36, 1]]);
var root_420 = add_locations(from_html(`<span></span>`), Navigation_menu_trigger[FILENAME], [[45, 2]]);
var root_318 = add_locations(from_html(`<!> <!> <!>`, 1), Navigation_menu_trigger[FILENAME], []);
var root9 = add_locations(from_html(`<!> <!>`, 1), Navigation_menu_trigger[FILENAME], []);
function Navigation_menu_trigger($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Navigation_menu_trigger);
  let id = prop($$props, "id", 19, () => createId(uid)), disabled = prop($$props, "disabled", 3, false), ref = prop($$props, "ref", 15, null), tabindex = prop($$props, "tabindex", 3, 0), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "disabled",
      "children",
      "child",
      "ref",
      "tabindex"
    ],
    "restProps"
  );
  const triggerState = NavigationMenuTriggerState.create({
    id: box.with(() => id()),
    disabled: box.with(() => disabled() ?? false),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, triggerState.props, { tabindex: tabindex() })), "mergedProps");
  var fragment = root9();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Navigation_menu_trigger, 34, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_277();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Navigation_menu_trigger, 37, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Navigation_menu_trigger,
      33,
      0
    );
  }
  var node_3 = sibling(node, 2);
  {
    var consequent_2 = ($$anchor2) => {
      var fragment_2 = root_318();
      var node_4 = first_child(fragment_2);
      add_svelte_meta(() => visually_hidden_default(node_4, spread_props(() => triggerState.focusProxyProps)), "component", Navigation_menu_trigger, 42, 1, { componentTag: "VisuallyHidden" });
      var node_5 = sibling(node_4, 2);
      validate_binding("bind:mounted={triggerState.focusProxyMounted}", () => triggerState, () => "focusProxyMounted", 43, 10);
      add_svelte_meta(
        () => mounted_default(node_5, {
          get mounted() {
            return triggerState.focusProxyMounted;
          },
          set mounted($$value) {
            triggerState.focusProxyMounted = $$value;
          }
        }),
        "component",
        Navigation_menu_trigger,
        43,
        1,
        { componentTag: "Mounted" }
      );
      var node_6 = sibling(node_5, 2);
      {
        var consequent_1 = ($$anchor3) => {
          var span = root_420();
          template_effect(() => set_attribute(span, "aria-owns", triggerState.itemContext.contentId ?? void 0));
          append($$anchor3, span);
        };
        add_svelte_meta(
          () => if_block(node_6, ($$render) => {
            if (triggerState.context.viewportRef.current) $$render(consequent_1);
          }),
          "if",
          Navigation_menu_trigger,
          44,
          1
        );
      }
      append($$anchor2, fragment_2);
    };
    add_svelte_meta(
      () => if_block(node_3, ($$render) => {
        if (triggerState.open) $$render(consequent_2);
      }),
      "if",
      Navigation_menu_trigger,
      41,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navigation_menu_trigger = hmr(Navigation_menu_trigger, () => Navigation_menu_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navigation_menu_trigger[HMR].source;
    set(Navigation_menu_trigger[HMR].source, module.default[HMR].original);
  });
}
var navigation_menu_trigger_default = Navigation_menu_trigger;

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-viewport.svelte
Navigation_menu_viewport[FILENAME] = "node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-viewport.svelte";
var root_319 = add_locations(from_html(`<div><!></div>`), Navigation_menu_viewport[FILENAME], [[36, 3]]);
var root_18 = add_locations(from_html(`<!> <!>`, 1), Navigation_menu_viewport[FILENAME], []);
function Navigation_menu_viewport($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Navigation_menu_viewport);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "forceMount",
      "child",
      "children"
    ],
    "restProps"
  );
  const viewportState = NavigationMenuViewportState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, viewportState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    const presence = wrap_snippet(Navigation_menu_viewport, function($$anchor2) {
      validate_snippet_args(...arguments);
      var fragment_1 = root_18();
      var node_1 = first_child(fragment_1);
      {
        var consequent = ($$anchor3) => {
          var fragment_2 = comment();
          var node_2 = first_child(fragment_2);
          add_svelte_meta(() => snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Navigation_menu_viewport, 34, 3);
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var div = root_319();
          attribute_effect(div, () => ({ ...get(mergedProps) }));
          var node_3 = child(div);
          add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop), "render", Navigation_menu_viewport, 37, 4);
          reset(div);
          append($$anchor3, div);
        };
        add_svelte_meta(
          () => if_block(node_1, ($$render) => {
            if ($$props.child) $$render(consequent);
            else $$render(alternate, false);
          }),
          "if",
          Navigation_menu_viewport,
          33,
          2
        );
      }
      var node_4 = sibling(node_1, 2);
      validate_binding("bind:mounted={viewportState.mounted}", () => viewportState, () => "mounted", 40, 11);
      add_svelte_meta(
        () => mounted_default(node_4, {
          get mounted() {
            return viewportState.mounted;
          },
          set mounted($$value) {
            viewportState.mounted = $$value;
          }
        }),
        "component",
        Navigation_menu_viewport,
        40,
        2,
        { componentTag: "Mounted" }
      );
      append($$anchor2, fragment_1);
    });
    let $0 = user_derived(() => forceMount() || viewportState.open);
    add_svelte_meta(
      () => presence_layer_default(node, {
        get open() {
          return get($0);
        },
        get ref() {
          return viewportState.opts.ref;
        },
        presence,
        $$slots: { presence: true }
      }),
      "component",
      Navigation_menu_viewport,
      31,
      0,
      { componentTag: "PresenceLayer" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navigation_menu_viewport = hmr(Navigation_menu_viewport, () => Navigation_menu_viewport[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navigation_menu_viewport[HMR].source;
    set(Navigation_menu_viewport[HMR].source, module.default[HMR].original);
  });
}
var navigation_menu_viewport_default = Navigation_menu_viewport;

// node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-sub.svelte
Navigation_menu_sub[FILENAME] = "node_modules/bits-ui/dist/bits/navigation-menu/components/navigation-menu-sub.svelte";
var root_278 = add_locations(from_html(`<div><!></div>`), Navigation_menu_sub[FILENAME], [[43, 1]]);
function Navigation_menu_sub($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Navigation_menu_sub);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15, ""), onValueChange = prop($$props, "onValueChange", 3, noop3), orientation = prop($$props, "orientation", 3, "horizontal"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "id",
      "ref",
      "value",
      "onValueChange",
      "orientation"
    ],
    "restProps"
  );
  const rootState = NavigationMenuSubState.create({
    id: box.with(() => id()),
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    orientation: box.with(() => orientation()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Navigation_menu_sub, 41, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_278();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Navigation_menu_sub, 44, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Navigation_menu_sub,
      40,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Navigation_menu_sub = hmr(Navigation_menu_sub, () => Navigation_menu_sub[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Navigation_menu_sub[HMR].source;
    set(Navigation_menu_sub[HMR].source, module.default[HMR].original);
  });
}
var navigation_menu_sub_default = Navigation_menu_sub;

// node_modules/bits-ui/dist/bits/pagination/exports.js
var exports_exports23 = {};
__export(exports_exports23, {
  NextButton: () => pagination_next_button_default,
  Page: () => pagination_page_default,
  PrevButton: () => pagination_prev_button_default,
  Root: () => pagination_default
});

// node_modules/bits-ui/dist/bits/pagination/pagination.svelte.js
var paginationAttrs = createBitsAttrs({
  component: "pagination",
  parts: ["root", "page", "prev", "next"]
});
var PaginationRootContext = new Context("Pagination.Root");
var PaginationRootState = class _PaginationRootState {
  static create(opts) {
    return PaginationRootContext.set(new _PaginationRootState(opts));
  }
  opts;
  attachment;
  #totalPages = tag(
    user_derived(() => {
      if (strict_equals(this.opts.count.current, 0)) return 1;
      return Math.ceil(this.opts.count.current / this.opts.perPage.current);
    }),
    "PaginationRootState.totalPages"
  );
  get totalPages() {
    return get(this.#totalPages);
  }
  set totalPages(value) {
    set(this.#totalPages, value);
  }
  #range = tag(
    user_derived(() => {
      const start = (this.opts.page.current - 1) * this.opts.perPage.current;
      const end = Math.min(start + this.opts.perPage.current, this.opts.count.current);
      return { start: start + 1, end };
    }),
    "PaginationRootState.range"
  );
  get range() {
    return get(this.#range);
  }
  set range(value) {
    set(this.#range, value);
  }
  #pages = tag(
    user_derived(() => getPageItems({
      page: this.opts.page.current,
      totalPages: this.totalPages,
      siblingCount: this.opts.siblingCount.current
    })),
    "PaginationRootState.pages"
  );
  get pages() {
    return get(this.#pages);
  }
  set pages(value) {
    set(this.#pages, value);
  }
  #hasPrevPage = tag(user_derived(() => this.opts.page.current > 1), "PaginationRootState.hasPrevPage");
  get hasPrevPage() {
    return get(this.#hasPrevPage);
  }
  set hasPrevPage(value) {
    set(this.#hasPrevPage, value);
  }
  #hasNextPage = tag(user_derived(() => this.opts.page.current < this.totalPages), "PaginationRootState.hasNextPage");
  get hasNextPage() {
    return get(this.#hasNextPage);
  }
  set hasNextPage(value) {
    set(this.#hasNextPage, value);
  }
  constructor(opts) {
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
  }
  setPage(page) {
    this.opts.page.current = page;
  }
  getPageTriggerNodes() {
    const node = this.opts.ref.current;
    if (!node) return [];
    return Array.from(node.querySelectorAll("[data-pagination-page]"));
  }
  getButtonNode(type) {
    const node = this.opts.ref.current;
    if (!node) return;
    return node.querySelector(paginationAttrs.selector(type));
  }
  prevPage() {
    this.opts.page.current = Math.max(this.opts.page.current - 1, 1);
  }
  nextPage() {
    this.opts.page.current = Math.min(this.opts.page.current + 1, this.totalPages);
  }
  #snippetProps = tag(
    user_derived(() => ({
      pages: this.pages,
      range: this.range,
      currentPage: this.opts.page.current
    })),
    "PaginationRootState.snippetProps"
  );
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "data-orientation": getDataOrientation(this.opts.orientation.current),
      [paginationAttrs.root]: "",
      ...this.attachment
    })),
    "PaginationRootState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var PaginationPageState = class _PaginationPageState {
  static create(opts) {
    return new _PaginationPageState(opts, PaginationRootContext.get());
  }
  opts;
  root;
  attachment;
  #isSelected = tag(user_derived(() => strict_equals(this.opts.page.current.value, this.root.opts.page.current)), "PaginationPageState.#isSelected");
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  onclick(e) {
    if (this.opts.disabled.current) return;
    if (strict_equals(e.button, 0, false)) return;
    this.root.setPage(this.opts.page.current.value);
  }
  onkeydown(e) {
    if (strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ENTER)) {
      e.preventDefault();
      this.root.setPage(this.opts.page.current.value);
    } else {
      handleTriggerKeydown(e, this.opts.ref.current, this.root);
    }
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "aria-label": `Page ${this.opts.page.current.value}`,
      "data-value": `${this.opts.page.current.value}`,
      "data-selected": get(this.#isSelected) ? "" : void 0,
      [paginationAttrs.page]: "",
      //
      onclick: this.onclick,
      onkeydown: this.onkeydown,
      ...this.attachment
    })),
    "PaginationPageState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var PaginationButtonState = class _PaginationButtonState {
  static create(opts) {
    return new _PaginationButtonState(opts, PaginationRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  #action() {
    strict_equals(this.opts.type, "prev") ? this.root.prevPage() : this.root.nextPage();
  }
  #isDisabled = tag(
    user_derived(() => {
      if (this.opts.disabled.current) return true;
      if (strict_equals(this.opts.type, "prev")) return !this.root.hasPrevPage;
      if (strict_equals(this.opts.type, "next")) return !this.root.hasNextPage;
      return false;
    }),
    "PaginationButtonState.#isDisabled"
  );
  onclick(e) {
    if (this.opts.disabled.current) return;
    if (strict_equals(e.button, 0, false)) return;
    this.#action();
  }
  onkeydown(e) {
    if (strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ENTER)) {
      e.preventDefault();
      this.#action();
    } else {
      handleTriggerKeydown(e, this.opts.ref.current, this.root);
    }
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      [paginationAttrs[this.opts.type]]: "",
      disabled: get(this.#isDisabled),
      //
      onclick: this.onclick,
      onkeydown: this.onkeydown,
      ...this.attachment
    })),
    "PaginationButtonState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
function handleTriggerKeydown(e, node, root18) {
  if (!node || !root18.opts.ref.current) return;
  const items = root18.getPageTriggerNodes();
  const nextButton = root18.getButtonNode("next");
  const prevButton = root18.getButtonNode("prev");
  if (prevButton) {
    items.unshift(prevButton);
  }
  if (nextButton) {
    items.push(nextButton);
  }
  const currentIndex = items.indexOf(node);
  const dir = getElemDirection(root18.opts.ref.current);
  const { nextKey, prevKey } = getDirectionalKeys(dir, root18.opts.orientation.current);
  const loop = root18.opts.loop.current;
  const keyToIndex = {
    [nextKey]: currentIndex + 1,
    [prevKey]: currentIndex - 1,
    [kbd_constants_exports.HOME]: 0,
    [kbd_constants_exports.END]: items.length - 1
  };
  let itemIndex = keyToIndex[e.key];
  if (strict_equals(itemIndex, void 0)) return;
  e.preventDefault();
  if (itemIndex < 0 && loop) {
    itemIndex = items.length - 1;
  } else if (strict_equals(itemIndex, items.length) && loop) {
    itemIndex = 0;
  }
  const itemToFocus = items[itemIndex];
  if (!itemToFocus) return;
  itemToFocus.focus();
}
function getPageItems({ page = 1, totalPages, siblingCount = 1 }) {
  const pageItems = [];
  const pagesToShow = /* @__PURE__ */ new Set([1, totalPages]);
  const firstItemWithSiblings = 3 + siblingCount;
  const lastItemWithSiblings = totalPages - 2 - siblingCount;
  if (firstItemWithSiblings > lastItemWithSiblings) {
    for (let i = 2; i <= totalPages - 1; i++) {
      pagesToShow.add(i);
    }
  } else if (page < firstItemWithSiblings) {
    for (let i = 2; i <= Math.min(firstItemWithSiblings, totalPages); i++) {
      pagesToShow.add(i);
    }
  } else if (page > lastItemWithSiblings) {
    for (let i = totalPages - 1; i >= Math.max(lastItemWithSiblings, 2); i--) {
      pagesToShow.add(i);
    }
  } else {
    for (let i = Math.max(page - siblingCount, 2); i <= Math.min(page + siblingCount, totalPages); i++) {
      pagesToShow.add(i);
    }
  }
  function addPage(value) {
    pageItems.push({ type: "page", value, key: `page-${value}` });
  }
  function addEllipsis() {
    const id = useId();
    pageItems.push({ type: "ellipsis", key: `ellipsis-${id}` });
  }
  let lastNumber = 0;
  for (const p2 of Array.from(pagesToShow).sort((a2, b) => a2 - b)) {
    if (p2 - lastNumber > 1) {
      addEllipsis();
    }
    addPage(p2);
    lastNumber = p2;
  }
  return pageItems;
}

// node_modules/bits-ui/dist/bits/pagination/components/pagination.svelte
Pagination[FILENAME] = "node_modules/bits-ui/dist/bits/pagination/components/pagination.svelte";
var root_279 = add_locations(from_html(`<div><!></div>`), Pagination[FILENAME], [[51, 1]]);
function Pagination($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Pagination);
  let id = prop($$props, "id", 19, () => createId(uid)), perPage = prop($$props, "perPage", 3, 1), page = prop($$props, "page", 15, 1), ref = prop($$props, "ref", 15, null), siblingCount = prop($$props, "siblingCount", 3, 1), onPageChange = prop($$props, "onPageChange", 3, noop3), loop = prop($$props, "loop", 3, false), orientation = prop($$props, "orientation", 3, "horizontal"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "count",
      "perPage",
      "page",
      "ref",
      "siblingCount",
      "onPageChange",
      "loop",
      "orientation",
      "child",
      "children"
    ],
    "restProps"
  );
  const rootState = PaginationRootState.create({
    id: box.with(() => id()),
    count: box.with(() => $$props.count),
    perPage: box.with(() => perPage()),
    page: box.with(() => page(), (v) => {
      page(v);
      onPageChange()?.(v);
    }),
    loop: box.with(() => loop()),
    siblingCount: box.with(() => siblingCount()),
    orientation: box.with(() => orientation()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => ({ props: get(mergedProps), ...rootState.snippetProps }));
        add_svelte_meta(() => snippet(node_1, () => $$props.child, () => get($0)), "render", Pagination, 49, 1);
      }
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_279();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => rootState.snippetProps), "render", Pagination, 52, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Pagination,
      48,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Pagination = hmr(Pagination, () => Pagination[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Pagination[HMR].source;
    set(Pagination[HMR].source, module.default[HMR].original);
  });
}
var pagination_default = Pagination;

// node_modules/bits-ui/dist/bits/pagination/components/pagination-prev-button.svelte
Pagination_prev_button[FILENAME] = "node_modules/bits-ui/dist/bits/pagination/components/pagination-prev-button.svelte";
var root_280 = add_locations(from_html(`<button><!></button>`), Pagination_prev_button[FILENAME], [[35, 1]]);
function Pagination_prev_button($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Pagination_prev_button);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), type = prop($$props, "type", 3, "button"), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "child",
      "children",
      "ref",
      "type",
      "disabled"
    ],
    "restProps"
  );
  const prevButtonState = PaginationButtonState.create({
    type: "prev",
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => Boolean(disabled()))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, prevButtonState.props, { type: type() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Pagination_prev_button, 33, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_280();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Pagination_prev_button, 36, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Pagination_prev_button,
      32,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Pagination_prev_button = hmr(Pagination_prev_button, () => Pagination_prev_button[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Pagination_prev_button[HMR].source;
    set(Pagination_prev_button[HMR].source, module.default[HMR].original);
  });
}
var pagination_prev_button_default = Pagination_prev_button;

// node_modules/bits-ui/dist/bits/pagination/components/pagination-next-button.svelte
Pagination_next_button[FILENAME] = "node_modules/bits-ui/dist/bits/pagination/components/pagination-next-button.svelte";
var root_281 = add_locations(from_html(`<button><!></button>`), Pagination_next_button[FILENAME], [[35, 1]]);
function Pagination_next_button($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Pagination_next_button);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), type = prop($$props, "type", 3, "button"), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "child",
      "children",
      "ref",
      "type",
      "disabled"
    ],
    "restProps"
  );
  const nextButtonState = PaginationButtonState.create({
    type: "next",
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => Boolean(disabled()))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, nextButtonState.props, { type: type() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Pagination_next_button, 33, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_281();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Pagination_next_button, 36, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Pagination_next_button,
      32,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Pagination_next_button = hmr(Pagination_next_button, () => Pagination_next_button[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Pagination_next_button[HMR].source;
    set(Pagination_next_button[HMR].source, module.default[HMR].original);
  });
}
var pagination_next_button_default = Pagination_next_button;

// node_modules/bits-ui/dist/bits/pagination/components/pagination-page.svelte
Pagination_page[FILENAME] = "node_modules/bits-ui/dist/bits/pagination/components/pagination-page.svelte";
var root_282 = add_locations(from_html(`<button><!></button>`), Pagination_page[FILENAME], [[36, 1]]);
function Pagination_page($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Pagination_page);
  let id = prop($$props, "id", 19, () => createId(uid)), type = prop($$props, "type", 3, "button"), ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "page",
      "child",
      "children",
      "type",
      "ref",
      "disabled"
    ],
    "restProps"
  );
  const pageState = PaginationPageState.create({
    id: box.with(() => id()),
    page: box.with(() => $$props.page),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => Boolean(disabled()))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, pageState.props, { type: type() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Pagination_page, 34, 1);
      append($$anchor2, fragment_1);
    };
    var alternate_1 = ($$anchor2) => {
      var button = root_282();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_2 = comment();
          var node_3 = first_child(fragment_2);
          add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop), "render", Pagination_page, 38, 3);
          append($$anchor3, fragment_2);
        };
        var alternate = ($$anchor3) => {
          var text2 = text();
          template_effect(() => set_text(text2, $$props.page.value));
          append($$anchor3, text2);
        };
        add_svelte_meta(
          () => if_block(node_2, ($$render) => {
            if ($$props.children) $$render(consequent_1);
            else $$render(alternate, false);
          }),
          "if",
          Pagination_page,
          37,
          2
        );
      }
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate_1, false);
      }),
      "if",
      Pagination_page,
      33,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Pagination_page = hmr(Pagination_page, () => Pagination_page[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Pagination_page[HMR].source;
    set(Pagination_page[HMR].source, module.default[HMR].original);
  });
}
var pagination_page_default = Pagination_page;

// node_modules/bits-ui/dist/bits/pin-input/exports.js
var exports_exports24 = {};
__export(exports_exports24, {
  Cell: () => pin_input_cell_default,
  Root: () => pin_input_default
});

// node_modules/bits-ui/dist/bits/pin-input/components/pin-input.svelte
Pin_input[FILENAME] = "node_modules/bits-ui/dist/bits/pin-input/components/pin-input.svelte";
var root10 = add_locations(from_html(`<div><!> <div><input/></div></div>`), Pin_input[FILENAME], [[60, 0, [[63, 1, [[64, 2]]]]]]);
function Pin_input($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Pin_input);
  let id = prop($$props, "id", 19, () => createId(uid)), inputId = prop($$props, "inputId", 19, () => `${createId(uid)}-input`), ref = prop($$props, "ref", 15, null), maxlength = prop($$props, "maxlength", 3, 6), textalign = prop($$props, "textalign", 3, "left"), inputmode = prop($$props, "inputmode", 3, "numeric"), onComplete = prop($$props, "onComplete", 3, noop3), pushPasswordManagerStrategy = prop($$props, "pushPasswordManagerStrategy", 3, "increase-width"), containerClass = prop($$props, "class", 3, ""), autocomplete = prop($$props, "autocomplete", 3, "one-time-code"), disabled = prop($$props, "disabled", 3, false), value = prop($$props, "value", 15, ""), onValueChange = prop($$props, "onValueChange", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "inputId",
      "ref",
      "maxlength",
      "textalign",
      "pattern",
      "inputmode",
      "onComplete",
      "pushPasswordManagerStrategy",
      "class",
      "children",
      "autocomplete",
      "disabled",
      "value",
      "onValueChange",
      "pasteTransformer"
    ],
    "restProps"
  );
  const rootState = PinInputRootState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    inputId: box.with(() => inputId()),
    autocomplete: box.with(() => autocomplete()),
    maxLength: box.with(() => maxlength()),
    textAlign: box.with(() => textalign()),
    disabled: box.with(() => disabled()),
    inputmode: box.with(() => inputmode()),
    pattern: box.with(() => $$props.pattern),
    onComplete: box.with(() => onComplete()),
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    pushPasswordManagerStrategy: box.with(() => pushPasswordManagerStrategy()),
    pasteTransformer: box.with(() => $$props.pasteTransformer)
  });
  const mergedInputProps = tag(user_derived(() => mergeProps(restProps, rootState.inputProps)), "mergedInputProps");
  const mergedRootProps = tag(user_derived(() => mergeProps(rootState.rootProps, { class: containerClass() })), "mergedRootProps");
  const mergedInputWrapperProps = tag(user_derived(() => mergeProps(rootState.inputWrapperProps, {})), "mergedInputWrapperProps");
  var div = root10();
  attribute_effect(div, () => ({ ...get(mergedRootProps) }));
  var node = child(div);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop, () => rootState.snippetProps), "render", Pin_input, 61, 1);
  var div_1 = sibling(node, 2);
  attribute_effect(div_1, () => ({ ...get(mergedInputWrapperProps) }));
  var input = child(div_1);
  remove_input_defaults(input);
  attribute_effect(input, () => ({ ...get(mergedInputProps) }));
  reset(div_1);
  reset(div);
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Pin_input = hmr(Pin_input, () => Pin_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Pin_input[HMR].source;
    set(Pin_input[HMR].source, module.default[HMR].original);
  });
}
var pin_input_default = Pin_input;

// node_modules/bits-ui/dist/bits/pin-input/components/pin-input-cell.svelte
Pin_input_cell[FILENAME] = "node_modules/bits-ui/dist/bits/pin-input/components/pin-input-cell.svelte";
var root_283 = add_locations(from_html(`<div><!></div>`), Pin_input_cell[FILENAME], [[33, 1]]);
function Pin_input_cell($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Pin_input_cell);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "cell",
      "child",
      "children"
    ],
    "restProps"
  );
  const cellState = PinInputCellState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    cell: box.with(() => $$props.cell)
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, cellState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Pin_input_cell, 31, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_283();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Pin_input_cell, 34, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Pin_input_cell,
      30,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Pin_input_cell = hmr(Pin_input_cell, () => Pin_input_cell[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Pin_input_cell[HMR].source;
    set(Pin_input_cell[HMR].source, module.default[HMR].original);
  });
}
var pin_input_cell_default = Pin_input_cell;

// node_modules/bits-ui/dist/bits/popover/exports.js
var exports_exports25 = {};
__export(exports_exports25, {
  Arrow: () => popover_arrow_default,
  Close: () => popover_close_default,
  Content: () => popover_content_default,
  ContentStatic: () => popover_content_static_default,
  Portal: () => portal_default,
  Root: () => popover_default,
  Trigger: () => popover_trigger_default
});

// node_modules/bits-ui/dist/bits/popover/components/popover.svelte
Popover[FILENAME] = "node_modules/bits-ui/dist/bits/popover/components/popover.svelte";
function Popover($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Popover);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3);
  PopoverRootState.create({
    open: box.with(() => open(), (v) => {
      open(v);
      onOpenChange()(v);
    }),
    onOpenChangeComplete: box.with(() => onOpenChangeComplete())
  });
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => floating_layer_default(node, {
      children: wrap_snippet(Popover, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop), "render", Popover, 28, 1);
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }),
    "component",
    Popover,
    27,
    0,
    { componentTag: "FloatingLayer" }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Popover = hmr(Popover, () => Popover[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Popover[HMR].source;
    set(Popover[HMR].source, module.default[HMR].original);
  });
}
var popover_default = Popover;

// node_modules/bits-ui/dist/bits/progress/exports.js
var exports_exports26 = {};
__export(exports_exports26, {
  Root: () => progress_default
});

// node_modules/bits-ui/dist/bits/progress/progress.svelte.js
var progressAttrs = createBitsAttrs({ component: "progress", parts: ["root"] });
var ProgressRootState = class _ProgressRootState {
  static create(opts) {
    return new _ProgressRootState(opts);
  }
  opts;
  attachment;
  constructor(opts) {
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
  }
  #props = tag(
    user_derived(() => ({
      role: "progressbar",
      value: this.opts.value.current,
      "aria-valuemin": this.opts.min.current,
      "aria-valuemax": this.opts.max.current,
      "aria-valuenow": strict_equals(this.opts.value.current, null) ? void 0 : this.opts.value.current,
      "data-value": strict_equals(this.opts.value.current, null) ? void 0 : this.opts.value.current,
      "data-state": getProgressDataState(this.opts.value.current, this.opts.max.current),
      "data-max": this.opts.max.current,
      "data-min": this.opts.min.current,
      "data-indeterminate": strict_equals(this.opts.value.current, null) ? "" : void 0,
      [progressAttrs.root]: "",
      ...this.attachment
    })),
    "ProgressRootState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
function getProgressDataState(value, max) {
  if (strict_equals(value, null)) return "indeterminate";
  return strict_equals(value, max) ? "loaded" : "loading";
}

// node_modules/bits-ui/dist/bits/progress/components/progress.svelte
Progress[FILENAME] = "node_modules/bits-ui/dist/bits/progress/components/progress.svelte";
var root_284 = add_locations(from_html(`<div><!></div>`), Progress[FILENAME], [[37, 1]]);
function Progress($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Progress);
  let value = prop($$props, "value", 3, 0), max = prop($$props, "max", 3, 100), min = prop($$props, "min", 3, 0), id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "value",
      "max",
      "min",
      "id",
      "ref"
    ],
    "restProps"
  );
  const rootState = ProgressRootState.create({
    value: box.with(() => value()),
    max: box.with(() => max()),
    min: box.with(() => min()),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Progress, 35, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_284();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Progress, 38, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Progress,
      34,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Progress = hmr(Progress, () => Progress[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Progress[HMR].source;
    set(Progress[HMR].source, module.default[HMR].original);
  });
}
var progress_default = Progress;

// node_modules/bits-ui/dist/bits/radio-group/exports.js
var exports_exports27 = {};
__export(exports_exports27, {
  Item: () => radio_group_item_default,
  Root: () => radio_group_default
});

// node_modules/bits-ui/dist/bits/radio-group/radio-group.svelte.js
var radioGroupAttrs = createBitsAttrs({ component: "radio-group", parts: ["root", "item"] });
var RadioGroupRootContext = new Context("RadioGroup.Root");
var RadioGroupRootState = class _RadioGroupRootState {
  static create(opts) {
    return RadioGroupRootContext.set(new _RadioGroupRootState(opts));
  }
  opts;
  #hasValue = tag(user_derived(() => strict_equals(this.opts.value.current, "", false)), "RadioGroupRootState.hasValue");
  get hasValue() {
    return get(this.#hasValue);
  }
  set hasValue(value) {
    set(this.#hasValue, value);
  }
  rovingFocusGroup;
  attachment;
  constructor(opts) {
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.rovingFocusGroup = new RovingFocusGroup({
      rootNode: this.opts.ref,
      candidateAttr: radioGroupAttrs.item,
      loop: this.opts.loop,
      orientation: this.opts.orientation
    });
  }
  isChecked(value) {
    return strict_equals(this.opts.value.current, value);
  }
  setValue(value) {
    this.opts.value.current = value;
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "radiogroup",
      "aria-required": getAriaRequired(this.opts.required.current),
      "aria-disabled": getAriaDisabled(this.opts.disabled.current),
      "aria-readonly": this.opts.readonly.current ? "true" : void 0,
      "data-disabled": getDataDisabled(this.opts.disabled.current),
      "data-readonly": getDataReadonly(this.opts.readonly.current),
      "data-orientation": this.opts.orientation.current,
      [radioGroupAttrs.root]: "",
      ...this.attachment
    })),
    "RadioGroupRootState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var RadioGroupItemState = class _RadioGroupItemState {
  static create(opts) {
    return new _RadioGroupItemState(opts, RadioGroupRootContext.get());
  }
  opts;
  root;
  attachment;
  #checked = tag(user_derived(() => strict_equals(this.root.opts.value.current, this.opts.value.current)), "RadioGroupItemState.checked");
  get checked() {
    return get(this.#checked);
  }
  set checked(value) {
    set(this.#checked, value);
  }
  #isDisabled = tag(user_derived(() => this.opts.disabled.current || this.root.opts.disabled.current), "RadioGroupItemState.#isDisabled");
  #isReadonly = tag(user_derived(() => this.root.opts.readonly.current), "RadioGroupItemState.#isReadonly");
  #isChecked = tag(user_derived(() => this.root.isChecked(this.opts.value.current)), "RadioGroupItemState.#isChecked");
  #tabIndex = tag(state(-1), "RadioGroupItemState.#tabIndex");
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    if (strict_equals(this.opts.value.current, this.root.opts.value.current)) {
      this.root.rovingFocusGroup.setCurrentTabStopId(this.opts.id.current);
      set(this.#tabIndex, 0);
    } else if (!this.root.opts.value.current) {
      set(this.#tabIndex, 0);
    }
    user_effect(() => {
      set(this.#tabIndex, this.root.rovingFocusGroup.getTabIndex(this.opts.ref.current), true);
    });
    watch(
      [
        () => this.opts.value.current,
        () => this.root.opts.value.current
      ],
      () => {
        if (strict_equals(this.opts.value.current, this.root.opts.value.current)) {
          this.root.rovingFocusGroup.setCurrentTabStopId(this.opts.id.current);
          set(this.#tabIndex, 0);
        }
      }
    );
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
    this.onfocus = this.onfocus.bind(this);
  }
  onclick(_) {
    if (this.opts.disabled.current || get(this.#isReadonly)) return;
    this.root.setValue(this.opts.value.current);
  }
  onfocus(_) {
    if (!this.root.hasValue || get(this.#isReadonly)) return;
    this.root.setValue(this.opts.value.current);
  }
  onkeydown(e) {
    if (get(this.#isDisabled)) return;
    if (strict_equals(e.key, kbd_constants_exports.SPACE)) {
      e.preventDefault();
      if (!get(this.#isReadonly)) {
        this.root.setValue(this.opts.value.current);
      }
      return;
    }
    this.root.rovingFocusGroup.handleKeydown(this.opts.ref.current, e, true);
  }
  #snippetProps = tag(user_derived(() => ({ checked: get(this.#isChecked) })), "RadioGroupItemState.snippetProps");
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      disabled: get(this.#isDisabled) ? true : void 0,
      "data-value": this.opts.value.current,
      "data-orientation": this.root.opts.orientation.current,
      "data-disabled": getDataDisabled(get(this.#isDisabled)),
      "data-readonly": getDataReadonly(get(this.#isReadonly)),
      "data-state": get(this.#isChecked) ? "checked" : "unchecked",
      "aria-checked": getAriaChecked(get(this.#isChecked), false),
      [radioGroupAttrs.item]: "",
      type: "button",
      role: "radio",
      tabindex: get(this.#tabIndex),
      onkeydown: this.onkeydown,
      onfocus: this.onfocus,
      onclick: this.onclick,
      ...this.attachment
    })),
    "RadioGroupItemState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var RadioGroupInputState = class _RadioGroupInputState {
  static create() {
    return new _RadioGroupInputState(RadioGroupRootContext.get());
  }
  root;
  #shouldRender = tag(user_derived(() => strict_equals(this.root.opts.name.current, void 0, false)), "RadioGroupInputState.shouldRender");
  get shouldRender() {
    return get(this.#shouldRender);
  }
  set shouldRender(value) {
    set(this.#shouldRender, value);
  }
  #props = tag(
    user_derived(() => ({
      name: this.root.opts.name.current,
      value: this.root.opts.value.current,
      required: this.root.opts.required.current,
      disabled: this.root.opts.disabled.current
    })),
    "RadioGroupInputState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
  constructor(root18) {
    this.root = root18;
  }
};

// node_modules/bits-ui/dist/bits/radio-group/components/radio-group-input.svelte
Radio_group_input[FILENAME] = "node_modules/bits-ui/dist/bits/radio-group/components/radio-group-input.svelte";
function Radio_group_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Radio_group_input);
  const inputState = RadioGroupInputState.create();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => hidden_input_default(node_1, spread_props(() => inputState.props)), "component", Radio_group_input, 9, 1, { componentTag: "HiddenInput" });
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (inputState.shouldRender) $$render(consequent);
      }),
      "if",
      Radio_group_input,
      8,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Radio_group_input = hmr(Radio_group_input, () => Radio_group_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Radio_group_input[HMR].source;
    set(Radio_group_input[HMR].source, module.default[HMR].original);
  });
}
var radio_group_input_default = Radio_group_input;

// node_modules/bits-ui/dist/bits/radio-group/components/radio-group.svelte
Radio_group[FILENAME] = "node_modules/bits-ui/dist/bits/radio-group/components/radio-group.svelte";
var root_285 = add_locations(from_html(`<div><!></div>`), Radio_group[FILENAME], [[55, 1]]);
var root11 = add_locations(from_html(`<!> <!>`, 1), Radio_group[FILENAME], []);
function Radio_group($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Radio_group);
  let disabled = prop($$props, "disabled", 3, false), value = prop($$props, "value", 15, ""), ref = prop($$props, "ref", 15, null), orientation = prop($$props, "orientation", 3, "vertical"), loop = prop($$props, "loop", 3, true), name = prop($$props, "name", 3, void 0), required = prop($$props, "required", 3, false), readonly = prop($$props, "readonly", 3, false), id = prop($$props, "id", 19, () => createId(uid)), onValueChange = prop($$props, "onValueChange", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "disabled",
      "children",
      "child",
      "value",
      "ref",
      "orientation",
      "loop",
      "name",
      "required",
      "readonly",
      "id",
      "onValueChange"
    ],
    "restProps"
  );
  const rootState = RadioGroupRootState.create({
    orientation: box.with(() => orientation()),
    disabled: box.with(() => disabled()),
    loop: box.with(() => loop()),
    name: box.with(() => name()),
    required: box.with(() => required()),
    readonly: box.with(() => readonly()),
    id: box.with(() => id()),
    value: box.with(() => value(), (v) => {
      if (strict_equals(v, value())) return;
      value(v);
      onValueChange()?.(v);
    }),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = root11();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Radio_group, 53, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_285();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Radio_group, 56, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Radio_group,
      52,
      0
    );
  }
  var node_3 = sibling(node, 2);
  add_svelte_meta(() => radio_group_input_default(node_3, {}), "component", Radio_group, 60, 0, { componentTag: "RadioGroupInput" });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Radio_group = hmr(Radio_group, () => Radio_group[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Radio_group[HMR].source;
    set(Radio_group[HMR].source, module.default[HMR].original);
  });
}
var radio_group_default = Radio_group;

// node_modules/bits-ui/dist/bits/radio-group/components/radio-group-item.svelte
Radio_group_item[FILENAME] = "node_modules/bits-ui/dist/bits/radio-group/components/radio-group-item.svelte";
var root_286 = add_locations(from_html(`<button><!></button>`), Radio_group_item[FILENAME], [[35, 1]]);
function Radio_group_item($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Radio_group_item);
  let id = prop($$props, "id", 19, () => createId(uid)), disabled = prop($$props, "disabled", 3, false), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "children",
      "child",
      "value",
      "disabled",
      "ref"
    ],
    "restProps"
  );
  const itemState = RadioGroupItemState.create({
    value: box.with(() => $$props.value),
    disabled: box.with(() => disabled() ?? false),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, itemState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => ({ props: get(mergedProps), ...itemState.snippetProps }));
        add_svelte_meta(() => snippet(node_1, () => $$props.child, () => get($0)), "render", Radio_group_item, 33, 1);
      }
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_286();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => itemState.snippetProps), "render", Radio_group_item, 36, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Radio_group_item,
      32,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Radio_group_item = hmr(Radio_group_item, () => Radio_group_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Radio_group_item[HMR].source;
    set(Radio_group_item[HMR].source, module.default[HMR].original);
  });
}
var radio_group_item_default = Radio_group_item;

// node_modules/bits-ui/dist/bits/range-calendar/exports.js
var exports_exports28 = {};
__export(exports_exports28, {
  Cell: () => range_calendar_cell_default,
  Day: () => range_calendar_day_default,
  Grid: () => calendar_grid_default,
  GridBody: () => calendar_grid_body_default,
  GridHead: () => calendar_grid_head_default,
  GridRow: () => calendar_grid_row_default,
  HeadCell: () => calendar_head_cell_default,
  Header: () => calendar_header_default,
  Heading: () => calendar_heading_default,
  MonthSelect: () => calendar_month_select_default,
  NextButton: () => calendar_next_button_default,
  PrevButton: () => calendar_prev_button_default,
  Root: () => range_calendar_default,
  YearSelect: () => calendar_year_select_default
});

// node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar.svelte
Range_calendar[FILENAME] = "node_modules/bits-ui/dist/bits/range-calendar/components/range-calendar.svelte";
var root_287 = add_locations(from_html(`<div><!></div>`), Range_calendar[FILENAME], [[148, 1]]);
function Range_calendar($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Range_calendar);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop3), placeholder = prop($$props, "placeholder", 15), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop3), weekdayFormat = prop($$props, "weekdayFormat", 3, "narrow"), pagedNavigation = prop($$props, "pagedNavigation", 3, false), isDateDisabled = prop($$props, "isDateDisabled", 3, () => false), isDateUnavailable = prop($$props, "isDateUnavailable", 3, () => false), fixedWeeks = prop($$props, "fixedWeeks", 3, false), numberOfMonths = prop($$props, "numberOfMonths", 3, 1), calendarLabel = prop($$props, "calendarLabel", 3, "Event"), disabled = prop($$props, "disabled", 3, false), readonly = prop($$props, "readonly", 3, false), minValue = prop($$props, "minValue", 3, void 0), maxValue = prop($$props, "maxValue", 3, void 0), preventDeselect = prop($$props, "preventDeselect", 3, false), disableDaysOutsideMonth = prop($$props, "disableDaysOutsideMonth", 3, true), onStartValueChange = prop($$props, "onStartValueChange", 3, noop3), onEndValueChange = prop($$props, "onEndValueChange", 3, noop3), excludeDisabled = prop($$props, "excludeDisabled", 3, false), monthFormat = prop($$props, "monthFormat", 3, "long"), yearFormat = prop($$props, "yearFormat", 3, "numeric"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "value",
      "onValueChange",
      "placeholder",
      "onPlaceholderChange",
      "weekdayFormat",
      "weekStartsOn",
      "pagedNavigation",
      "isDateDisabled",
      "isDateUnavailable",
      "fixedWeeks",
      "numberOfMonths",
      "locale",
      "calendarLabel",
      "disabled",
      "readonly",
      "minValue",
      "maxValue",
      "preventDeselect",
      "disableDaysOutsideMonth",
      "minDays",
      "maxDays",
      "onStartValueChange",
      "onEndValueChange",
      "excludeDisabled",
      "monthFormat",
      "yearFormat"
    ],
    "restProps"
  );
  let startValue = tag(state(proxy(value()?.start)), "startValue");
  let endValue = tag(state(proxy(value()?.end)), "endValue");
  const defaultPlaceholder = getDefaultDate({ defaultValue: value()?.start });
  function handleDefaultPlaceholder() {
    if (strict_equals(placeholder(), void 0, false)) return;
    placeholder(defaultPlaceholder);
  }
  handleDefaultPlaceholder();
  watch.pre(() => placeholder(), () => {
    handleDefaultPlaceholder();
  });
  function handleDefaultValue() {
    if (strict_equals(value(), void 0, false)) return;
    value({ start: void 0, end: void 0 });
  }
  handleDefaultValue();
  watch.pre(() => value(), () => {
    handleDefaultValue();
  });
  const rootState = RangeCalendarRootState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    placeholder: box.with(() => placeholder(), (v) => {
      placeholder(v);
      onPlaceholderChange()(v);
    }),
    disabled: box.with(() => disabled()),
    readonly: box.with(() => readonly()),
    preventDeselect: box.with(() => preventDeselect()),
    minValue: box.with(() => minValue()),
    maxValue: box.with(() => maxValue()),
    isDateUnavailable: box.with(() => isDateUnavailable()),
    isDateDisabled: box.with(() => isDateDisabled()),
    pagedNavigation: box.with(() => pagedNavigation()),
    weekStartsOn: box.with(() => $$props.weekStartsOn),
    weekdayFormat: box.with(() => weekdayFormat()),
    numberOfMonths: box.with(() => numberOfMonths()),
    locale: resolveLocaleProp(() => $$props.locale),
    calendarLabel: box.with(() => calendarLabel()),
    fixedWeeks: box.with(() => fixedWeeks()),
    disableDaysOutsideMonth: box.with(() => disableDaysOutsideMonth()),
    minDays: box.with(() => $$props.minDays),
    maxDays: box.with(() => $$props.maxDays),
    excludeDisabled: box.with(() => excludeDisabled()),
    startValue: box.with(() => get(startValue), (v) => {
      set(startValue, v, true);
      onStartValueChange()(v);
    }),
    endValue: box.with(() => get(endValue), (v) => {
      set(endValue, v, true);
      onEndValueChange()(v);
    }),
    monthFormat: box.with(() => monthFormat()),
    yearFormat: box.with(() => yearFormat()),
    defaultPlaceholder
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => ({ props: get(mergedProps), ...rootState.snippetProps }));
        add_svelte_meta(() => snippet(node_1, () => $$props.child, () => get($0)), "render", Range_calendar, 146, 1);
      }
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_287();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => rootState.snippetProps), "render", Range_calendar, 149, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Range_calendar,
      145,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Range_calendar = hmr(Range_calendar, () => Range_calendar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Range_calendar[HMR].source;
    set(Range_calendar[HMR].source, module.default[HMR].original);
  });
}
var range_calendar_default = Range_calendar;

// node_modules/bits-ui/dist/bits/rating-group/exports.js
var exports_exports29 = {};
__export(exports_exports29, {
  Item: () => rating_group_item_default,
  Root: () => rating_group_default
});

// node_modules/bits-ui/dist/bits/rating-group/rating-group.svelte.js
var ratingGroupAttrs = createBitsAttrs({ component: "rating-group", parts: ["root", "item"] });
var RatingGroupRootContext = new Context("RatingGroup.Root");
var RatingGroupRootState = class _RatingGroupRootState {
  static create(opts) {
    return RatingGroupRootContext.set(new _RatingGroupRootState(opts));
  }
  opts;
  attachment;
  #hoverValue = tag(state(null), "RatingGroupRootState.#hoverValue");
  #keySequence = tag(state(""), "RatingGroupRootState.#keySequence");
  #keySequenceTimeout = null;
  domContext;
  #hasValue = tag(user_derived(() => this.opts.value.current > 0), "RatingGroupRootState.hasValue");
  get hasValue() {
    return get(this.#hasValue);
  }
  set hasValue(value) {
    set(this.#hasValue, value);
  }
  #valueToUse = tag(user_derived(() => get(this.#hoverValue) ?? this.opts.value.current), "RatingGroupRootState.valueToUse");
  get valueToUse() {
    return get(this.#valueToUse);
  }
  set valueToUse(value) {
    set(this.#valueToUse, value);
  }
  #isRTL = tag(
    user_derived(() => {
      const element2 = this.opts.ref.current;
      if (!element2) return false;
      const style = getComputedStyle(element2);
      return strict_equals(style.direction, "rtl");
    }),
    "RatingGroupRootState.isRTL"
  );
  get isRTL() {
    return get(this.#isRTL);
  }
  set isRTL(value) {
    set(this.#isRTL, value);
  }
  #ariaValuetext = tag(
    user_derived(() => {
      return strict_equals(typeof this.opts.ariaValuetext.current, "function") ? this.opts.ariaValuetext.current(this.opts.value.current, this.opts.max.current) : this.opts.ariaValuetext.current;
    }),
    "RatingGroupRootState.ariaValuetext"
  );
  get ariaValuetext() {
    return get(this.#ariaValuetext);
  }
  set ariaValuetext(value) {
    set(this.#ariaValuetext, value);
  }
  #items = tag(
    user_derived(() => {
      const value = this.valueToUse;
      return Array.from({ length: this.opts.max.current }, (_, i) => {
        const itemValue = i + 1;
        const halfValue = itemValue - 0.5;
        const state2 = value >= itemValue ? "active" : this.opts.allowHalf.current && value >= halfValue ? "partial" : "inactive";
        return { index: i, state: state2 };
      });
    }),
    "RatingGroupRootState.items"
  );
  get items() {
    return get(this.#items);
  }
  set items(value) {
    set(this.#items, value);
  }
  constructor(opts) {
    this.opts = opts;
    this.attachment = attachRef(opts.ref);
    this.onkeydown = this.onkeydown.bind(this);
    this.onpointerleave = this.onpointerleave.bind(this);
    this.domContext = new DOMContext(this.opts.ref);
  }
  isActive(itemIndex) {
    return this.valueToUse >= itemIndex + 1;
  }
  isPartial(itemIndex) {
    if (!this.opts.allowHalf.current) return false;
    const itemValue = itemIndex + 1;
    return this.valueToUse >= itemValue - 0.5 && this.valueToUse < itemValue;
  }
  setHoverValue(value) {
    if (this.opts.readonly.current || this.opts.disabled.current || !this.opts.hoverPreview.current) return;
    set(
      this.#hoverValue,
      strict_equals(value, null) ? null : Math.max(this.opts.min.current, Math.min(this.opts.max.current, value)),
      true
    );
  }
  setValue(value) {
    if (this.opts.readonly.current || this.opts.disabled.current) return;
    this.opts.value.current = Math.max(this.opts.min.current, Math.min(this.opts.max.current, value));
  }
  calculateRatingFromPointer(itemIndex, event) {
    const ratingValue = itemIndex + 1;
    if (!this.opts.allowHalf.current) return ratingValue;
    const rect = event.currentTarget.getBoundingClientRect();
    const style = getComputedStyle(event.currentTarget);
    const isHorizontal = strict_equals(this.opts.orientation.current, "horizontal");
    const position = isHorizontal ? (event.clientX - rect.left) / rect.width : (event.clientY - rect.top) / rect.height;
    const normalizedPosition = strict_equals(style.direction, "rtl") ? 1 - position : position;
    return normalizedPosition < 0.5 ? ratingValue - 0.5 : ratingValue;
  }
  onpointerleave() {
    this.setHoverValue(null);
  }
  handlers = {
    [kbd_constants_exports.ARROW_UP]: () => {
      this.setHoverValue(null);
      this.#adjustValue(this.opts.allowHalf.current ? 0.5 : 1);
    },
    [kbd_constants_exports.ARROW_RIGHT]: () => {
      this.setHoverValue(null);
      const increment = this.opts.allowHalf.current ? 0.5 : 1;
      this.#adjustValue(this.isRTL ? -increment : increment);
    },
    [kbd_constants_exports.ARROW_DOWN]: () => {
      this.setHoverValue(null);
      this.#adjustValue(this.opts.allowHalf.current ? -0.5 : -1);
    },
    [kbd_constants_exports.ARROW_LEFT]: () => {
      this.setHoverValue(null);
      const increment = this.opts.allowHalf.current ? 0.5 : 1;
      this.#adjustValue(this.isRTL ? increment : -increment);
    },
    [kbd_constants_exports.HOME]: () => {
      this.setHoverValue(null);
      this.setValue(this.opts.min.current);
    },
    [kbd_constants_exports.END]: () => {
      this.setHoverValue(null);
      this.setValue(this.opts.max.current);
    },
    [kbd_constants_exports.PAGE_UP]: () => {
      this.setHoverValue(null);
      this.#adjustValue(1);
    },
    [kbd_constants_exports.PAGE_DOWN]: () => {
      this.setHoverValue(null);
      this.#adjustValue(-1);
    }
  };
  onkeydown(e) {
    if (this.opts.disabled.current || this.opts.readonly.current) return;
    if (this.handlers[e.key]) {
      e.preventDefault();
      this.#clearKeySequence();
      this.handlers[e.key]?.();
      return;
    }
    if (this.opts.allowHalf.current && this.#handleDecimalInput(e)) return;
    const num = parseInt(e.key || "");
    if (!isNaN(num) && e.key) {
      e.preventDefault();
      if (num >= this.opts.min.current && num <= this.opts.max.current) {
        this.setValue(num);
        if (this.opts.allowHalf.current) {
          this.#startDecimalListening(num);
        }
      }
      return;
    }
    this.#clearKeySequence();
  }
  #adjustValue(delta) {
    this.setValue(this.opts.value.current + delta);
  }
  #handleDecimalInput(e) {
    if (!e.key) return false;
    if (strict_equals(e.key, ".")) {
      e.preventDefault();
      set(this.#keySequence, get(this.#keySequence) + e.key);
      return true;
    }
    if (strict_equals(e.key, "5") && get(this.#keySequence).match(/^\d+\.$/)) {
      e.preventDefault();
      set(this.#keySequence, get(this.#keySequence) + e.key);
      const match = get(this.#keySequence).match(/^(\d+)\.5$/);
      if (match?.[1]) {
        const value = parseFloat(get(this.#keySequence));
        if (value >= this.opts.min.current && value <= this.opts.max.current) {
          this.setValue(value);
          this.#clearKeySequence();
        }
      }
      return true;
    }
    return false;
  }
  #startDecimalListening(baseValue) {
    set(this.#keySequence, baseValue.toString(), true);
    if (this.#keySequenceTimeout) {
      this.domContext.clearTimeout(this.#keySequenceTimeout);
    }
    this.#keySequenceTimeout = this.domContext.setTimeout(() => this.#clearKeySequence(), 1e3);
  }
  #clearKeySequence() {
    set(this.#keySequence, "");
    if (this.#keySequenceTimeout) {
      this.domContext.clearTimeout(this.#keySequenceTimeout);
      this.#keySequenceTimeout = null;
    }
  }
  #snippetProps = tag(
    user_derived(() => ({
      items: this.items,
      value: this.opts.value.current,
      max: this.opts.max.current
    })),
    "RatingGroupRootState.snippetProps"
  );
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
  #props = tag(
    user_derived(() => {
      return {
        id: this.opts.id.current,
        role: "slider",
        "aria-valuenow": this.opts.value.current,
        "aria-valuemin": this.opts.min.current,
        "aria-valuemax": this.opts.max.current,
        "aria-valuetext": this.ariaValuetext,
        "aria-orientation": this.opts.orientation.current,
        "aria-required": getAriaRequired(this.opts.required.current),
        "aria-disabled": this.opts.disabled.current ? "true" : void 0,
        "aria-label": "Rating",
        "data-disabled": getDataDisabled(this.opts.disabled.current),
        "data-readonly": this.opts.readonly.current ? "" : void 0,
        "data-orientation": this.opts.orientation.current,
        tabindex: this.opts.disabled.current ? -1 : 0,
        [ratingGroupAttrs.root]: "",
        onkeydown: this.onkeydown,
        onpointerleave: this.onpointerleave,
        ...this.attachment
      };
    }),
    "RatingGroupRootState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var RatingGroupItemState = class _RatingGroupItemState {
  static create(opts) {
    return new _RatingGroupItemState(opts, RatingGroupRootContext.get());
  }
  opts;
  root;
  attachment;
  #isDisabled = tag(user_derived(() => this.opts.disabled.current || this.root.opts.disabled.current), "RatingGroupItemState.#isDisabled");
  #isActive = tag(user_derived(() => this.root.isActive(this.opts.index.current)), "RatingGroupItemState.#isActive");
  #isPartial = tag(user_derived(() => this.root.isPartial(this.opts.index.current)), "RatingGroupItemState.#isPartial");
  #state = tag(
    user_derived(() => {
      if (get(this.#isActive)) return "active";
      if (get(this.#isPartial)) return "partial";
      return "inactive";
    }),
    "RatingGroupItemState.#state"
  );
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
    this.onclick = this.onclick.bind(this);
    this.onpointermove = this.onpointermove.bind(this);
  }
  onclick(e) {
    if (get(this.#isDisabled) || this.root.opts.readonly.current) return;
    if (strict_equals(this.opts.index.current, 0) && strict_equals(this.root.opts.min.current, 0) && this.root.opts.value.current > 0) {
      const newValue2 = this.root.calculateRatingFromPointer(this.opts.index.current, e);
      const currentValue = this.root.opts.value.current;
      if (strict_equals(newValue2, currentValue)) {
        this.root.setValue(0);
        if (this.root.opts.ref.current) {
          this.root.opts.ref.current.focus();
        }
        return;
      }
    }
    const newValue = this.root.calculateRatingFromPointer(this.opts.index.current, e);
    this.root.setValue(newValue);
    if (this.root.opts.ref.current) {
      this.root.opts.ref.current.focus();
    }
  }
  onpointermove(e) {
    if (get(this.#isDisabled) || this.root.opts.readonly.current || !this.root.opts.hoverPreview.current) return;
    if (strict_equals(e.pointerType, "touch")) return;
    const hoverValue = this.root.calculateRatingFromPointer(this.opts.index.current, e);
    this.root.setHoverValue(hoverValue);
  }
  #snippetProps = tag(
    user_derived(() => {
      return { state: get(this.#state) };
    }),
    "RatingGroupItemState.snippetProps"
  );
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "presentation",
      "data-value": this.opts.index.current + 1,
      "data-orientation": this.root.opts.orientation.current,
      "data-disabled": getDataDisabled(get(this.#isDisabled)),
      "data-readonly": this.root.opts.readonly.current ? "" : void 0,
      "data-state": get(this.#state),
      [ratingGroupAttrs.item]: "",
      onclick: this.onclick,
      onpointermove: this.onpointermove,
      ...this.attachment
    })),
    "RatingGroupItemState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var RatingGroupHiddenInputState = class _RatingGroupHiddenInputState {
  static create() {
    return new _RatingGroupHiddenInputState(RatingGroupRootContext.get());
  }
  root;
  #shouldRender = tag(user_derived(() => strict_equals(this.root.opts.name.current, void 0, false)), "RatingGroupHiddenInputState.shouldRender");
  get shouldRender() {
    return get(this.#shouldRender);
  }
  set shouldRender(value) {
    set(this.#shouldRender, value);
  }
  #props = tag(
    user_derived(() => ({
      name: this.root.opts.name.current,
      value: this.root.opts.value.current,
      required: this.root.opts.required.current,
      disabled: this.root.opts.disabled.current
    })),
    "RatingGroupHiddenInputState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
  constructor(root18) {
    this.root = root18;
  }
};

// node_modules/bits-ui/dist/bits/rating-group/components/rating-group-input.svelte
Rating_group_input[FILENAME] = "node_modules/bits-ui/dist/bits/rating-group/components/rating-group-input.svelte";
function Rating_group_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Rating_group_input);
  const inputState = RatingGroupHiddenInputState.create();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => hidden_input_default(node_1, spread_props(() => inputState.props)), "component", Rating_group_input, 9, 1, { componentTag: "HiddenInput" });
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (inputState.shouldRender) $$render(consequent);
      }),
      "if",
      Rating_group_input,
      8,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Rating_group_input = hmr(Rating_group_input, () => Rating_group_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Rating_group_input[HMR].source;
    set(Rating_group_input[HMR].source, module.default[HMR].original);
  });
}
var rating_group_input_default = Rating_group_input;

// node_modules/bits-ui/dist/bits/rating-group/components/rating-group.svelte
Rating_group[FILENAME] = "node_modules/bits-ui/dist/bits/rating-group/components/rating-group.svelte";
var root_288 = add_locations(from_html(`<div><!></div>`), Rating_group[FILENAME], [[75, 1]]);
var root12 = add_locations(from_html(`<!> <!>`, 1), Rating_group[FILENAME], []);
function Rating_group($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Rating_group);
  let disabled = prop($$props, "disabled", 3, false), value = prop($$props, "value", 15, 0), ref = prop($$props, "ref", 15, null), orientation = prop($$props, "orientation", 3, "horizontal"), name = prop($$props, "name", 3, void 0), required = prop($$props, "required", 3, false), min = prop($$props, "min", 3, 0), max = prop($$props, "max", 3, 5), allowHalf = prop($$props, "allowHalf", 3, false), readonly = prop($$props, "readonly", 3, false), id = prop($$props, "id", 19, () => createId(uid)), onValueChange = prop($$props, "onValueChange", 3, noop3), hoverPreview = prop($$props, "hoverPreview", 3, true), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "disabled",
      "children",
      "child",
      "value",
      "ref",
      "orientation",
      "name",
      "required",
      "min",
      "max",
      "allowHalf",
      "readonly",
      "id",
      "onValueChange",
      "aria-label",
      "aria-valuetext",
      "hoverPreview"
    ],
    "restProps"
  );
  if (value() < min() || value() > max()) {
    value(Math.max(min(), Math.min(max(), value())));
  }
  const ariaValuetext = tag(
    user_derived(() => {
      if ($$props["aria-valuetext"]) return $$props["aria-valuetext"];
      return (value2, max2) => `${value2} out of ${max2}`;
    }),
    "ariaValuetext"
  );
  const rootState = RatingGroupRootState.create({
    orientation: box.with(() => orientation()),
    disabled: box.with(() => disabled()),
    name: box.with(() => name()),
    required: box.with(() => required()),
    min: box.with(() => min()),
    max: box.with(() => max()),
    allowHalf: box.with(() => allowHalf()),
    readonly: box.with(() => readonly()),
    id: box.with(() => id()),
    value: box.with(() => value(), (v) => {
      if (strict_equals(v, value())) return;
      value(v);
      onValueChange()?.(v);
    }),
    ref: box.with(() => ref(), (v) => ref(v)),
    ariaValuetext: box.with(() => get(ariaValuetext)),
    hoverPreview: box.with(() => hoverPreview())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props, { "aria-label": $$props["aria-label"] })), "mergedProps");
  var fragment = root12();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => ({ props: get(mergedProps), ...rootState.snippetProps }));
        add_svelte_meta(() => snippet(node_1, () => $$props.child, () => get($0)), "render", Rating_group, 73, 1);
      }
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_288();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => rootState.snippetProps), "render", Rating_group, 76, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Rating_group,
      72,
      0
    );
  }
  var node_3 = sibling(node, 2);
  add_svelte_meta(() => rating_group_input_default(node_3, {}), "component", Rating_group, 80, 0, { componentTag: "RatingGroupInput" });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Rating_group = hmr(Rating_group, () => Rating_group[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Rating_group[HMR].source;
    set(Rating_group[HMR].source, module.default[HMR].original);
  });
}
var rating_group_default = Rating_group;

// node_modules/bits-ui/dist/bits/rating-group/components/rating-group-item.svelte
Rating_group_item[FILENAME] = "node_modules/bits-ui/dist/bits/rating-group/components/rating-group-item.svelte";
var root_289 = add_locations(from_html(`<div><!></div>`), Rating_group_item[FILENAME], [[35, 1]]);
function Rating_group_item($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Rating_group_item);
  let disabled = prop($$props, "disabled", 3, false), ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "disabled",
      "index",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const itemState = RatingGroupItemState.create({
    disabled: box.with(() => Boolean(disabled())),
    index: box.with(() => $$props.index),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, itemState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => ({ props: get(mergedProps), ...itemState.snippetProps }));
        add_svelte_meta(() => snippet(node_1, () => $$props.child, () => get($0)), "render", Rating_group_item, 33, 1);
      }
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_289();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => itemState.snippetProps), "render", Rating_group_item, 36, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Rating_group_item,
      32,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Rating_group_item = hmr(Rating_group_item, () => Rating_group_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Rating_group_item[HMR].source;
    set(Rating_group_item[HMR].source, module.default[HMR].original);
  });
}
var rating_group_item_default = Rating_group_item;

// node_modules/bits-ui/dist/bits/scroll-area/exports.js
var exports_exports30 = {};
__export(exports_exports30, {
  Corner: () => scroll_area_corner_default,
  Root: () => scroll_area_default,
  Scrollbar: () => scroll_area_scrollbar_default,
  Thumb: () => scroll_area_thumb_default,
  Viewport: () => scroll_area_viewport_default
});

// node_modules/bits-ui/dist/internal/clamp.js
function clamp(n2, min, max) {
  return Math.min(max, Math.max(min, n2));
}

// node_modules/bits-ui/dist/bits/scroll-area/scroll-area.svelte.js
var scrollAreaAttrs = createBitsAttrs({
  component: "scroll-area",
  parts: ["root", "viewport", "corner", "thumb", "scrollbar"]
});
var ScrollAreaRootContext = new Context("ScrollArea.Root");
var ScrollAreaScrollbarContext = new Context("ScrollArea.Scrollbar");
var ScrollAreaScrollbarVisibleContext = new Context("ScrollArea.ScrollbarVisible");
var ScrollAreaScrollbarAxisContext = new Context("ScrollArea.ScrollbarAxis");
var ScrollAreaScrollbarSharedContext = new Context("ScrollArea.ScrollbarShared");
var ScrollAreaRootState = class _ScrollAreaRootState {
  static create(opts) {
    return ScrollAreaRootContext.set(new _ScrollAreaRootState(opts));
  }
  opts;
  attachment;
  #scrollAreaNode = tag(state(null), "ScrollAreaRootState.scrollAreaNode");
  get scrollAreaNode() {
    return get(this.#scrollAreaNode);
  }
  set scrollAreaNode(value) {
    set(this.#scrollAreaNode, value, true);
  }
  #viewportNode = tag(state(null), "ScrollAreaRootState.viewportNode");
  get viewportNode() {
    return get(this.#viewportNode);
  }
  set viewportNode(value) {
    set(this.#viewportNode, value, true);
  }
  #contentNode = tag(state(null), "ScrollAreaRootState.contentNode");
  get contentNode() {
    return get(this.#contentNode);
  }
  set contentNode(value) {
    set(this.#contentNode, value, true);
  }
  #scrollbarXNode = tag(state(null), "ScrollAreaRootState.scrollbarXNode");
  get scrollbarXNode() {
    return get(this.#scrollbarXNode);
  }
  set scrollbarXNode(value) {
    set(this.#scrollbarXNode, value, true);
  }
  #scrollbarYNode = tag(state(null), "ScrollAreaRootState.scrollbarYNode");
  get scrollbarYNode() {
    return get(this.#scrollbarYNode);
  }
  set scrollbarYNode(value) {
    set(this.#scrollbarYNode, value, true);
  }
  #cornerWidth = tag(state(0), "ScrollAreaRootState.cornerWidth");
  get cornerWidth() {
    return get(this.#cornerWidth);
  }
  set cornerWidth(value) {
    set(this.#cornerWidth, value, true);
  }
  #cornerHeight = tag(state(0), "ScrollAreaRootState.cornerHeight");
  get cornerHeight() {
    return get(this.#cornerHeight);
  }
  set cornerHeight(value) {
    set(this.#cornerHeight, value, true);
  }
  #scrollbarXEnabled = tag(state(false), "ScrollAreaRootState.scrollbarXEnabled");
  get scrollbarXEnabled() {
    return get(this.#scrollbarXEnabled);
  }
  set scrollbarXEnabled(value) {
    set(this.#scrollbarXEnabled, value, true);
  }
  #scrollbarYEnabled = tag(state(false), "ScrollAreaRootState.scrollbarYEnabled");
  get scrollbarYEnabled() {
    return get(this.#scrollbarYEnabled);
  }
  set scrollbarYEnabled(value) {
    set(this.#scrollbarYEnabled, value, true);
  }
  domContext;
  constructor(opts) {
    this.opts = opts;
    this.attachment = attachRef(opts.ref, (v) => this.scrollAreaNode = v);
    this.domContext = new DOMContext(opts.ref);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      dir: this.opts.dir.current,
      style: {
        position: "relative",
        "--bits-scroll-area-corner-height": `${this.cornerHeight}px`,
        "--bits-scroll-area-corner-width": `${this.cornerWidth}px`
      },
      [scrollAreaAttrs.root]: "",
      ...this.attachment
    })),
    "ScrollAreaRootState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var ScrollAreaViewportState = class _ScrollAreaViewportState {
  static create(opts) {
    return new _ScrollAreaViewportState(opts, ScrollAreaRootContext.get());
  }
  opts;
  root;
  attachment;
  #contentId = box(useId());
  #contentRef = box(null);
  contentAttachment = attachRef(this.#contentRef, (v) => this.root.contentNode = v);
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref, (v) => this.root.viewportNode = v);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      style: {
        overflowX: this.root.scrollbarXEnabled ? "scroll" : "hidden",
        overflowY: this.root.scrollbarYEnabled ? "scroll" : "hidden"
      },
      [scrollAreaAttrs.viewport]: "",
      ...this.attachment
    })),
    "ScrollAreaViewportState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
  #contentProps = tag(
    user_derived(() => ({
      id: this.#contentId.current,
      "data-scroll-area-content": "",
      style: {
        minWidth: this.root.scrollbarXEnabled ? "fit-content" : void 0
      },
      ...this.contentAttachment
    })),
    "ScrollAreaViewportState.contentProps"
  );
  get contentProps() {
    return get(this.#contentProps);
  }
  set contentProps(value) {
    set(this.#contentProps, value);
  }
};
var ScrollAreaScrollbarState = class _ScrollAreaScrollbarState {
  static create(opts) {
    return ScrollAreaScrollbarContext.set(new _ScrollAreaScrollbarState(opts, ScrollAreaRootContext.get()));
  }
  opts;
  root;
  #isHorizontal = tag(user_derived(() => strict_equals(this.opts.orientation.current, "horizontal")), "ScrollAreaScrollbarState.isHorizontal");
  get isHorizontal() {
    return get(this.#isHorizontal);
  }
  set isHorizontal(value) {
    set(this.#isHorizontal, value);
  }
  #hasThumb = tag(state(false), "ScrollAreaScrollbarState.hasThumb");
  get hasThumb() {
    return get(this.#hasThumb);
  }
  set hasThumb(value) {
    set(this.#hasThumb, value, true);
  }
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    watch(() => this.isHorizontal, (isHorizontal) => {
      if (isHorizontal) {
        this.root.scrollbarXEnabled = true;
        return () => {
          this.root.scrollbarXEnabled = false;
        };
      } else {
        this.root.scrollbarYEnabled = true;
        return () => {
          this.root.scrollbarYEnabled = false;
        };
      }
    });
  }
};
var ScrollAreaScrollbarHoverState = class _ScrollAreaScrollbarHoverState {
  static create() {
    return new _ScrollAreaScrollbarHoverState(ScrollAreaScrollbarContext.get());
  }
  scrollbar;
  root;
  #isVisible = tag(state(false), "ScrollAreaScrollbarHoverState.isVisible");
  get isVisible() {
    return get(this.#isVisible);
  }
  set isVisible(value) {
    set(this.#isVisible, value, true);
  }
  constructor(scrollbar) {
    this.scrollbar = scrollbar;
    this.root = scrollbar.root;
    user_effect(() => {
      const scrollAreaNode = this.root.scrollAreaNode;
      const hideDelay = this.root.opts.scrollHideDelay.current;
      let hideTimer = 0;
      if (!scrollAreaNode) return;
      const handlePointerEnter = () => {
        this.root.domContext.clearTimeout(hideTimer);
        untrack(() => this.isVisible = true);
      };
      const handlePointerLeave = () => {
        if (hideTimer) this.root.domContext.clearTimeout(hideTimer);
        hideTimer = this.root.domContext.setTimeout(
          () => {
            untrack(() => {
              this.scrollbar.hasThumb = false;
              this.isVisible = false;
            });
          },
          hideDelay
        );
      };
      const unsubListeners = executeCallbacks(on(scrollAreaNode, "pointerenter", handlePointerEnter), on(scrollAreaNode, "pointerleave", handlePointerLeave));
      return () => {
        this.root.domContext.getWindow().clearTimeout(hideTimer);
        unsubListeners();
      };
    });
  }
  #props = tag(user_derived(() => ({ "data-state": this.isVisible ? "visible" : "hidden" })), "ScrollAreaScrollbarHoverState.props");
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var ScrollAreaScrollbarScrollState = class _ScrollAreaScrollbarScrollState {
  static create() {
    return new _ScrollAreaScrollbarScrollState(ScrollAreaScrollbarContext.get());
  }
  scrollbar;
  root;
  machine = new StateMachine("hidden", {
    hidden: { SCROLL: "scrolling" },
    scrolling: { SCROLL_END: "idle", POINTER_ENTER: "interacting" },
    interacting: { SCROLL: "interacting", POINTER_LEAVE: "idle" },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  #isHidden = tag(user_derived(() => strict_equals(this.machine.state.current, "hidden")), "ScrollAreaScrollbarScrollState.isHidden");
  get isHidden() {
    return get(this.#isHidden);
  }
  set isHidden(value) {
    set(this.#isHidden, value);
  }
  constructor(scrollbar) {
    this.scrollbar = scrollbar;
    this.root = scrollbar.root;
    const debounceScrollend = useDebounce(() => this.machine.dispatch("SCROLL_END"), 100);
    user_effect(() => {
      const _state = this.machine.state.current;
      const scrollHideDelay = this.root.opts.scrollHideDelay.current;
      if (strict_equals(_state, "idle")) {
        const hideTimer = this.root.domContext.setTimeout(() => this.machine.dispatch("HIDE"), scrollHideDelay);
        return () => this.root.domContext.clearTimeout(hideTimer);
      }
    });
    user_effect(() => {
      const viewportNode = this.root.viewportNode;
      if (!viewportNode) return;
      const scrollDirection = this.scrollbar.isHorizontal ? "scrollLeft" : "scrollTop";
      let prevScrollPos = viewportNode[scrollDirection];
      const handleScroll = () => {
        const scrollPos = viewportNode[scrollDirection];
        const hasScrollInDirectionChanged = strict_equals(prevScrollPos, scrollPos, false);
        if (hasScrollInDirectionChanged) {
          this.machine.dispatch("SCROLL");
          debounceScrollend();
        }
        prevScrollPos = scrollPos;
      };
      const unsubListener = addEventListener(viewportNode, "scroll", handleScroll);
      return unsubListener;
    });
    this.onpointerenter = this.onpointerenter.bind(this);
    this.onpointerleave = this.onpointerleave.bind(this);
  }
  onpointerenter(_) {
    this.machine.dispatch("POINTER_ENTER");
  }
  onpointerleave(_) {
    this.machine.dispatch("POINTER_LEAVE");
  }
  #props = tag(
    user_derived(() => ({
      "data-state": strict_equals(this.machine.state.current, "hidden") ? "hidden" : "visible",
      onpointerenter: this.onpointerenter,
      onpointerleave: this.onpointerleave
    })),
    "ScrollAreaScrollbarScrollState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var ScrollAreaScrollbarAutoState = class _ScrollAreaScrollbarAutoState {
  static create() {
    return new _ScrollAreaScrollbarAutoState(ScrollAreaScrollbarContext.get());
  }
  scrollbar;
  root;
  #isVisible = tag(state(false), "ScrollAreaScrollbarAutoState.isVisible");
  get isVisible() {
    return get(this.#isVisible);
  }
  set isVisible(value) {
    set(this.#isVisible, value, true);
  }
  constructor(scrollbar) {
    this.scrollbar = scrollbar;
    this.root = scrollbar.root;
    const handleResize = useDebounce(
      () => {
        const viewportNode = this.root.viewportNode;
        if (!viewportNode) return;
        const isOverflowX = viewportNode.offsetWidth < viewportNode.scrollWidth;
        const isOverflowY = viewportNode.offsetHeight < viewportNode.scrollHeight;
        this.isVisible = this.scrollbar.isHorizontal ? isOverflowX : isOverflowY;
      },
      10
    );
    new SvelteResizeObserver(() => this.root.viewportNode, handleResize);
    new SvelteResizeObserver(() => this.root.contentNode, handleResize);
  }
  #props = tag(user_derived(() => ({ "data-state": this.isVisible ? "visible" : "hidden" })), "ScrollAreaScrollbarAutoState.props");
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var ScrollAreaScrollbarVisibleState = class _ScrollAreaScrollbarVisibleState {
  static create() {
    return ScrollAreaScrollbarVisibleContext.set(new _ScrollAreaScrollbarVisibleState(ScrollAreaScrollbarContext.get()));
  }
  scrollbar;
  root;
  #thumbNode = tag(state(null), "ScrollAreaScrollbarVisibleState.thumbNode");
  get thumbNode() {
    return get(this.#thumbNode);
  }
  set thumbNode(value) {
    set(this.#thumbNode, value, true);
  }
  #pointerOffset = tag(state(0), "ScrollAreaScrollbarVisibleState.pointerOffset");
  get pointerOffset() {
    return get(this.#pointerOffset);
  }
  set pointerOffset(value) {
    set(this.#pointerOffset, value, true);
  }
  #sizes = tag(
    state({
      content: 0,
      viewport: 0,
      scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
    }),
    "ScrollAreaScrollbarVisibleState.sizes"
  );
  get sizes() {
    return get(this.#sizes);
  }
  set sizes(value) {
    set(this.#sizes, value);
  }
  #thumbRatio = tag(user_derived(() => getThumbRatio(this.sizes.viewport, this.sizes.content)), "ScrollAreaScrollbarVisibleState.thumbRatio");
  get thumbRatio() {
    return get(this.#thumbRatio);
  }
  set thumbRatio(value) {
    set(this.#thumbRatio, value);
  }
  #hasThumb = tag(user_derived(() => Boolean(this.thumbRatio > 0 && this.thumbRatio < 1)), "ScrollAreaScrollbarVisibleState.hasThumb");
  get hasThumb() {
    return get(this.#hasThumb);
  }
  set hasThumb(value) {
    set(this.#hasThumb, value);
  }
  #prevTransformStyle = tag(state(""), "ScrollAreaScrollbarVisibleState.prevTransformStyle");
  get prevTransformStyle() {
    return get(this.#prevTransformStyle);
  }
  set prevTransformStyle(value) {
    set(this.#prevTransformStyle, value, true);
  }
  constructor(scrollbar) {
    this.scrollbar = scrollbar;
    this.root = scrollbar.root;
    user_effect(() => {
      this.scrollbar.hasThumb = this.hasThumb;
    });
    user_effect(() => {
      if (!this.scrollbar.hasThumb && this.thumbNode) {
        this.prevTransformStyle = this.thumbNode.style.transform;
      }
    });
  }
  setSizes(sizes) {
    this.sizes = sizes;
  }
  getScrollPosition(pointerPos, dir) {
    return getScrollPositionFromPointer({
      pointerPos,
      pointerOffset: this.pointerOffset,
      sizes: this.sizes,
      dir
    });
  }
  onThumbPointerUp() {
    this.pointerOffset = 0;
  }
  onThumbPointerDown(pointerPos) {
    this.pointerOffset = pointerPos;
  }
  xOnThumbPositionChange() {
    if (!(this.root.viewportNode && this.thumbNode)) return;
    const scrollPos = this.root.viewportNode.scrollLeft;
    const offset2 = getThumbOffsetFromScroll({
      scrollPos,
      sizes: this.sizes,
      dir: this.root.opts.dir.current
    });
    const transformStyle = `translate3d(${offset2}px, 0, 0)`;
    this.thumbNode.style.transform = transformStyle;
    this.prevTransformStyle = transformStyle;
  }
  xOnWheelScroll(scrollPos) {
    if (!this.root.viewportNode) return;
    this.root.viewportNode.scrollLeft = scrollPos;
  }
  xOnDragScroll(pointerPos) {
    if (!this.root.viewportNode) return;
    this.root.viewportNode.scrollLeft = this.getScrollPosition(pointerPos, this.root.opts.dir.current);
  }
  yOnThumbPositionChange() {
    if (!(this.root.viewportNode && this.thumbNode)) return;
    const scrollPos = this.root.viewportNode.scrollTop;
    const offset2 = getThumbOffsetFromScroll({ scrollPos, sizes: this.sizes });
    const transformStyle = `translate3d(0, ${offset2}px, 0)`;
    this.thumbNode.style.transform = transformStyle;
    this.prevTransformStyle = transformStyle;
  }
  yOnWheelScroll(scrollPos) {
    if (!this.root.viewportNode) return;
    this.root.viewportNode.scrollTop = scrollPos;
  }
  yOnDragScroll(pointerPos) {
    if (!this.root.viewportNode) return;
    this.root.viewportNode.scrollTop = this.getScrollPosition(pointerPos, this.root.opts.dir.current);
  }
};
var ScrollAreaScrollbarXState = class _ScrollAreaScrollbarXState {
  static create(opts) {
    return ScrollAreaScrollbarAxisContext.set(new _ScrollAreaScrollbarXState(opts, ScrollAreaScrollbarVisibleContext.get()));
  }
  opts;
  scrollbarVis;
  root;
  scrollbar;
  attachment;
  #computedStyle = tag(state(), "ScrollAreaScrollbarXState.computedStyle");
  get computedStyle() {
    return get(this.#computedStyle);
  }
  set computedStyle(value) {
    set(this.#computedStyle, value, true);
  }
  constructor(opts, scrollbarVis) {
    this.opts = opts;
    this.scrollbarVis = scrollbarVis;
    this.root = scrollbarVis.root;
    this.scrollbar = scrollbarVis.scrollbar;
    this.attachment = attachRef(this.scrollbar.opts.ref, (v) => this.root.scrollbarXNode = v);
    user_effect(() => {
      if (!this.scrollbar.opts.ref.current) return;
      if (this.opts.mounted.current) {
        this.computedStyle = getComputedStyle(this.scrollbar.opts.ref.current);
      }
    });
    user_effect(() => {
      this.onResize();
    });
  }
  onThumbPointerDown = (pointerPos) => {
    this.scrollbarVis.onThumbPointerDown(pointerPos.x);
  };
  onDragScroll = (pointerPos) => {
    this.scrollbarVis.xOnDragScroll(pointerPos.x);
  };
  onThumbPointerUp = () => {
    this.scrollbarVis.onThumbPointerUp();
  };
  onThumbPositionChange = () => {
    this.scrollbarVis.xOnThumbPositionChange();
  };
  onWheelScroll = (e, maxScrollPos) => {
    if (!this.root.viewportNode) return;
    const scrollPos = this.root.viewportNode.scrollLeft + e.deltaX;
    this.scrollbarVis.xOnWheelScroll(scrollPos);
    if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
      e.preventDefault();
    }
  };
  onResize = () => {
    if (!(this.scrollbar.opts.ref.current && this.root.viewportNode && this.computedStyle)) return;
    this.scrollbarVis.setSizes({
      content: this.root.viewportNode.scrollWidth,
      viewport: this.root.viewportNode.offsetWidth,
      scrollbar: {
        size: this.scrollbar.opts.ref.current.clientWidth,
        paddingStart: toInt(this.computedStyle.paddingLeft),
        paddingEnd: toInt(this.computedStyle.paddingRight)
      }
    });
  };
  #thumbSize = tag(
    user_derived(() => {
      return getThumbSize(this.scrollbarVis.sizes);
    }),
    "ScrollAreaScrollbarXState.thumbSize"
  );
  get thumbSize() {
    return get(this.#thumbSize);
  }
  set thumbSize(value) {
    set(this.#thumbSize, value);
  }
  #props = tag(
    user_derived(() => ({
      id: this.scrollbar.opts.id.current,
      "data-orientation": "horizontal",
      style: {
        bottom: 0,
        left: strict_equals(this.root.opts.dir.current, "rtl") ? "var(--bits-scroll-area-corner-width)" : 0,
        right: strict_equals(this.root.opts.dir.current, "ltr") ? "var(--bits-scroll-area-corner-width)" : 0,
        "--bits-scroll-area-thumb-width": `${this.thumbSize}px`
      },
      ...this.attachment
    })),
    "ScrollAreaScrollbarXState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var ScrollAreaScrollbarYState = class _ScrollAreaScrollbarYState {
  static create(opts) {
    return ScrollAreaScrollbarAxisContext.set(new _ScrollAreaScrollbarYState(opts, ScrollAreaScrollbarVisibleContext.get()));
  }
  opts;
  scrollbarVis;
  root;
  scrollbar;
  attachment;
  #computedStyle = tag(state(), "ScrollAreaScrollbarYState.computedStyle");
  get computedStyle() {
    return get(this.#computedStyle);
  }
  set computedStyle(value) {
    set(this.#computedStyle, value, true);
  }
  constructor(opts, scrollbarVis) {
    this.opts = opts;
    this.scrollbarVis = scrollbarVis;
    this.root = scrollbarVis.root;
    this.scrollbar = scrollbarVis.scrollbar;
    this.attachment = attachRef(this.scrollbar.opts.ref, (v) => this.root.scrollbarYNode = v);
    user_effect(() => {
      if (!this.scrollbar.opts.ref.current) return;
      if (this.opts.mounted.current) {
        this.computedStyle = getComputedStyle(this.scrollbar.opts.ref.current);
      }
    });
    user_effect(() => {
      this.onResize();
    });
    this.onThumbPointerDown = this.onThumbPointerDown.bind(this);
    this.onDragScroll = this.onDragScroll.bind(this);
    this.onThumbPointerUp = this.onThumbPointerUp.bind(this);
    this.onThumbPositionChange = this.onThumbPositionChange.bind(this);
    this.onWheelScroll = this.onWheelScroll.bind(this);
    this.onResize = this.onResize.bind(this);
  }
  onThumbPointerDown(pointerPos) {
    this.scrollbarVis.onThumbPointerDown(pointerPos.y);
  }
  onDragScroll(pointerPos) {
    this.scrollbarVis.yOnDragScroll(pointerPos.y);
  }
  onThumbPointerUp() {
    this.scrollbarVis.onThumbPointerUp();
  }
  onThumbPositionChange() {
    this.scrollbarVis.yOnThumbPositionChange();
  }
  onWheelScroll(e, maxScrollPos) {
    if (!this.root.viewportNode) return;
    const scrollPos = this.root.viewportNode.scrollTop + e.deltaY;
    this.scrollbarVis.yOnWheelScroll(scrollPos);
    if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
      e.preventDefault();
    }
  }
  onResize() {
    if (!(this.scrollbar.opts.ref.current && this.root.viewportNode && this.computedStyle)) return;
    this.scrollbarVis.setSizes({
      content: this.root.viewportNode.scrollHeight,
      viewport: this.root.viewportNode.offsetHeight,
      scrollbar: {
        size: this.scrollbar.opts.ref.current.clientHeight,
        paddingStart: toInt(this.computedStyle.paddingTop),
        paddingEnd: toInt(this.computedStyle.paddingBottom)
      }
    });
  }
  #thumbSize = tag(
    user_derived(() => {
      return getThumbSize(this.scrollbarVis.sizes);
    }),
    "ScrollAreaScrollbarYState.thumbSize"
  );
  get thumbSize() {
    return get(this.#thumbSize);
  }
  set thumbSize(value) {
    set(this.#thumbSize, value);
  }
  #props = tag(
    user_derived(() => ({
      id: this.scrollbar.opts.id.current,
      "data-orientation": "vertical",
      style: {
        top: 0,
        right: strict_equals(this.root.opts.dir.current, "ltr") ? 0 : void 0,
        left: strict_equals(this.root.opts.dir.current, "rtl") ? 0 : void 0,
        bottom: "var(--bits-scroll-area-corner-height)",
        "--bits-scroll-area-thumb-height": `${this.thumbSize}px`
      },
      ...this.attachment
    })),
    "ScrollAreaScrollbarYState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var ScrollAreaScrollbarSharedState = class _ScrollAreaScrollbarSharedState {
  static create() {
    return ScrollAreaScrollbarSharedContext.set(new _ScrollAreaScrollbarSharedState(ScrollAreaScrollbarAxisContext.get()));
  }
  scrollbarState;
  root;
  scrollbarVis;
  scrollbar;
  #rect = tag(state(null), "ScrollAreaScrollbarSharedState.rect");
  get rect() {
    return get(this.#rect);
  }
  set rect(value) {
    set(this.#rect, value);
  }
  #prevWebkitUserSelect = tag(state(""), "ScrollAreaScrollbarSharedState.prevWebkitUserSelect");
  get prevWebkitUserSelect() {
    return get(this.#prevWebkitUserSelect);
  }
  set prevWebkitUserSelect(value) {
    set(this.#prevWebkitUserSelect, value, true);
  }
  handleResize;
  handleThumbPositionChange;
  handleWheelScroll;
  handleThumbPointerDown;
  handleThumbPointerUp;
  #maxScrollPos = tag(user_derived(() => this.scrollbarVis.sizes.content - this.scrollbarVis.sizes.viewport), "ScrollAreaScrollbarSharedState.maxScrollPos");
  get maxScrollPos() {
    return get(this.#maxScrollPos);
  }
  set maxScrollPos(value) {
    set(this.#maxScrollPos, value);
  }
  constructor(scrollbarState) {
    this.scrollbarState = scrollbarState;
    this.root = scrollbarState.root;
    this.scrollbarVis = scrollbarState.scrollbarVis;
    this.scrollbar = scrollbarState.scrollbarVis.scrollbar;
    this.handleResize = useDebounce(() => this.scrollbarState.onResize(), 10);
    this.handleThumbPositionChange = this.scrollbarState.onThumbPositionChange;
    this.handleWheelScroll = this.scrollbarState.onWheelScroll;
    this.handleThumbPointerDown = this.scrollbarState.onThumbPointerDown;
    this.handleThumbPointerUp = this.scrollbarState.onThumbPointerUp;
    user_effect(() => {
      const maxScrollPos = this.maxScrollPos;
      const scrollbarNode = this.scrollbar.opts.ref.current;
      this.root.viewportNode;
      const handleWheel = (e) => {
        const node = e.target;
        const isScrollbarWheel = scrollbarNode?.contains(node);
        if (isScrollbarWheel) this.handleWheelScroll(e, maxScrollPos);
      };
      const unsubListener = addEventListener(this.root.domContext.getDocument(), "wheel", handleWheel, { passive: false });
      return unsubListener;
    });
    user_pre_effect(() => {
      this.scrollbarVis.sizes;
      untrack(() => this.handleThumbPositionChange());
    });
    new SvelteResizeObserver(() => this.scrollbar.opts.ref.current, this.handleResize);
    new SvelteResizeObserver(() => this.root.contentNode, this.handleResize);
    this.onpointerdown = this.onpointerdown.bind(this);
    this.onpointermove = this.onpointermove.bind(this);
    this.onpointerup = this.onpointerup.bind(this);
  }
  handleDragScroll(e) {
    if (!this.rect) return;
    const x = e.clientX - this.rect.left;
    const y = e.clientY - this.rect.top;
    this.scrollbarState.onDragScroll({ x, y });
  }
  onpointerdown(e) {
    if (strict_equals(e.button, 0, false)) return;
    const target = e.target;
    target.setPointerCapture(e.pointerId);
    this.rect = this.scrollbar.opts.ref.current?.getBoundingClientRect() ?? null;
    this.prevWebkitUserSelect = this.root.domContext.getDocument().body.style.webkitUserSelect;
    this.root.domContext.getDocument().body.style.webkitUserSelect = "none";
    if (this.root.viewportNode) this.root.viewportNode.style.scrollBehavior = "auto";
    this.handleDragScroll(e);
  }
  onpointermove(e) {
    this.handleDragScroll(e);
  }
  onpointerup(e) {
    const target = e.target;
    if (target.hasPointerCapture(e.pointerId)) {
      target.releasePointerCapture(e.pointerId);
    }
    this.root.domContext.getDocument().body.style.webkitUserSelect = this.prevWebkitUserSelect;
    if (this.root.viewportNode) this.root.viewportNode.style.scrollBehavior = "";
    this.rect = null;
  }
  #props = tag(
    user_derived(() => mergeProps({
      ...this.scrollbarState.props,
      style: { position: "absolute", ...this.scrollbarState.props.style },
      [scrollAreaAttrs.scrollbar]: "",
      onpointerdown: this.onpointerdown,
      onpointermove: this.onpointermove,
      onpointerup: this.onpointerup
    })),
    "ScrollAreaScrollbarSharedState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var ScrollAreaThumbImplState = class _ScrollAreaThumbImplState {
  static create(opts) {
    return new _ScrollAreaThumbImplState(opts, ScrollAreaScrollbarSharedContext.get());
  }
  opts;
  scrollbarState;
  attachment;
  #root;
  #removeUnlinkedScrollListener = tag(state(), "ScrollAreaThumbImplState.#removeUnlinkedScrollListener");
  #debounceScrollEnd = useDebounce(
    () => {
      if (get(this.#removeUnlinkedScrollListener)) {
        get(this.#removeUnlinkedScrollListener)();
        set(this.#removeUnlinkedScrollListener, void 0);
      }
    },
    100
  );
  constructor(opts, scrollbarState) {
    this.opts = opts;
    this.scrollbarState = scrollbarState;
    this.#root = scrollbarState.root;
    this.attachment = attachRef(this.opts.ref, (v) => this.scrollbarState.scrollbarVis.thumbNode = v);
    user_effect(() => {
      const viewportNode = this.#root.viewportNode;
      if (!viewportNode) return;
      const handleScroll = () => {
        this.#debounceScrollEnd();
        if (!get(this.#removeUnlinkedScrollListener)) {
          const listener = addUnlinkedScrollListener(viewportNode, this.scrollbarState.handleThumbPositionChange);
          set(this.#removeUnlinkedScrollListener, listener, true);
          this.scrollbarState.handleThumbPositionChange();
        }
      };
      untrack(() => this.scrollbarState.handleThumbPositionChange());
      const unsubListener = addEventListener(viewportNode, "scroll", handleScroll);
      return unsubListener;
    });
    this.onpointerdowncapture = this.onpointerdowncapture.bind(this);
    this.onpointerup = this.onpointerup.bind(this);
  }
  onpointerdowncapture(e) {
    const thumb = e.target;
    if (!thumb) return;
    const thumbRect = thumb.getBoundingClientRect();
    const x = e.clientX - thumbRect.left;
    const y = e.clientY - thumbRect.top;
    this.scrollbarState.handleThumbPointerDown({ x, y });
  }
  onpointerup(_) {
    this.scrollbarState.handleThumbPointerUp();
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "data-state": this.scrollbarState.scrollbarVis.hasThumb ? "visible" : "hidden",
      style: {
        width: "var(--bits-scroll-area-thumb-width)",
        height: "var(--bits-scroll-area-thumb-height)",
        transform: this.scrollbarState.scrollbarVis.prevTransformStyle
      },
      onpointerdowncapture: this.onpointerdowncapture,
      onpointerup: this.onpointerup,
      [scrollAreaAttrs.thumb]: "",
      ...this.attachment
    })),
    "ScrollAreaThumbImplState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var ScrollAreaCornerImplState = class _ScrollAreaCornerImplState {
  static create(opts) {
    return new _ScrollAreaCornerImplState(opts, ScrollAreaRootContext.get());
  }
  opts;
  root;
  attachment;
  #width = tag(state(0), "ScrollAreaCornerImplState.#width");
  #height = tag(state(0), "ScrollAreaCornerImplState.#height");
  #hasSize = tag(user_derived(() => Boolean(get(this.#width) && get(this.#height))), "ScrollAreaCornerImplState.hasSize");
  get hasSize() {
    return get(this.#hasSize);
  }
  set hasSize(value) {
    set(this.#hasSize, value);
  }
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    new SvelteResizeObserver(() => this.root.scrollbarXNode, () => {
      const height = this.root.scrollbarXNode?.offsetHeight || 0;
      this.root.cornerHeight = height;
      set(this.#height, height, true);
    });
    new SvelteResizeObserver(() => this.root.scrollbarYNode, () => {
      const width = this.root.scrollbarYNode?.offsetWidth || 0;
      this.root.cornerWidth = width;
      set(this.#width, width, true);
    });
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      style: {
        width: get(this.#width),
        height: get(this.#height),
        position: "absolute",
        right: strict_equals(this.root.opts.dir.current, "ltr") ? 0 : void 0,
        left: strict_equals(this.root.opts.dir.current, "rtl") ? 0 : void 0,
        bottom: 0
      },
      [scrollAreaAttrs.corner]: "",
      ...this.attachment
    })),
    "ScrollAreaCornerImplState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
function toInt(value) {
  return value ? Number.parseInt(value, 10) : 0;
}
function getThumbRatio(viewportSize, contentSize) {
  const ratio = viewportSize / contentSize;
  return Number.isNaN(ratio) ? 0 : ratio;
}
function getThumbSize(sizes) {
  const ratio = getThumbRatio(sizes.viewport, sizes.content);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio;
  return Math.max(thumbSize, 18);
}
function getScrollPositionFromPointer({ pointerPos, pointerOffset, sizes, dir = "ltr" }) {
  const thumbSizePx = getThumbSize(sizes);
  const thumbCenter = thumbSizePx / 2;
  const offset2 = pointerOffset || thumbCenter;
  const thumbOffsetFromEnd = thumbSizePx - offset2;
  const minPointerPos = sizes.scrollbar.paddingStart + offset2;
  const maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd;
  const maxScrollPos = sizes.content - sizes.viewport;
  const scrollRange = strict_equals(dir, "ltr") ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const interpolate = linearScale([minPointerPos, maxPointerPos], scrollRange);
  return interpolate(pointerPos);
}
function getThumbOffsetFromScroll({ scrollPos, sizes, dir = "ltr" }) {
  const thumbSizePx = getThumbSize(sizes);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const scrollbar = sizes.scrollbar.size - scrollbarPadding;
  const maxScrollPos = sizes.content - sizes.viewport;
  const maxThumbPos = scrollbar - thumbSizePx;
  const scrollClampRange = strict_equals(dir, "ltr") ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const scrollWithoutMomentum = clamp(scrollPos, scrollClampRange[0], scrollClampRange[1]);
  const interpolate = linearScale([0, maxScrollPos], [0, maxThumbPos]);
  return interpolate(scrollWithoutMomentum);
}
function linearScale(input, output) {
  return (value) => {
    if (strict_equals(input[0], input[1]) || strict_equals(output[0], output[1])) return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {
  return scrollPos > 0 && scrollPos < maxScrollPos;
}
function addUnlinkedScrollListener(node, handler) {
  let prevPosition = { left: node.scrollLeft, top: node.scrollTop };
  let rAF = 0;
  const win = getWindow(node);
  (function loop() {
    const position = { left: node.scrollLeft, top: node.scrollTop };
    const isHorizontalScroll = strict_equals(prevPosition.left, position.left, false);
    const isVerticalScroll = strict_equals(prevPosition.top, position.top, false);
    if (isHorizontalScroll || isVerticalScroll) handler();
    prevPosition = position;
    rAF = win.requestAnimationFrame(loop);
  })();
  return () => win.cancelAnimationFrame(rAF);
}

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area.svelte
Scroll_area[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area.svelte";
var root_290 = add_locations(from_html(`<div><!></div>`), Scroll_area[FILENAME], [[37, 1]]);
function Scroll_area($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Scroll_area);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), type = prop($$props, "type", 3, "hover"), dir = prop($$props, "dir", 3, "ltr"), scrollHideDelay = prop($$props, "scrollHideDelay", 3, 600), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "type",
      "dir",
      "scrollHideDelay",
      "children",
      "child"
    ],
    "restProps"
  );
  const rootState = ScrollAreaRootState.create({
    type: box.with(() => type()),
    dir: box.with(() => dir()),
    scrollHideDelay: box.with(() => scrollHideDelay()),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Scroll_area, 35, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_290();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Scroll_area, 38, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Scroll_area,
      34,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area = hmr(Scroll_area, () => Scroll_area[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area[HMR].source;
    set(Scroll_area[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_default = Scroll_area;

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-viewport.svelte
Scroll_area_viewport[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-viewport.svelte";
var root13 = add_locations(from_html(`<div><div><!></div></div>`), Scroll_area_viewport[FILENAME], [[28, 0, [[29, 1]]]]);
var $$css2 = {
  hash: "s-fbvr5voIYKY7",
  code: "\n	/* Hide scrollbars cross browser and enable momentum scroll for touch devices */\n	[data-scroll-area-viewport] {\n		scrollbar-width: none !important;\n		-ms-overflow-style: none !important;\n		-webkit-overflow-scrolling: touch !important;\n	}\n	[data-scroll-area-viewport]::-webkit-scrollbar {\n		display: none !important;\n	}\n\n	:where([data-scroll-area-viewport]) {\n		display: flex;\n		flex-direction: column;\n		align-items: stretch;\n	}\n	:where([data-scroll-area-content]) {\n		flex-grow: 1;\n	}\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2Nyb2xsLWFyZWEtdmlld3BvcnQuc3ZlbHRlIiwic291cmNlcyI6WyJzY3JvbGwtYXJlYS12aWV3cG9ydC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IHsgYm94LCBtZXJnZVByb3BzIH0gZnJvbSBcInN2ZWx0ZS10b29sYmVsdFwiO1xuXHRpbXBvcnQgdHlwZSB7IFNjcm9sbEFyZWFWaWV3cG9ydFByb3BzIH0gZnJvbSBcIi4uL3R5cGVzLmpzXCI7XG5cdGltcG9ydCB7IFNjcm9sbEFyZWFWaWV3cG9ydFN0YXRlIH0gZnJvbSBcIi4uL3Njcm9sbC1hcmVhLnN2ZWx0ZS5qc1wiO1xuXHRpbXBvcnQgeyBjcmVhdGVJZCB9IGZyb20gXCIuLi8uLi8uLi9pbnRlcm5hbC9jcmVhdGUtaWQuanNcIjtcblxuXHRjb25zdCB1aWQgPSAkcHJvcHMuaWQoKTtcblxuXHRsZXQge1xuXHRcdHJlZiA9ICRiaW5kYWJsZShudWxsKSxcblx0XHRpZCA9IGNyZWF0ZUlkKHVpZCksXG5cdFx0Y2hpbGRyZW4sXG5cdFx0Li4ucmVzdFByb3BzXG5cdH06IFNjcm9sbEFyZWFWaWV3cG9ydFByb3BzID0gJHByb3BzKCk7XG5cblx0Y29uc3Qgdmlld3BvcnRTdGF0ZSA9IFNjcm9sbEFyZWFWaWV3cG9ydFN0YXRlLmNyZWF0ZSh7XG5cdFx0aWQ6IGJveC53aXRoKCgpID0+IGlkKSxcblx0XHRyZWY6IGJveC53aXRoKFxuXHRcdFx0KCkgPT4gcmVmLFxuXHRcdFx0KHYpID0+IChyZWYgPSB2KVxuXHRcdCksXG5cdH0pO1xuXG5cdGNvbnN0IG1lcmdlZFByb3BzID0gJGRlcml2ZWQobWVyZ2VQcm9wcyhyZXN0UHJvcHMsIHZpZXdwb3J0U3RhdGUucHJvcHMpKTtcblx0Y29uc3QgbWVyZ2VkQ29udGVudFByb3BzID0gJGRlcml2ZWQobWVyZ2VQcm9wcyh7fSwgdmlld3BvcnRTdGF0ZS5jb250ZW50UHJvcHMpKTtcbjwvc2NyaXB0PlxuXG48ZGl2IHsuLi5tZXJnZWRQcm9wc30+XG5cdDxkaXYgey4uLm1lcmdlZENvbnRlbnRQcm9wc30+XG5cdFx0e0ByZW5kZXIgY2hpbGRyZW4/LigpfVxuXHQ8L2Rpdj5cbjwvZGl2PlxuXG48c3R5bGU+XG5cdC8qIEhpZGUgc2Nyb2xsYmFycyBjcm9zcyBicm93c2VyIGFuZCBlbmFibGUgbW9tZW50dW0gc2Nyb2xsIGZvciB0b3VjaCBkZXZpY2VzICovXG5cdDpnbG9iYWwoW2RhdGEtc2Nyb2xsLWFyZWEtdmlld3BvcnRdKSB7XG5cdFx0c2Nyb2xsYmFyLXdpZHRoOiBub25lICFpbXBvcnRhbnQ7XG5cdFx0LW1zLW92ZXJmbG93LXN0eWxlOiBub25lICFpbXBvcnRhbnQ7XG5cdFx0LXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoICFpbXBvcnRhbnQ7XG5cdH1cblx0Omdsb2JhbChbZGF0YS1zY3JvbGwtYXJlYS12aWV3cG9ydF0pOjotd2Via2l0LXNjcm9sbGJhciB7XG5cdFx0ZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xuXHR9XG5cblx0Omdsb2JhbCg6d2hlcmUoW2RhdGEtc2Nyb2xsLWFyZWEtdmlld3BvcnRdKSkge1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblx0XHRhbGlnbi1pdGVtczogc3RyZXRjaDtcblx0fVxuXHQ6Z2xvYmFsKDp3aGVyZShbZGF0YS1zY3JvbGwtYXJlYS1jb250ZW50XSkpIHtcblx0XHRmbGV4LWdyb3c6IDE7XG5cdH1cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImlnbm9yZUxpc3QiOltdfQ== */"
};
function Scroll_area_viewport($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Scroll_area_viewport);
  append_styles($$anchor, $$css2);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "ref", "id", "children"], "restProps");
  const viewportState = ScrollAreaViewportState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, viewportState.props)), "mergedProps");
  const mergedContentProps = tag(user_derived(() => mergeProps({}, viewportState.contentProps)), "mergedContentProps");
  var div = root13();
  attribute_effect(div, () => ({ ...get(mergedProps) }));
  var div_1 = child(div);
  attribute_effect(div_1, () => ({ ...get(mergedContentProps) }));
  var node = child(div_1);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop), "render", Scroll_area_viewport, 30, 2);
  reset(div_1);
  reset(div);
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_viewport = hmr(Scroll_area_viewport, () => Scroll_area_viewport[HMR].source);
  import.meta.hot.accept((module) => {
    cleanup_styles("s-fbvr5voIYKY7");
    module.default[HMR].source = Scroll_area_viewport[HMR].source;
    set(Scroll_area_viewport[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_viewport_default = Scroll_area_viewport;

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-shared.svelte
Scroll_area_scrollbar_shared[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-shared.svelte";
var root_291 = add_locations(from_html(`<div><!></div>`), Scroll_area_scrollbar_shared[FILENAME], [[16, 1]]);
function Scroll_area_scrollbar_shared($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_scrollbar_shared);
  let restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "child", "children"], "restProps");
  const scrollbarSharedState = ScrollAreaScrollbarSharedState.create();
  const mergedProps = tag(user_derived(() => mergeProps(restProps, scrollbarSharedState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Scroll_area_scrollbar_shared, 14, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_291();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Scroll_area_scrollbar_shared, 17, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Scroll_area_scrollbar_shared,
      13,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_scrollbar_shared = hmr(Scroll_area_scrollbar_shared, () => Scroll_area_scrollbar_shared[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_scrollbar_shared[HMR].source;
    set(Scroll_area_scrollbar_shared[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_scrollbar_shared_default = Scroll_area_scrollbar_shared;

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-x.svelte
Scroll_area_scrollbar_x[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-x.svelte";
function Scroll_area_scrollbar_x($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_scrollbar_x);
  let restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "restProps");
  const isMounted = new IsMounted();
  const scrollbarXState = ScrollAreaScrollbarXState.create({ mounted: box.with(() => isMounted.current) });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, scrollbarXState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => scroll_area_scrollbar_shared_default(node, spread_props(() => get(mergedProps))), "component", Scroll_area_scrollbar_x, 19, 0, { componentTag: "ScrollAreaScrollbarShared" });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_scrollbar_x = hmr(Scroll_area_scrollbar_x, () => Scroll_area_scrollbar_x[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_scrollbar_x[HMR].source;
    set(Scroll_area_scrollbar_x[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_scrollbar_x_default = Scroll_area_scrollbar_x;

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-y.svelte
Scroll_area_scrollbar_y[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-y.svelte";
function Scroll_area_scrollbar_y($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_scrollbar_y);
  let restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "restProps");
  const isMounted = new IsMounted();
  const scrollbarYState = ScrollAreaScrollbarYState.create({ mounted: box.with(() => isMounted.current) });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, scrollbarYState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => scroll_area_scrollbar_shared_default(node, spread_props(() => get(mergedProps))), "component", Scroll_area_scrollbar_y, 20, 0, { componentTag: "ScrollAreaScrollbarShared" });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_scrollbar_y = hmr(Scroll_area_scrollbar_y, () => Scroll_area_scrollbar_y[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_scrollbar_y[HMR].source;
    set(Scroll_area_scrollbar_y[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_scrollbar_y_default = Scroll_area_scrollbar_y;

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-visible.svelte
Scroll_area_scrollbar_visible[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-visible.svelte";
function Scroll_area_scrollbar_visible($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_scrollbar_visible);
  let restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy"], "restProps");
  const scrollbarVisibleState = ScrollAreaScrollbarVisibleState.create();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => scroll_area_scrollbar_x_default(node_1, spread_props(() => restProps)), "component", Scroll_area_scrollbar_visible, 13, 1, { componentTag: "ScrollAreaScrollbarX" });
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      add_svelte_meta(() => scroll_area_scrollbar_y_default(node_2, spread_props(() => restProps)), "component", Scroll_area_scrollbar_visible, 15, 1, { componentTag: "ScrollAreaScrollbarY" });
      append($$anchor2, fragment_2);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (strict_equals(scrollbarVisibleState.scrollbar.opts.orientation.current, "horizontal")) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Scroll_area_scrollbar_visible,
      12,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_scrollbar_visible = hmr(Scroll_area_scrollbar_visible, () => Scroll_area_scrollbar_visible[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_scrollbar_visible[HMR].source;
    set(Scroll_area_scrollbar_visible[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_scrollbar_visible_default = Scroll_area_scrollbar_visible;

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-auto.svelte
Scroll_area_scrollbar_auto[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-auto.svelte";
function Scroll_area_scrollbar_auto($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_scrollbar_auto);
  let forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "forceMount"], "restProps");
  const scrollbarAutoState = ScrollAreaScrollbarAutoState.create();
  const mergedProps = tag(user_derived(() => mergeProps(restProps, scrollbarAutoState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    const presence = wrap_snippet(Scroll_area_scrollbar_auto, function($$anchor2) {
      validate_snippet_args(...arguments);
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => scroll_area_scrollbar_visible_default(node_1, spread_props(() => get(mergedProps))), "component", Scroll_area_scrollbar_auto, 19, 2, { componentTag: "ScrollAreaScrollbarVisible" });
      append($$anchor2, fragment_1);
    });
    let $0 = user_derived(() => forceMount() || scrollbarAutoState.isVisible);
    add_svelte_meta(
      () => presence_layer_default(node, {
        get open() {
          return get($0);
        },
        get ref() {
          return scrollbarAutoState.scrollbar.opts.ref;
        },
        presence,
        $$slots: { presence: true }
      }),
      "component",
      Scroll_area_scrollbar_auto,
      14,
      0,
      { componentTag: "PresenceLayer" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_scrollbar_auto = hmr(Scroll_area_scrollbar_auto, () => Scroll_area_scrollbar_auto[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_scrollbar_auto[HMR].source;
    set(Scroll_area_scrollbar_auto[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_scrollbar_auto_default = Scroll_area_scrollbar_auto;

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-scroll.svelte
Scroll_area_scrollbar_scroll[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-scroll.svelte";
function Scroll_area_scrollbar_scroll($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_scrollbar_scroll);
  let forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "forceMount"], "restProps");
  const scrollbarScrollState = ScrollAreaScrollbarScrollState.create();
  const mergedProps = tag(user_derived(() => mergeProps(restProps, scrollbarScrollState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    const presence = wrap_snippet(Scroll_area_scrollbar_scroll, function($$anchor2) {
      validate_snippet_args(...arguments);
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => scroll_area_scrollbar_visible_default(node_1, spread_props(() => get(mergedProps))), "component", Scroll_area_scrollbar_scroll, 21, 2, { componentTag: "ScrollAreaScrollbarVisible" });
      append($$anchor2, fragment_1);
    });
    let $0 = user_derived(() => forceMount() || !scrollbarScrollState.isHidden);
    add_svelte_meta(
      () => presence_layer_default(node, spread_props(() => get(mergedProps), {
        get open() {
          return get($0);
        },
        get ref() {
          return scrollbarScrollState.scrollbar.opts.ref;
        },
        presence,
        $$slots: { presence: true }
      })),
      "component",
      Scroll_area_scrollbar_scroll,
      15,
      0,
      { componentTag: "PresenceLayer" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_scrollbar_scroll = hmr(Scroll_area_scrollbar_scroll, () => Scroll_area_scrollbar_scroll[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_scrollbar_scroll[HMR].source;
    set(Scroll_area_scrollbar_scroll[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_scrollbar_scroll_default = Scroll_area_scrollbar_scroll;

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-hover.svelte
Scroll_area_scrollbar_hover[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar-hover.svelte";
function Scroll_area_scrollbar_hover($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_scrollbar_hover);
  let forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "forceMount"], "restProps");
  const scrollbarHoverState = ScrollAreaScrollbarHoverState.create();
  const scrollbarAutoState = ScrollAreaScrollbarAutoState.create();
  const mergedProps = tag(
    user_derived(() => mergeProps(restProps, scrollbarHoverState.props, scrollbarAutoState.props, {
      "data-state": scrollbarHoverState.isVisible ? "visible" : "hidden"
    })),
    "mergedProps"
  );
  const open = tag(user_derived(() => forceMount() || scrollbarHoverState.isVisible && scrollbarAutoState.isVisible), "open");
  var fragment = comment();
  var node = first_child(fragment);
  {
    const presence = wrap_snippet(Scroll_area_scrollbar_hover, function($$anchor2) {
      validate_snippet_args(...arguments);
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => scroll_area_scrollbar_visible_default(node_1, spread_props(() => get(mergedProps))), "component", Scroll_area_scrollbar_hover, 28, 2, { componentTag: "ScrollAreaScrollbarVisible" });
      append($$anchor2, fragment_1);
    });
    add_svelte_meta(
      () => presence_layer_default(node, {
        get open() {
          return get(open);
        },
        get ref() {
          return scrollbarAutoState.scrollbar.opts.ref;
        },
        presence,
        $$slots: { presence: true }
      }),
      "component",
      Scroll_area_scrollbar_hover,
      26,
      0,
      { componentTag: "PresenceLayer" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_scrollbar_hover = hmr(Scroll_area_scrollbar_hover, () => Scroll_area_scrollbar_hover[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_scrollbar_hover[HMR].source;
    set(Scroll_area_scrollbar_hover[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_scrollbar_hover_default = Scroll_area_scrollbar_hover;

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar.svelte
Scroll_area_scrollbar[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-scrollbar.svelte";
function Scroll_area_scrollbar($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Scroll_area_scrollbar);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "orientation"
    ],
    "restProps"
  );
  const scrollbarState = ScrollAreaScrollbarState.create({
    orientation: box.with(() => $$props.orientation),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const type = tag(user_derived(() => scrollbarState.root.opts.type.current), "type");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => scroll_area_scrollbar_hover_default(node_1, spread_props(() => restProps, {
          get id() {
            return id();
          }
        })),
        "component",
        Scroll_area_scrollbar,
        33,
        1,
        { componentTag: "ScrollAreaScrollbarHover" }
      );
      append($$anchor2, fragment_1);
    };
    var alternate_2 = ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      {
        var consequent_1 = ($$anchor3) => {
          var fragment_3 = comment();
          var node_3 = first_child(fragment_3);
          add_svelte_meta(
            () => scroll_area_scrollbar_scroll_default(node_3, spread_props(() => restProps, {
              get id() {
                return id();
              }
            })),
            "component",
            Scroll_area_scrollbar,
            35,
            1,
            { componentTag: "ScrollAreaScrollbarScroll" }
          );
          append($$anchor3, fragment_3);
        };
        var alternate_1 = ($$anchor3) => {
          var fragment_4 = comment();
          var node_4 = first_child(fragment_4);
          {
            var consequent_2 = ($$anchor4) => {
              var fragment_5 = comment();
              var node_5 = first_child(fragment_5);
              add_svelte_meta(
                () => scroll_area_scrollbar_auto_default(node_5, spread_props(() => restProps, {
                  get id() {
                    return id();
                  }
                })),
                "component",
                Scroll_area_scrollbar,
                37,
                1,
                { componentTag: "ScrollAreaScrollbarAuto" }
              );
              append($$anchor4, fragment_5);
            };
            var alternate = ($$anchor4) => {
              var fragment_6 = comment();
              var node_6 = first_child(fragment_6);
              {
                var consequent_3 = ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_7 = first_child(fragment_7);
                  add_svelte_meta(
                    () => scroll_area_scrollbar_visible_default(node_7, spread_props(() => restProps, {
                      get id() {
                        return id();
                      }
                    })),
                    "component",
                    Scroll_area_scrollbar,
                    39,
                    1,
                    { componentTag: "ScrollAreaScrollbarVisible" }
                  );
                  append($$anchor5, fragment_7);
                };
                add_svelte_meta(
                  () => if_block(
                    node_6,
                    ($$render) => {
                      if (strict_equals(get(type), "always")) $$render(consequent_3);
                    },
                    true
                  ),
                  "if",
                  Scroll_area_scrollbar,
                  38,
                  0
                );
              }
              append($$anchor4, fragment_6);
            };
            add_svelte_meta(
              () => if_block(
                node_4,
                ($$render) => {
                  if (strict_equals(get(type), "auto")) $$render(consequent_2);
                  else $$render(alternate, false);
                },
                true
              ),
              "if",
              Scroll_area_scrollbar,
              36,
              0
            );
          }
          append($$anchor3, fragment_4);
        };
        add_svelte_meta(
          () => if_block(
            node_2,
            ($$render) => {
              if (strict_equals(get(type), "scroll")) $$render(consequent_1);
              else $$render(alternate_1, false);
            },
            true
          ),
          "if",
          Scroll_area_scrollbar,
          34,
          0
        );
      }
      append($$anchor2, fragment_2);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (strict_equals(get(type), "hover")) $$render(consequent);
        else $$render(alternate_2, false);
      }),
      "if",
      Scroll_area_scrollbar,
      32,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_scrollbar = hmr(Scroll_area_scrollbar, () => Scroll_area_scrollbar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_scrollbar[HMR].source;
    set(Scroll_area_scrollbar[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_scrollbar_default = Scroll_area_scrollbar;

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-thumb-impl.svelte
Scroll_area_thumb_impl[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-thumb-impl.svelte";
var root_292 = add_locations(from_html(`<div><!></div>`), Scroll_area_thumb_impl[FILENAME], [[42, 1]]);
function Scroll_area_thumb_impl($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_thumb_impl);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "child",
      "children",
      "present"
    ],
    "restProps"
  );
  const isMounted = new IsMounted();
  const thumbState = ScrollAreaThumbImplState.create({
    id: box.with(() => $$props.id),
    ref: box.with(() => ref(), (v) => ref(v)),
    mounted: box.with(() => isMounted.current)
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, thumbState.props, { style: { hidden: !$$props.present } })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Scroll_area_thumb_impl, 40, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_292();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Scroll_area_thumb_impl, 43, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Scroll_area_thumb_impl,
      39,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_thumb_impl = hmr(Scroll_area_thumb_impl, () => Scroll_area_thumb_impl[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_thumb_impl[HMR].source;
    set(Scroll_area_thumb_impl[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_thumb_impl_default = Scroll_area_thumb_impl;

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-thumb.svelte
Scroll_area_thumb[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-thumb.svelte";
function Scroll_area_thumb($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Scroll_area_thumb);
  var $$ownership_validator = create_ownership_validator($$props);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "id", "ref", "forceMount"], "restProps");
  const scrollbarState = ScrollAreaScrollbarVisibleContext.get();
  var fragment = comment();
  var node = first_child(fragment);
  {
    const presence = wrap_snippet(Scroll_area_thumb, function($$anchor2, $$arg0) {
      validate_snippet_args(...arguments);
      let present = () => $$arg0?.().present;
      present();
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        $$ownership_validator.binding("ref", scroll_area_thumb_impl_default, ref);
        add_svelte_meta(
          () => scroll_area_thumb_impl_default(node_1, spread_props(() => restProps, {
            get id() {
              return id();
            },
            get present() {
              return present();
            },
            get ref() {
              return ref();
            },
            set ref($$value) {
              ref($$value);
            }
          })),
          "component",
          Scroll_area_thumb,
          22,
          2,
          { componentTag: "ScrollAreaThumbImpl" }
        );
      }
      append($$anchor2, fragment_1);
    });
    let $0 = user_derived(() => forceMount() || scrollbarState.hasThumb);
    add_svelte_meta(
      () => presence_layer_default(node, {
        get open() {
          return get($0);
        },
        get ref() {
          return scrollbarState.scrollbar.opts.ref;
        },
        presence,
        $$slots: { presence: true }
      }),
      "component",
      Scroll_area_thumb,
      20,
      0,
      { componentTag: "PresenceLayer" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_thumb = hmr(Scroll_area_thumb, () => Scroll_area_thumb[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_thumb[HMR].source;
    set(Scroll_area_thumb[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_thumb_default = Scroll_area_thumb;

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-corner-impl.svelte
Scroll_area_corner_impl[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-corner-impl.svelte";
var root_293 = add_locations(from_html(`<div><!></div>`), Scroll_area_corner_impl[FILENAME], [[30, 1]]);
function Scroll_area_corner_impl($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Scroll_area_corner_impl);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "children",
      "child"
    ],
    "restProps"
  );
  const cornerState = ScrollAreaCornerImplState.create({
    id: box.with(() => $$props.id),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, cornerState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Scroll_area_corner_impl, 28, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_293();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Scroll_area_corner_impl, 31, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Scroll_area_corner_impl,
      27,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_corner_impl = hmr(Scroll_area_corner_impl, () => Scroll_area_corner_impl[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_corner_impl[HMR].source;
    set(Scroll_area_corner_impl[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_corner_impl_default = Scroll_area_corner_impl;

// node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-corner.svelte
Scroll_area_corner[FILENAME] = "node_modules/bits-ui/dist/bits/scroll-area/components/scroll-area-corner.svelte";
function Scroll_area_corner($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Scroll_area_corner);
  var $$ownership_validator = create_ownership_validator($$props);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "ref", "id"], "restProps");
  const scrollAreaState = ScrollAreaRootContext.get();
  const hasBothScrollbarsVisible = tag(user_derived(() => Boolean(scrollAreaState.scrollbarXNode && scrollAreaState.scrollbarYNode)), "hasBothScrollbarsVisible");
  const hasCorner = tag(user_derived(() => strict_equals(scrollAreaState.opts.type.current, "scroll", false) && get(hasBothScrollbarsVisible)), "hasCorner");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        $$ownership_validator.binding("ref", scroll_area_corner_impl_default, ref);
        add_svelte_meta(
          () => scroll_area_corner_impl_default(node_1, spread_props(() => restProps, {
            get id() {
              return id();
            },
            get ref() {
              return ref();
            },
            set ref($$value) {
              ref($$value);
            }
          })),
          "component",
          Scroll_area_corner,
          26,
          1,
          { componentTag: "ScrollAreaCornerImpl" }
        );
      }
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (get(hasCorner)) $$render(consequent);
      }),
      "if",
      Scroll_area_corner,
      25,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Scroll_area_corner = hmr(Scroll_area_corner, () => Scroll_area_corner[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Scroll_area_corner[HMR].source;
    set(Scroll_area_corner[HMR].source, module.default[HMR].original);
  });
}
var scroll_area_corner_default = Scroll_area_corner;

// node_modules/bits-ui/dist/bits/select/exports.js
var exports_exports31 = {};
__export(exports_exports31, {
  Content: () => select_content_default,
  ContentStatic: () => select_content_static_default,
  Group: () => select_group_default,
  GroupHeading: () => select_group_heading_default,
  Item: () => select_item_default,
  Portal: () => portal_default,
  Root: () => select_default,
  ScrollDownButton: () => select_scroll_down_button_default,
  ScrollUpButton: () => select_scroll_up_button_default,
  Trigger: () => select_trigger_default,
  Viewport: () => select_viewport_default
});

// node_modules/bits-ui/dist/bits/select/components/select.svelte
Select[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select.svelte";
var root14 = add_locations(from_html(`<!> <!>`, 1), Select[FILENAME], []);
function Select($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Select);
  let value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop3), name = prop($$props, "name", 3, ""), disabled = prop($$props, "disabled", 3, false), open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3), loop = prop($$props, "loop", 3, false), scrollAlignment = prop($$props, "scrollAlignment", 3, "nearest"), required = prop($$props, "required", 3, false), items = prop($$props, "items", 19, () => []), allowDeselect = prop($$props, "allowDeselect", 3, false);
  function handleDefaultValue() {
    if (strict_equals(value(), void 0, false)) return;
    value(strict_equals($$props.type, "single") ? "" : []);
  }
  handleDefaultValue();
  watch.pre(() => value(), () => {
    handleDefaultValue();
  });
  let inputValue = tag(state(""), "inputValue");
  const rootState = SelectRootState.create({
    type: $$props.type,
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    disabled: box.with(() => disabled()),
    required: box.with(() => required()),
    open: box.with(() => open(), (v) => {
      open(v);
      onOpenChange()(v);
    }),
    loop: box.with(() => loop()),
    scrollAlignment: box.with(() => scrollAlignment()),
    name: box.with(() => name()),
    isCombobox: false,
    items: box.with(() => items()),
    allowDeselect: box.with(() => allowDeselect()),
    inputValue: box.with(() => get(inputValue), (v) => set(inputValue, v, true)),
    onOpenChangeComplete: box.with(() => onOpenChangeComplete())
  });
  var fragment = root14();
  var node = first_child(fragment);
  add_svelte_meta(
    () => floating_layer_default(node, {
      children: wrap_snippet(Select, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop), "render", Select, 79, 1);
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }),
    "component",
    Select,
    78,
    0,
    { componentTag: "FloatingLayer" }
  );
  var node_2 = sibling(node, 2);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_2 = comment();
      var node_3 = first_child(fragment_2);
      {
        var consequent = ($$anchor3) => {
          var fragment_3 = comment();
          var node_4 = first_child(fragment_3);
          validate_each_keys(() => rootState.opts.value.current, (item) => item);
          add_svelte_meta(
            () => each(node_4, 16, () => rootState.opts.value.current, (item) => item, ($$anchor4, item) => {
              var fragment_4 = comment();
              var node_5 = first_child(fragment_4);
              add_svelte_meta(
                () => select_hidden_input_default(node_5, {
                  get value() {
                    return item;
                  },
                  get autocomplete() {
                    return $$props.autocomplete;
                  }
                }),
                "component",
                Select,
                85,
                3,
                { componentTag: "SelectHiddenInput" }
              );
              append($$anchor4, fragment_4);
            }),
            "each",
            Select,
            84,
            2
          );
          append($$anchor3, fragment_3);
        };
        add_svelte_meta(
          () => if_block(node_3, ($$render) => {
            if (rootState.opts.value.current.length) $$render(consequent);
          }),
          "if",
          Select,
          83,
          1
        );
      }
      append($$anchor2, fragment_2);
    };
    var alternate = ($$anchor2) => {
      var fragment_5 = comment();
      var node_6 = first_child(fragment_5);
      validate_binding("bind:value={rootState.opts.value.current as string}", () => rootState.opts.value, () => "current", 89, 20);
      add_svelte_meta(
        () => select_hidden_input_default(node_6, {
          get autocomplete() {
            return $$props.autocomplete;
          },
          get value() {
            return rootState.opts.value.current;
          },
          set value($$value) {
            rootState.opts.value.current = $$value;
          }
        }),
        "component",
        Select,
        89,
        1,
        { componentTag: "SelectHiddenInput" }
      );
      append($$anchor2, fragment_5);
    };
    add_svelte_meta(
      () => if_block(node_2, ($$render) => {
        if (Array.isArray(rootState.opts.value.current)) $$render(consequent_1);
        else $$render(alternate, false);
      }),
      "if",
      Select,
      82,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select = hmr(Select, () => Select[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select[HMR].source;
    set(Select[HMR].source, module.default[HMR].original);
  });
}
var select_default = Select;

// node_modules/bits-ui/dist/bits/select/components/select-trigger.svelte
Select_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/select/components/select-trigger.svelte";
var root_320 = add_locations(from_html(`<button><!></button>`), Select_trigger[FILENAME], [[34, 2]]);
function Select_trigger($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Select_trigger);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), type = prop($$props, "type", 3, "button"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "child",
      "children",
      "type"
    ],
    "restProps"
  );
  const triggerState = SelectTriggerState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, triggerState.props, { type: type() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => component(node, () => components_exports.Anchor, ($$anchor2, FloatingLayer_Anchor) => {
      FloatingLayer_Anchor($$anchor2, {
        get id() {
          return id();
        },
        get ref() {
          return triggerState.opts.ref;
        },
        children: wrap_snippet(Select_trigger, ($$anchor3, $$slotProps) => {
          var fragment_1 = comment();
          var node_1 = first_child(fragment_1);
          {
            var consequent = ($$anchor4) => {
              var fragment_2 = comment();
              var node_2 = first_child(fragment_2);
              add_svelte_meta(() => snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Select_trigger, 32, 2);
              append($$anchor4, fragment_2);
            };
            var alternate = ($$anchor4) => {
              var button = root_320();
              attribute_effect(button, () => ({ ...get(mergedProps) }));
              var node_3 = child(button);
              add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop), "render", Select_trigger, 35, 3);
              reset(button);
              append($$anchor4, button);
            };
            add_svelte_meta(
              () => if_block(node_1, ($$render) => {
                if ($$props.child) $$render(consequent);
                else $$render(alternate, false);
              }),
              "if",
              Select_trigger,
              31,
              1
            );
          }
          append($$anchor3, fragment_1);
        }),
        $$slots: { default: true }
      });
    }),
    "component",
    Select_trigger,
    30,
    0,
    { componentTag: "FloatingLayer.Anchor" }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Select_trigger = hmr(Select_trigger, () => Select_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Select_trigger[HMR].source;
    set(Select_trigger[HMR].source, module.default[HMR].original);
  });
}
var select_trigger_default = Select_trigger;

// node_modules/bits-ui/dist/bits/separator/exports.js
var exports_exports32 = {};
__export(exports_exports32, {
  Root: () => separator_default
});

// node_modules/bits-ui/dist/bits/slider/exports.js
var exports_exports33 = {};
__export(exports_exports33, {
  Range: () => slider_range_default,
  Root: () => slider_default,
  Thumb: () => slider_thumb_default,
  ThumbLabel: () => slider_thumb_label_default,
  Tick: () => slider_tick_default,
  TickLabel: () => slider_tick_label_default
});

// node_modules/bits-ui/dist/bits/slider/helpers.js
function getRangeStyles(direction, min, max) {
  const styles = {
    position: "absolute"
  };
  if (direction === "lr") {
    styles.left = `${min}%`;
    styles.right = `${max}%`;
  } else if (direction === "rl") {
    styles.right = `${min}%`;
    styles.left = `${max}%`;
  } else if (direction === "bt") {
    styles.bottom = `${min}%`;
    styles.top = `${max}%`;
  } else {
    styles.top = `${min}%`;
    styles.bottom = `${max}%`;
  }
  return styles;
}
function getThumbStyles(direction, thumbPos) {
  const styles = {
    position: "absolute"
  };
  if (direction === "lr") {
    styles.left = `${thumbPos}%`;
    styles.translate = "-50% 0";
  } else if (direction === "rl") {
    styles.right = `${thumbPos}%`;
    styles.translate = "50% 0";
  } else if (direction === "bt") {
    styles.bottom = `${thumbPos}%`;
    styles.translate = "0 50%";
  } else {
    styles.top = `${thumbPos}%`;
    styles.translate = "0 -50%";
  }
  return styles;
}
function getTickStyles(direction, tickPosition, offsetPercentage) {
  const style = {
    position: "absolute"
  };
  if (direction === "lr") {
    style.left = `${tickPosition}%`;
    style.translate = `${offsetPercentage}% 0`;
  } else if (direction === "rl") {
    style.right = `${tickPosition}%`;
    style.translate = `${-offsetPercentage}% 0`;
  } else if (direction === "bt") {
    style.bottom = `${tickPosition}%`;
    style.translate = `0 ${-offsetPercentage}%`;
  } else {
    style.top = `${tickPosition}%`;
    style.translate = `0 ${offsetPercentage}%`;
  }
  return style;
}
function getTickLabelStyles(direction, tickPosition, labelPosition = "top") {
  const style = {
    position: "absolute"
  };
  if (direction === "lr" || direction === "rl") {
    style.left = direction === "lr" ? `${tickPosition}%` : void 0;
    style.right = direction === "rl" ? `${tickPosition}%` : void 0;
    style.translate = "-50% 0";
    if (labelPosition === "top") {
      style.bottom = "100%";
    } else if (labelPosition === "bottom") {
      style.top = "100%";
    }
  } else {
    if (direction === "tb") {
      style.top = `${tickPosition}%`;
    } else {
      style.bottom = `${tickPosition}%`;
    }
    style.translate = "0 50%";
    if (labelPosition === "left") {
      style.right = "100%";
    } else if (labelPosition === "right") {
      style.left = "100%";
    }
  }
  return style;
}
function getThumbLabelStyles(direction, thumbPosition, labelPosition = "top") {
  const style = {
    position: "absolute"
  };
  if (direction === "lr" || direction === "rl") {
    style.left = direction === "lr" ? `${thumbPosition}%` : void 0;
    style.right = direction === "rl" ? `${thumbPosition}%` : void 0;
    style.translate = "-50% 0";
    if (labelPosition === "top") {
      style.bottom = "100%";
    } else if (labelPosition === "bottom") {
      style.top = "100%";
    }
  } else {
    if (direction === "tb") {
      style.top = `${thumbPosition}%`;
    } else {
      style.bottom = `${thumbPosition}%`;
    }
    style.translate = "0 -50%";
    if (labelPosition === "left") {
      style.right = "100%";
    } else if (labelPosition === "right") {
      style.left = "100%";
    }
  }
  return style;
}
function getDecimalPlaces(num) {
  if (Math.floor(num) === num)
    return 0;
  const str = num.toString();
  if (str.indexOf(".") !== -1 && str.indexOf("e-") === -1) {
    return str.split(".")[1].length;
  } else if (str.indexOf("e-") !== -1) {
    const parts = str.split("e-");
    return parseInt(parts[1], 10);
  }
  return 0;
}
function roundToPrecision(num, precision) {
  const factor = Math.pow(10, precision);
  return Math.round(num * factor) / factor;
}
function normalizeSteps(step, min, max) {
  if (typeof step === "number") {
    const difference = max - min;
    let count = Math.ceil(difference / step);
    const precision = getDecimalPlaces(step);
    const factor = Math.pow(10, precision);
    const intDifference = Math.round(difference * factor);
    const intStep = Math.round(step * factor);
    if (intDifference % intStep === 0) {
      count++;
    }
    const steps = [];
    for (let i = 0; i < count; i++) {
      const value = min + i * step;
      const roundedValue = roundToPrecision(value, precision);
      steps.push(roundedValue);
    }
    return steps;
  }
  return [...new Set(step)].filter((value) => value >= min && value <= max).sort((a2, b) => a2 - b);
}
function snapValueToCustomSteps(value, steps) {
  if (steps.length === 0)
    return value;
  let closest = steps[0];
  let minDistance = Math.abs(value - closest);
  for (const step of steps) {
    const distance = Math.abs(value - step);
    if (distance < minDistance) {
      minDistance = distance;
      closest = step;
    }
  }
  return closest;
}
function getAdjacentStepValue(currentValue, steps, direction) {
  const currentIndex = steps.indexOf(currentValue);
  if (currentIndex === -1) {
    return snapValueToCustomSteps(currentValue, steps);
  }
  if (direction === "next") {
    return currentIndex < steps.length - 1 ? steps[currentIndex + 1] : currentValue;
  } else {
    return currentIndex > 0 ? steps[currentIndex - 1] : currentValue;
  }
}

// node_modules/bits-ui/dist/internal/math.js
function linearScale2(domain, range, clamp2 = true) {
  const [d0, d1] = domain;
  const [r0, r1] = range;
  const slope = (r1 - r0) / (d1 - d0);
  return (x) => {
    const result = r0 + slope * (x - d0);
    if (!clamp2)
      return result;
    if (result > Math.max(r0, r1))
      return Math.max(r0, r1);
    if (result < Math.min(r0, r1))
      return Math.min(r0, r1);
    return result;
  };
}

// node_modules/bits-ui/dist/bits/slider/slider.svelte.js
var sliderAttrs = createBitsAttrs({
  component: "slider",
  parts: [
    "root",
    "thumb",
    "range",
    "tick",
    "tick-label",
    "thumb-label"
  ]
});
var SliderRootContext = new Context("Slider.Root");
var SliderBaseRootState = class {
  opts;
  attachment;
  #isActive = tag(state(false), "SliderBaseRootState.isActive");
  get isActive() {
    return get(this.#isActive);
  }
  set isActive(value) {
    set(this.#isActive, value, true);
  }
  #direction = tag(
    user_derived(() => {
      if (strict_equals(this.opts.orientation.current, "horizontal")) {
        return strict_equals(this.opts.dir.current, "rtl") ? "rl" : "lr";
      } else {
        return strict_equals(this.opts.dir.current, "rtl") ? "tb" : "bt";
      }
    }),
    "SliderBaseRootState.direction"
  );
  get direction() {
    return get(this.#direction);
  }
  set direction(value) {
    set(this.#direction, value);
  }
  #normalizedSteps = tag(
    user_derived(() => {
      return normalizeSteps(this.opts.step.current, this.opts.min.current, this.opts.max.current);
    }),
    "SliderBaseRootState.normalizedSteps"
  );
  get normalizedSteps() {
    return get(this.#normalizedSteps);
  }
  set normalizedSteps(value) {
    set(this.#normalizedSteps, value);
  }
  domContext;
  constructor(opts) {
    this.opts = opts;
    this.attachment = attachRef(opts.ref);
    this.domContext = new DOMContext(this.opts.ref);
  }
  isThumbActive(_index) {
    return this.isActive;
  }
  #touchAction = tag(
    user_derived(() => {
      if (this.opts.disabled.current) return void 0;
      return strict_equals(this.opts.orientation.current, "horizontal") ? "pan-y" : "pan-x";
    }),
    "SliderBaseRootState.#touchAction"
  );
  getAllThumbs = () => {
    const node = this.opts.ref.current;
    if (!node) return [];
    return Array.from(node.querySelectorAll(sliderAttrs.selector("thumb")));
  };
  getThumbScale = () => {
    const trackPadding = this.opts.trackPadding?.current;
    if (strict_equals(trackPadding, void 0, false) && trackPadding > 0) {
      return [trackPadding, 100 - trackPadding];
    }
    if (strict_equals(this.opts.thumbPositioning.current, "exact")) {
      return [0, 100];
    }
    const isVertical = strict_equals(this.opts.orientation.current, "vertical");
    const activeThumb = this.getAllThumbs()[0];
    const thumbSize = isVertical ? activeThumb?.offsetHeight : activeThumb?.offsetWidth;
    if (strict_equals(thumbSize, void 0) || Number.isNaN(thumbSize) || strict_equals(thumbSize, 0)) return [0, 100];
    const trackSize = isVertical ? this.opts.ref.current?.offsetHeight : this.opts.ref.current?.offsetWidth;
    if (strict_equals(trackSize, void 0) || Number.isNaN(trackSize) || strict_equals(trackSize, 0)) return [0, 100];
    const percentPadding = thumbSize / 2 / trackSize * 100;
    const min = percentPadding;
    const max = 100 - percentPadding;
    return [min, max];
  };
  getPositionFromValue = (thumbValue) => {
    const thumbScale = this.getThumbScale();
    const scale = linearScale2([this.opts.min.current, this.opts.max.current], thumbScale);
    return scale(thumbValue);
  };
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "data-orientation": getDataOrientation(this.opts.orientation.current),
      "data-disabled": getDataDisabled(this.opts.disabled.current),
      style: { touchAction: get(this.#touchAction) },
      [sliderAttrs.root]: "",
      ...this.attachment
    })),
    "SliderBaseRootState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var SliderSingleRootState = class extends SliderBaseRootState {
  opts;
  isMulti = false;
  constructor(opts) {
    super(opts);
    this.opts = opts;
    onMountEffect(() => {
      return executeCallbacks(on(this.domContext.getDocument(), "pointerdown", this.handlePointerDown), on(this.domContext.getDocument(), "pointerup", this.handlePointerUp), on(this.domContext.getDocument(), "pointermove", this.handlePointerMove), on(this.domContext.getDocument(), "pointerleave", this.handlePointerUp));
    });
    watch(
      [
        () => this.opts.step.current,
        () => this.opts.min.current,
        () => this.opts.max.current,
        () => this.opts.value.current
      ],
      ([step, min, max, value]) => {
        const steps = normalizeSteps(step, min, max);
        const isValidValue = (v) => {
          return steps.includes(v);
        };
        const gcv = (v) => {
          return snapValueToCustomSteps(v, steps);
        };
        if (!isValidValue(value)) {
          this.opts.value.current = gcv(value);
        }
      }
    );
  }
  isTickValueSelected = (tickValue) => {
    return strict_equals(this.opts.value.current, tickValue);
  };
  applyPosition({ clientXY, start, end }) {
    const min = this.opts.min.current;
    const max = this.opts.max.current;
    const percent = (clientXY - start) / (end - start);
    const val = percent * (max - min) + min;
    if (val < min) {
      this.updateValue(min);
    } else if (val > max) {
      this.updateValue(max);
    } else {
      const steps = this.normalizedSteps;
      const newValue = snapValueToCustomSteps(val, steps);
      this.updateValue(newValue);
    }
  }
  updateValue = (newValue) => {
    this.opts.value.current = snapValueToCustomSteps(newValue, this.normalizedSteps);
  };
  handlePointerMove = (e) => {
    if (!this.isActive || this.opts.disabled.current) return;
    e.preventDefault();
    e.stopPropagation();
    const sliderNode = this.opts.ref.current;
    const activeThumb = this.getAllThumbs()[0];
    if (!sliderNode || !activeThumb) return;
    activeThumb.focus();
    const { left, right, top, bottom } = sliderNode.getBoundingClientRect();
    if (strict_equals(this.direction, "lr")) {
      this.applyPosition({ clientXY: e.clientX, start: left, end: right });
    } else if (strict_equals(this.direction, "rl")) {
      this.applyPosition({ clientXY: e.clientX, start: right, end: left });
    } else if (strict_equals(this.direction, "bt")) {
      this.applyPosition({ clientXY: e.clientY, start: bottom, end: top });
    } else if (strict_equals(this.direction, "tb")) {
      this.applyPosition({ clientXY: e.clientY, start: top, end: bottom });
    }
  };
  handlePointerDown = (e) => {
    if (strict_equals(e.button, 0, false) || this.opts.disabled.current) return;
    const sliderNode = this.opts.ref.current;
    const closestThumb = this.getAllThumbs()[0];
    if (!closestThumb || !sliderNode) return;
    const target = e.composedPath()[0] ?? e.target;
    if (!isElementOrSVGElement(target) || !sliderNode.contains(target)) return;
    e.preventDefault();
    closestThumb.focus();
    this.isActive = true;
    this.handlePointerMove(e);
  };
  handlePointerUp = () => {
    if (this.opts.disabled.current) return;
    if (this.isActive) {
      this.opts.onValueCommit.current(untrack(() => this.opts.value.current));
    }
    this.isActive = false;
  };
  #thumbsPropsArr = tag(
    user_derived(() => {
      const currValue = this.opts.value.current;
      return Array.from({ length: 1 }, () => {
        const thumbValue = currValue;
        const thumbPosition = this.getPositionFromValue(thumbValue);
        const style = getThumbStyles(this.direction, thumbPosition);
        return {
          role: "slider",
          "aria-valuemin": this.opts.min.current,
          "aria-valuemax": this.opts.max.current,
          "aria-valuenow": thumbValue,
          "aria-disabled": getAriaDisabled(this.opts.disabled.current),
          "aria-orientation": getAriaOrientation(this.opts.orientation.current),
          "data-value": thumbValue,
          "data-orientation": getDataOrientation(this.opts.orientation.current),
          style,
          [sliderAttrs.thumb]: ""
        };
      });
    }),
    "SliderSingleRootState.thumbsPropsArr"
  );
  get thumbsPropsArr() {
    return get(this.#thumbsPropsArr);
  }
  set thumbsPropsArr(value) {
    set(this.#thumbsPropsArr, value);
  }
  #thumbsRenderArr = tag(
    user_derived(() => {
      return this.thumbsPropsArr.map((_, i) => i);
    }),
    "SliderSingleRootState.thumbsRenderArr"
  );
  get thumbsRenderArr() {
    return get(this.#thumbsRenderArr);
  }
  set thumbsRenderArr(value) {
    set(this.#thumbsRenderArr, value);
  }
  #ticksPropsArr = tag(
    user_derived(() => {
      const steps = this.normalizedSteps;
      const currValue = this.opts.value.current;
      return steps.map((tickValue, i) => {
        const tickPosition = this.getPositionFromValue(tickValue);
        const isFirst = strict_equals(i, 0);
        const isLast = strict_equals(i, steps.length - 1);
        const offsetPercentage = isFirst ? 0 : isLast ? -100 : -50;
        const style = getTickStyles(this.direction, tickPosition, offsetPercentage);
        const bounded = tickValue <= currValue;
        return {
          "data-disabled": getDataDisabled(this.opts.disabled.current),
          "data-orientation": getDataOrientation(this.opts.orientation.current),
          "data-bounded": bounded ? "" : void 0,
          "data-value": tickValue,
          "data-selected": this.isTickValueSelected(tickValue) ? "" : void 0,
          style,
          [sliderAttrs.tick]: ""
        };
      });
    }),
    "SliderSingleRootState.ticksPropsArr"
  );
  get ticksPropsArr() {
    return get(this.#ticksPropsArr);
  }
  set ticksPropsArr(value) {
    set(this.#ticksPropsArr, value);
  }
  #ticksRenderArr = tag(
    user_derived(() => {
      return this.ticksPropsArr.map((_, i) => i);
    }),
    "SliderSingleRootState.ticksRenderArr"
  );
  get ticksRenderArr() {
    return get(this.#ticksRenderArr);
  }
  set ticksRenderArr(value) {
    set(this.#ticksRenderArr, value);
  }
  #tickItemsArr = tag(
    user_derived(() => {
      return this.ticksPropsArr.map((tick2, i) => ({ value: tick2["data-value"], index: i }));
    }),
    "SliderSingleRootState.tickItemsArr"
  );
  get tickItemsArr() {
    return get(this.#tickItemsArr);
  }
  set tickItemsArr(value) {
    set(this.#tickItemsArr, value);
  }
  #thumbItemsArr = tag(
    user_derived(() => {
      const currValue = this.opts.value.current;
      return [{ value: currValue, index: 0 }];
    }),
    "SliderSingleRootState.thumbItemsArr"
  );
  get thumbItemsArr() {
    return get(this.#thumbItemsArr);
  }
  set thumbItemsArr(value) {
    set(this.#thumbItemsArr, value);
  }
  #snippetProps = tag(
    user_derived(() => ({
      ticks: this.ticksRenderArr,
      thumbs: this.thumbsRenderArr,
      tickItems: this.tickItemsArr,
      thumbItems: this.thumbItemsArr
    })),
    "SliderSingleRootState.snippetProps"
  );
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
};
var SliderMultiRootState = class extends SliderBaseRootState {
  opts;
  isMulti = true;
  #activeThumb = tag(state(null), "SliderMultiRootState.activeThumb");
  get activeThumb() {
    return get(this.#activeThumb);
  }
  set activeThumb(value) {
    set(this.#activeThumb, value, true);
  }
  #currentThumbIdx = tag(state(0), "SliderMultiRootState.currentThumbIdx");
  get currentThumbIdx() {
    return get(this.#currentThumbIdx);
  }
  set currentThumbIdx(value) {
    set(this.#currentThumbIdx, value, true);
  }
  constructor(opts) {
    super(opts);
    this.opts = opts;
    onMountEffect(() => {
      return executeCallbacks(on(this.domContext.getDocument(), "pointerdown", this.handlePointerDown), on(this.domContext.getDocument(), "pointerup", this.handlePointerUp), on(this.domContext.getDocument(), "pointermove", this.handlePointerMove), on(this.domContext.getDocument(), "pointerleave", this.handlePointerUp));
    });
    watch(
      [
        () => this.opts.step.current,
        () => this.opts.min.current,
        () => this.opts.max.current,
        () => this.opts.value.current
      ],
      ([step, min, max, value]) => {
        const steps = normalizeSteps(step, min, max);
        const isValidValue = (v) => {
          return steps.includes(v);
        };
        const gcv = (v) => {
          return snapValueToCustomSteps(v, steps);
        };
        if (value.some((v) => !isValidValue(v))) {
          this.opts.value.current = value.map(gcv);
        }
      }
    );
  }
  isTickValueSelected = (tickValue) => {
    return this.opts.value.current.includes(tickValue);
  };
  isThumbActive(index) {
    return this.isActive && strict_equals(this.activeThumb?.idx, index);
  }
  applyPosition({ clientXY, activeThumbIdx, start, end }) {
    const min = this.opts.min.current;
    const max = this.opts.max.current;
    const percent = (clientXY - start) / (end - start);
    const val = percent * (max - min) + min;
    if (val < min) {
      this.updateValue(min, activeThumbIdx);
    } else if (val > max) {
      this.updateValue(max, activeThumbIdx);
    } else {
      const steps = this.normalizedSteps;
      const newValue = snapValueToCustomSteps(val, steps);
      this.updateValue(newValue, activeThumbIdx);
    }
  }
  #getClosestThumb = (e) => {
    const thumbs = this.getAllThumbs();
    if (!thumbs.length) return;
    for (const thumb of thumbs) {
      thumb.blur();
    }
    const distances = thumbs.map((thumb) => {
      if (strict_equals(this.opts.orientation.current, "horizontal")) {
        const { left, right } = thumb.getBoundingClientRect();
        return Math.abs(e.clientX - (left + right) / 2);
      } else {
        const { top, bottom } = thumb.getBoundingClientRect();
        return Math.abs(e.clientY - (top + bottom) / 2);
      }
    });
    const node = thumbs[distances.indexOf(Math.min(...distances))];
    const idx = thumbs.indexOf(node);
    return { node, idx };
  };
  handlePointerMove = (e) => {
    if (!this.isActive || this.opts.disabled.current) return;
    e.preventDefault();
    e.stopPropagation();
    const sliderNode = this.opts.ref.current;
    const activeThumb = this.activeThumb;
    if (!sliderNode || !activeThumb) return;
    activeThumb.node.focus();
    const { left, right, top, bottom } = sliderNode.getBoundingClientRect();
    const direction = this.direction;
    if (strict_equals(direction, "lr")) {
      this.applyPosition({
        clientXY: e.clientX,
        activeThumbIdx: activeThumb.idx,
        start: left,
        end: right
      });
    } else if (strict_equals(direction, "rl")) {
      this.applyPosition({
        clientXY: e.clientX,
        activeThumbIdx: activeThumb.idx,
        start: right,
        end: left
      });
    } else if (strict_equals(direction, "bt")) {
      this.applyPosition({
        clientXY: e.clientY,
        activeThumbIdx: activeThumb.idx,
        start: bottom,
        end: top
      });
    } else if (strict_equals(direction, "tb")) {
      this.applyPosition({
        clientXY: e.clientY,
        activeThumbIdx: activeThumb.idx,
        start: top,
        end: bottom
      });
    }
  };
  handlePointerDown = (e) => {
    if (strict_equals(e.button, 0, false) || this.opts.disabled.current) return;
    const sliderNode = this.opts.ref.current;
    const closestThumb = this.#getClosestThumb(e);
    if (!closestThumb || !sliderNode) return;
    const target = e.composedPath()[0] ?? e.target;
    if (!isElementOrSVGElement(target) || !sliderNode.contains(target)) return;
    e.preventDefault();
    this.activeThumb = closestThumb;
    closestThumb.node.focus();
    this.isActive = true;
    this.handlePointerMove(e);
  };
  handlePointerUp = () => {
    if (this.opts.disabled.current) return;
    if (this.isActive) {
      this.opts.onValueCommit.current(untrack(() => this.opts.value.current));
    }
    this.isActive = false;
  };
  getAllThumbs = () => {
    const node = this.opts.ref.current;
    if (!node) return [];
    const thumbs = Array.from(node.querySelectorAll(sliderAttrs.selector("thumb")));
    return thumbs;
  };
  updateValue = (thumbValue, idx) => {
    const currValue = this.opts.value.current;
    if (!currValue.length) {
      this.opts.value.current.push(thumbValue);
      return;
    }
    const valueAtIndex = currValue[idx];
    if (strict_equals(valueAtIndex, thumbValue)) return;
    const newValue = [...currValue];
    if (!isValidIndex(idx, newValue)) return;
    const direction = newValue[idx] > thumbValue ? -1 : 1;
    const swap = () => {
      const diffIndex = idx + direction;
      newValue[idx] = newValue[diffIndex];
      newValue[diffIndex] = thumbValue;
      const thumbs = this.getAllThumbs();
      if (!thumbs.length) return;
      thumbs[diffIndex]?.focus();
      this.activeThumb = { node: thumbs[diffIndex], idx: diffIndex };
    };
    if (this.opts.autoSort.current && (strict_equals(direction, -1) && thumbValue < newValue[idx - 1] || strict_equals(direction, 1) && thumbValue > newValue[idx + 1])) {
      swap();
      this.opts.value.current = newValue;
      return;
    }
    const steps = this.normalizedSteps;
    newValue[idx] = snapValueToCustomSteps(thumbValue, steps);
    this.opts.value.current = newValue;
  };
  #thumbsPropsArr = tag(
    user_derived(() => {
      const currValue = this.opts.value.current;
      return Array.from({ length: currValue.length || 1 }, (_, i) => {
        const currThumb = untrack(() => this.currentThumbIdx);
        if (currThumb < currValue.length) {
          untrack(() => {
            this.currentThumbIdx = currThumb + 1;
          });
        }
        const thumbValue = currValue[i];
        const thumbPosition = this.getPositionFromValue(thumbValue ?? 0);
        const style = getThumbStyles(this.direction, thumbPosition);
        return {
          role: "slider",
          "aria-valuemin": this.opts.min.current,
          "aria-valuemax": this.opts.max.current,
          "aria-valuenow": thumbValue,
          "aria-disabled": getAriaDisabled(this.opts.disabled.current),
          "aria-orientation": getAriaOrientation(this.opts.orientation.current),
          "data-value": thumbValue,
          "data-orientation": getDataOrientation(this.opts.orientation.current),
          style,
          [sliderAttrs.thumb]: ""
        };
      });
    }),
    "SliderMultiRootState.thumbsPropsArr"
  );
  get thumbsPropsArr() {
    return get(this.#thumbsPropsArr);
  }
  set thumbsPropsArr(value) {
    set(this.#thumbsPropsArr, value);
  }
  #thumbsRenderArr = tag(
    user_derived(() => {
      return this.thumbsPropsArr.map((_, i) => i);
    }),
    "SliderMultiRootState.thumbsRenderArr"
  );
  get thumbsRenderArr() {
    return get(this.#thumbsRenderArr);
  }
  set thumbsRenderArr(value) {
    set(this.#thumbsRenderArr, value);
  }
  #ticksPropsArr = tag(
    user_derived(() => {
      const steps = this.normalizedSteps;
      const currValue = this.opts.value.current;
      return steps.map((tickValue, i) => {
        const tickPosition = this.getPositionFromValue(tickValue);
        const isFirst = strict_equals(i, 0);
        const isLast = strict_equals(i, steps.length - 1);
        const offsetPercentage = isFirst ? 0 : isLast ? -100 : -50;
        const style = getTickStyles(this.direction, tickPosition, offsetPercentage);
        const bounded = strict_equals(currValue.length, 1) ? tickValue <= currValue[0] : currValue[0] <= tickValue && tickValue <= currValue[currValue.length - 1];
        return {
          "data-disabled": getDataDisabled(this.opts.disabled.current),
          "data-orientation": getDataOrientation(this.opts.orientation.current),
          "data-bounded": bounded ? "" : void 0,
          "data-value": tickValue,
          style,
          [sliderAttrs.tick]: ""
        };
      });
    }),
    "SliderMultiRootState.ticksPropsArr"
  );
  get ticksPropsArr() {
    return get(this.#ticksPropsArr);
  }
  set ticksPropsArr(value) {
    set(this.#ticksPropsArr, value);
  }
  #ticksRenderArr = tag(
    user_derived(() => {
      return this.ticksPropsArr.map((_, i) => i);
    }),
    "SliderMultiRootState.ticksRenderArr"
  );
  get ticksRenderArr() {
    return get(this.#ticksRenderArr);
  }
  set ticksRenderArr(value) {
    set(this.#ticksRenderArr, value);
  }
  #tickItemsArr = tag(
    user_derived(() => {
      return this.ticksPropsArr.map((tick2, i) => ({ value: tick2["data-value"], index: i }));
    }),
    "SliderMultiRootState.tickItemsArr"
  );
  get tickItemsArr() {
    return get(this.#tickItemsArr);
  }
  set tickItemsArr(value) {
    set(this.#tickItemsArr, value);
  }
  #thumbItemsArr = tag(
    user_derived(() => {
      const currValue = this.opts.value.current;
      return currValue.map((value, index) => ({ value, index }));
    }),
    "SliderMultiRootState.thumbItemsArr"
  );
  get thumbItemsArr() {
    return get(this.#thumbItemsArr);
  }
  set thumbItemsArr(value) {
    set(this.#thumbItemsArr, value);
  }
  #snippetProps = tag(
    user_derived(() => ({
      ticks: this.ticksRenderArr,
      thumbs: this.thumbsRenderArr,
      tickItems: this.tickItemsArr,
      thumbItems: this.thumbItemsArr
    })),
    "SliderMultiRootState.snippetProps"
  );
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
};
var SliderRootState = class {
  static create(opts) {
    const { type, ...rest } = opts;
    const rootState = strict_equals(type, "single") ? new SliderSingleRootState(rest) : new SliderMultiRootState(rest);
    return SliderRootContext.set(rootState);
  }
};
var VALID_SLIDER_KEYS = [
  kbd_constants_exports.ARROW_LEFT,
  kbd_constants_exports.ARROW_RIGHT,
  kbd_constants_exports.ARROW_UP,
  kbd_constants_exports.ARROW_DOWN,
  kbd_constants_exports.HOME,
  kbd_constants_exports.END
];
var SliderRangeState = class _SliderRangeState {
  static create(opts) {
    return new _SliderRangeState(opts, SliderRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
  }
  #rangeStyles = tag(
    user_derived(() => {
      if (Array.isArray(this.root.opts.value.current)) {
        const min = this.root.opts.value.current.length > 1 ? this.root.getPositionFromValue(Math.min(...this.root.opts.value.current) ?? 0) : 0;
        const max = 100 - this.root.getPositionFromValue(Math.max(...this.root.opts.value.current) ?? 0);
        return {
          position: "absolute",
          ...getRangeStyles(this.root.direction, min, max)
        };
      } else {
        const trackPadding = this.root.opts.trackPadding?.current;
        const currentValue = this.root.opts.value.current;
        const maxValue = this.root.opts.max.current;
        const min = 0;
        const max = strict_equals(trackPadding, void 0, false) && trackPadding > 0 && strict_equals(currentValue, maxValue) ? 0 : (
          // 100% - 0% = full width
          100 - this.root.getPositionFromValue(currentValue)
        );
        return {
          position: "absolute",
          ...getRangeStyles(this.root.direction, min, max)
        };
      }
    }),
    "SliderRangeState.rangeStyles"
  );
  get rangeStyles() {
    return get(this.#rangeStyles);
  }
  set rangeStyles(value) {
    set(this.#rangeStyles, value);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "data-orientation": getDataOrientation(this.root.opts.orientation.current),
      "data-disabled": getDataDisabled(this.root.opts.disabled.current),
      style: this.rangeStyles,
      [sliderAttrs.range]: "",
      ...this.attachment
    })),
    "SliderRangeState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var SliderThumbState = class _SliderThumbState {
  static create(opts) {
    return new _SliderThumbState(opts, SliderRootContext.get());
  }
  opts;
  root;
  attachment;
  #isDisabled = tag(user_derived(() => this.root.opts.disabled.current || this.opts.disabled.current), "SliderThumbState.#isDisabled");
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
    this.onkeydown = this.onkeydown.bind(this);
  }
  #updateValue(newValue) {
    if (this.root.isMulti) {
      this.root.updateValue(newValue, this.opts.index.current);
    } else {
      this.root.updateValue(newValue);
    }
  }
  onkeydown(e) {
    if (get(this.#isDisabled)) return;
    const currNode = this.opts.ref.current;
    if (!currNode) return;
    const thumbs = this.root.getAllThumbs();
    if (!thumbs.length) return;
    const idx = thumbs.indexOf(currNode);
    if (this.root.isMulti) {
      this.root.currentThumbIdx = idx;
    }
    if (!VALID_SLIDER_KEYS.includes(e.key)) return;
    e.preventDefault();
    const min = this.root.opts.min.current;
    const max = this.root.opts.max.current;
    const value = this.root.opts.value.current;
    const thumbValue = Array.isArray(value) ? value[idx] : value;
    const orientation = this.root.opts.orientation.current;
    const direction = this.root.direction;
    const steps = this.root.normalizedSteps;
    switch (e.key) {
      case kbd_constants_exports.HOME:
        this.#updateValue(min);
        break;
      case kbd_constants_exports.END:
        this.#updateValue(max);
        break;
      case kbd_constants_exports.ARROW_LEFT:
        if (strict_equals(orientation, "horizontal", false)) break;
        if (e.metaKey) {
          const newValue = strict_equals(direction, "rl") ? max : min;
          this.#updateValue(newValue);
        } else {
          const stepDirection = strict_equals(direction, "rl") ? "next" : "prev";
          const newValue = getAdjacentStepValue(thumbValue, steps, stepDirection);
          this.#updateValue(newValue);
        }
        break;
      case kbd_constants_exports.ARROW_RIGHT:
        if (strict_equals(orientation, "horizontal", false)) break;
        if (e.metaKey) {
          const newValue = strict_equals(direction, "rl") ? min : max;
          this.#updateValue(newValue);
        } else {
          const stepDirection = strict_equals(direction, "rl") ? "prev" : "next";
          const newValue = getAdjacentStepValue(thumbValue, steps, stepDirection);
          this.#updateValue(newValue);
        }
        break;
      case kbd_constants_exports.ARROW_UP:
        if (e.metaKey) {
          const newValue = strict_equals(direction, "tb") ? min : max;
          this.#updateValue(newValue);
        } else {
          const stepDirection = strict_equals(direction, "tb") ? "prev" : "next";
          const newValue = getAdjacentStepValue(thumbValue, steps, stepDirection);
          this.#updateValue(newValue);
        }
        break;
      case kbd_constants_exports.ARROW_DOWN:
        if (e.metaKey) {
          const newValue = strict_equals(direction, "tb") ? max : min;
          this.#updateValue(newValue);
        } else {
          const stepDirection = strict_equals(direction, "tb") ? "next" : "prev";
          const newValue = getAdjacentStepValue(thumbValue, steps, stepDirection);
          this.#updateValue(newValue);
        }
        break;
    }
    this.root.opts.onValueCommit.current(this.root.opts.value.current);
  }
  #props = tag(
    user_derived(() => ({
      ...this.root.thumbsPropsArr[this.opts.index.current],
      id: this.opts.id.current,
      onkeydown: this.onkeydown,
      "data-active": this.root.isThumbActive(this.opts.index.current) ? "" : void 0,
      "data-disabled": getDataDisabled(this.opts.disabled.current || this.root.opts.disabled.current),
      tabindex: this.opts.disabled.current || this.root.opts.disabled.current ? -1 : 0,
      ...this.attachment
    })),
    "SliderThumbState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var SliderTickState = class _SliderTickState {
  static create(opts) {
    return new _SliderTickState(opts, SliderRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
  }
  #props = tag(
    user_derived(() => ({
      ...this.root.ticksPropsArr[this.opts.index.current],
      id: this.opts.id.current,
      ...this.attachment
    })),
    "SliderTickState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var SliderTickLabelState = class _SliderTickLabelState {
  static create(opts) {
    return new _SliderTickLabelState(opts, SliderRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
  }
  #props = tag(
    user_derived(() => {
      const tickProps = this.root.ticksPropsArr[this.opts.index.current];
      const steps = this.root.normalizedSteps;
      const tickValue = steps[this.opts.index.current];
      const tickPosition = this.root.getPositionFromValue(tickValue);
      const labelPosition = this.opts.position?.current ?? "top";
      const style = getTickLabelStyles(this.root.direction, tickPosition, labelPosition);
      return {
        id: this.opts.id.current,
        "data-orientation": getDataOrientation(this.root.opts.orientation.current),
        "data-disabled": getDataDisabled(this.root.opts.disabled.current),
        "data-bounded": tickProps["data-bounded"],
        "data-value": tickValue,
        "data-selected": this.root.isTickValueSelected(tickValue) ? "" : void 0,
        "data-position": labelPosition,
        style,
        [sliderAttrs["tick-label"]]: "",
        ...this.attachment
      };
    }),
    "SliderTickLabelState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var SliderThumbLabelState = class _SliderThumbLabelState {
  static create(opts) {
    return new _SliderThumbLabelState(opts, SliderRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
  }
  #props = tag(
    user_derived(() => {
      const value = this.root.opts.value.current;
      const thumbValue = Array.isArray(value) ? value[this.opts.index.current] : value;
      const thumbPosition = this.root.getPositionFromValue(thumbValue);
      const labelPosition = this.opts.position?.current ?? "top";
      const style = getThumbLabelStyles(this.root.direction, thumbPosition, labelPosition);
      return {
        id: this.opts.id.current,
        "data-orientation": getDataOrientation(this.root.opts.orientation.current),
        "data-disabled": getDataDisabled(this.root.opts.disabled.current),
        "data-value": thumbValue,
        "data-active": this.root.isThumbActive(this.opts.index.current) ? "" : void 0,
        "data-position": labelPosition,
        style,
        [sliderAttrs["thumb-label"]]: "",
        ...this.attachment
      };
    }),
    "SliderThumbLabelState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};

// node_modules/bits-ui/dist/bits/slider/components/slider.svelte
Slider[FILENAME] = "node_modules/bits-ui/dist/bits/slider/components/slider.svelte";
var root_294 = add_locations(from_html(`<span><!></span>`), Slider[FILENAME], [[96, 1]]);
function Slider($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Slider);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop3), onValueCommit = prop($$props, "onValueCommit", 3, noop3), disabled = prop($$props, "disabled", 3, false), step = prop($$props, "step", 3, 1), dir = prop($$props, "dir", 3, "ltr"), autoSort = prop($$props, "autoSort", 3, true), orientation = prop($$props, "orientation", 3, "horizontal"), thumbPositioning = prop($$props, "thumbPositioning", 3, "contain"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "value",
      "type",
      "onValueChange",
      "onValueCommit",
      "disabled",
      "min",
      "max",
      "step",
      "dir",
      "autoSort",
      "orientation",
      "thumbPositioning",
      "trackPadding"
    ],
    "restProps"
  );
  const min = tag(
    user_derived(() => {
      if (strict_equals($$props.min, void 0, false)) return $$props.min;
      if (Array.isArray(step())) return Math.min(...step());
      return 0;
    }),
    "min"
  );
  const max = tag(
    user_derived(() => {
      if (strict_equals($$props.max, void 0, false)) return $$props.max;
      if (Array.isArray(step())) return Math.max(...step());
      return 100;
    }),
    "max"
  );
  function handleDefaultValue() {
    if (strict_equals(value(), void 0, false)) return;
    if (strict_equals($$props.type, "single")) {
      return get(min);
    }
    return [];
  }
  handleDefaultValue();
  watch.pre(() => value(), () => {
    handleDefaultValue();
  });
  const rootState = SliderRootState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    // @ts-expect-error - we know
    onValueCommit: box.with(() => onValueCommit()),
    disabled: box.with(() => disabled()),
    min: box.with(() => get(min)),
    max: box.with(() => get(max)),
    step: box.with(() => step()),
    dir: box.with(() => dir()),
    autoSort: box.with(() => autoSort()),
    orientation: box.with(() => orientation()),
    thumbPositioning: box.with(() => thumbPositioning()),
    type: $$props.type,
    trackPadding: box.with(() => $$props.trackPadding)
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => ({ props: get(mergedProps), ...rootState.snippetProps }));
        add_svelte_meta(() => snippet(node_1, () => $$props.child, () => get($0)), "render", Slider, 94, 1);
      }
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_294();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => rootState.snippetProps), "render", Slider, 97, 2);
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Slider,
      93,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Slider = hmr(Slider, () => Slider[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Slider[HMR].source;
    set(Slider[HMR].source, module.default[HMR].original);
  });
}
var slider_default = Slider;

// node_modules/bits-ui/dist/bits/slider/components/slider-range.svelte
Slider_range[FILENAME] = "node_modules/bits-ui/dist/bits/slider/components/slider-range.svelte";
var root_295 = add_locations(from_html(`<span><!></span>`), Slider_range[FILENAME], [[30, 1]]);
function Slider_range($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Slider_range);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const rangeState = SliderRangeState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rangeState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Slider_range, 28, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_295();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Slider_range, 31, 2);
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Slider_range,
      27,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Slider_range = hmr(Slider_range, () => Slider_range[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Slider_range[HMR].source;
    set(Slider_range[HMR].source, module.default[HMR].original);
  });
}
var slider_range_default = Slider_range;

// node_modules/bits-ui/dist/bits/slider/components/slider-thumb.svelte
Slider_thumb[FILENAME] = "node_modules/bits-ui/dist/bits/slider/components/slider-thumb.svelte";
var root_296 = add_locations(from_html(`<span><!></span>`), Slider_thumb[FILENAME], [[38, 1]]);
function Slider_thumb($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Slider_thumb);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id",
      "index",
      "disabled"
    ],
    "restProps"
  );
  const thumbState = SliderThumbState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    index: box.with(() => $$props.index),
    disabled: box.with(() => disabled())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, thumbState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => ({
          active: thumbState.root.isThumbActive(thumbState.opts.index.current),
          props: get(mergedProps)
        }));
        add_svelte_meta(() => snippet(node_1, () => $$props.child, () => get($0)), "render", Slider_thumb, 33, 1);
      }
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_296();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      {
        let $0 = user_derived(() => ({
          active: thumbState.root.isThumbActive(thumbState.opts.index.current)
        }));
        add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => get($0)), "render", Slider_thumb, 39, 2);
      }
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Slider_thumb,
      32,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Slider_thumb = hmr(Slider_thumb, () => Slider_thumb[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Slider_thumb[HMR].source;
    set(Slider_thumb[HMR].source, module.default[HMR].original);
  });
}
var slider_thumb_default = Slider_thumb;

// node_modules/bits-ui/dist/bits/slider/components/slider-tick.svelte
Slider_tick[FILENAME] = "node_modules/bits-ui/dist/bits/slider/components/slider-tick.svelte";
var root_297 = add_locations(from_html(`<span><!></span>`), Slider_tick[FILENAME], [[33, 1]]);
function Slider_tick($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Slider_tick);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id",
      "index"
    ],
    "restProps"
  );
  const tickState = SliderTickState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    index: box.with(() => $$props.index)
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, tickState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Slider_tick, 31, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_297();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Slider_tick, 33, 24);
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Slider_tick,
      30,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Slider_tick = hmr(Slider_tick, () => Slider_tick[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Slider_tick[HMR].source;
    set(Slider_tick[HMR].source, module.default[HMR].original);
  });
}
var slider_tick_default = Slider_tick;

// node_modules/bits-ui/dist/bits/slider/components/slider-tick-label.svelte
Slider_tick_label[FILENAME] = "node_modules/bits-ui/dist/bits/slider/components/slider-tick-label.svelte";
var root_321 = add_locations(from_html(`<span><!></span>`), Slider_tick_label[FILENAME], [[49, 1]]);
function Slider_tick_label($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Slider_tick_label);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id",
      "index",
      "position"
    ],
    "restProps"
  );
  const root18 = SliderRootContext.get();
  const position = tag(
    user_derived(() => {
      if (strict_equals($$props.position, void 0, false)) return $$props.position;
      switch (root18.direction) {
        case "lr":
        case "rl":
          return "top";
        case "tb":
        case "bt":
          return "left";
      }
    }),
    "position"
  );
  const tickLabelState = SliderTickLabelState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    index: box.with(() => $$props.index),
    position: box.with(() => get(position))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, tickLabelState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Slider_tick_label, 47, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_321();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Slider_tick_label, 49, 24);
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Slider_tick_label,
      46,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Slider_tick_label = hmr(Slider_tick_label, () => Slider_tick_label[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Slider_tick_label[HMR].source;
    set(Slider_tick_label[HMR].source, module.default[HMR].original);
  });
}
var slider_tick_label_default = Slider_tick_label;

// node_modules/bits-ui/dist/bits/slider/components/slider-thumb-label.svelte
Slider_thumb_label[FILENAME] = "node_modules/bits-ui/dist/bits/slider/components/slider-thumb-label.svelte";
var root_322 = add_locations(from_html(`<span><!></span>`), Slider_thumb_label[FILENAME], [[49, 1]]);
function Slider_thumb_label($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Slider_thumb_label);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "id",
      "index",
      "position"
    ],
    "restProps"
  );
  const root18 = SliderRootContext.get();
  const position = tag(
    user_derived(() => {
      if (strict_equals($$props.position, void 0, false)) return $$props.position;
      switch (root18.direction) {
        case "lr":
        case "rl":
          return "top";
        case "tb":
        case "bt":
          return "left";
      }
    }),
    "position"
  );
  const tickLabelState = SliderThumbLabelState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    index: box.with(() => $$props.index),
    position: box.with(() => get(position))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, tickLabelState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Slider_thumb_label, 47, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_322();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Slider_thumb_label, 49, 24);
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Slider_thumb_label,
      46,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Slider_thumb_label = hmr(Slider_thumb_label, () => Slider_thumb_label[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Slider_thumb_label[HMR].source;
    set(Slider_thumb_label[HMR].source, module.default[HMR].original);
  });
}
var slider_thumb_label_default = Slider_thumb_label;

// node_modules/bits-ui/dist/bits/switch/exports.js
var exports_exports34 = {};
__export(exports_exports34, {
  Root: () => switch_default,
  Thumb: () => switch_thumb_default
});

// node_modules/bits-ui/dist/bits/switch/switch.svelte.js
var switchAttrs = createBitsAttrs({ component: "switch", parts: ["root", "thumb"] });
var SwitchRootContext = new Context("Switch.Root");
var SwitchRootState = class _SwitchRootState {
  static create(opts) {
    return SwitchRootContext.set(new _SwitchRootState(opts));
  }
  opts;
  attachment;
  constructor(opts) {
    this.opts = opts;
    this.attachment = attachRef(opts.ref);
    this.onkeydown = this.onkeydown.bind(this);
    this.onclick = this.onclick.bind(this);
  }
  #toggle() {
    this.opts.checked.current = !this.opts.checked.current;
  }
  onkeydown(e) {
    if (!(strict_equals(e.key, kbd_constants_exports.ENTER) || strict_equals(e.key, kbd_constants_exports.SPACE)) || this.opts.disabled.current) return;
    e.preventDefault();
    this.#toggle();
  }
  onclick(_) {
    if (this.opts.disabled.current) return;
    this.#toggle();
  }
  #sharedProps = tag(
    user_derived(() => ({
      "data-disabled": getDataDisabled(this.opts.disabled.current),
      "data-state": getDataChecked(this.opts.checked.current),
      "data-required": getDataRequired(this.opts.required.current)
    })),
    "SwitchRootState.sharedProps"
  );
  get sharedProps() {
    return get(this.#sharedProps);
  }
  set sharedProps(value) {
    set(this.#sharedProps, value);
  }
  #snippetProps = tag(user_derived(() => ({ checked: this.opts.checked.current })), "SwitchRootState.snippetProps");
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
  #props = tag(
    user_derived(() => ({
      ...this.sharedProps,
      id: this.opts.id.current,
      role: "switch",
      disabled: getDisabled(this.opts.disabled.current),
      "aria-checked": getAriaChecked(this.opts.checked.current, false),
      "aria-required": getAriaRequired(this.opts.required.current),
      [switchAttrs.root]: "",
      onclick: this.onclick,
      onkeydown: this.onkeydown,
      ...this.attachment
    })),
    "SwitchRootState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var SwitchInputState = class _SwitchInputState {
  static create() {
    return new _SwitchInputState(SwitchRootContext.get());
  }
  root;
  #shouldRender = tag(user_derived(() => strict_equals(this.root.opts.name.current, void 0, false)), "SwitchInputState.shouldRender");
  get shouldRender() {
    return get(this.#shouldRender);
  }
  set shouldRender(value) {
    set(this.#shouldRender, value);
  }
  constructor(root18) {
    this.root = root18;
  }
  #props = tag(
    user_derived(() => ({
      type: "checkbox",
      name: this.root.opts.name.current,
      value: this.root.opts.value.current,
      checked: this.root.opts.checked.current,
      disabled: this.root.opts.disabled.current,
      required: this.root.opts.required.current
    })),
    "SwitchInputState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var SwitchThumbState = class _SwitchThumbState {
  static create(opts) {
    return new _SwitchThumbState(opts, SwitchRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
  }
  #snippetProps = tag(user_derived(() => ({ checked: this.root.opts.checked.current })), "SwitchThumbState.snippetProps");
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
  #props = tag(
    user_derived(() => ({
      ...this.root.sharedProps,
      id: this.opts.id.current,
      [switchAttrs.thumb]: "",
      ...this.attachment
    })),
    "SwitchThumbState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};

// node_modules/bits-ui/dist/bits/switch/components/switch-input.svelte
Switch_input[FILENAME] = "node_modules/bits-ui/dist/bits/switch/components/switch-input.svelte";
function Switch_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Switch_input);
  const inputState = SwitchInputState.create();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => hidden_input_default(node_1, spread_props(() => inputState.props)), "component", Switch_input, 9, 1, { componentTag: "HiddenInput" });
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (inputState.shouldRender) $$render(consequent);
      }),
      "if",
      Switch_input,
      8,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Switch_input = hmr(Switch_input, () => Switch_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Switch_input[HMR].source;
    set(Switch_input[HMR].source, module.default[HMR].original);
  });
}
var switch_input_default = Switch_input;

// node_modules/bits-ui/dist/bits/switch/components/switch.svelte
Switch[FILENAME] = "node_modules/bits-ui/dist/bits/switch/components/switch.svelte";
var root_298 = add_locations(from_html(`<button><!></button>`), Switch[FILENAME], [[51, 1]]);
var root15 = add_locations(from_html(`<!> <!>`, 1), Switch[FILENAME], []);
function Switch($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Switch);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), disabled = prop($$props, "disabled", 3, false), required = prop($$props, "required", 3, false), checked = prop($$props, "checked", 15, false), value = prop($$props, "value", 3, "on"), name = prop($$props, "name", 3, void 0), type = prop($$props, "type", 3, "button"), onCheckedChange = prop($$props, "onCheckedChange", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "ref",
      "id",
      "disabled",
      "required",
      "checked",
      "value",
      "name",
      "type",
      "onCheckedChange"
    ],
    "restProps"
  );
  const rootState = SwitchRootState.create({
    checked: box.with(() => checked(), (v) => {
      checked(v);
      onCheckedChange()?.(v);
    }),
    disabled: box.with(() => disabled() ?? false),
    required: box.with(() => required()),
    value: box.with(() => value()),
    name: box.with(() => name()),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props, { type: type() })), "mergedProps");
  var fragment = root15();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => ({ props: get(mergedProps), ...rootState.snippetProps }));
        add_svelte_meta(() => snippet(node_1, () => $$props.child, () => get($0)), "render", Switch, 49, 1);
      }
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_298();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => rootState.snippetProps), "render", Switch, 52, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Switch,
      48,
      0
    );
  }
  var node_3 = sibling(node, 2);
  add_svelte_meta(() => switch_input_default(node_3, {}), "component", Switch, 56, 0, { componentTag: "SwitchInput" });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Switch = hmr(Switch, () => Switch[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Switch[HMR].source;
    set(Switch[HMR].source, module.default[HMR].original);
  });
}
var switch_default = Switch;

// node_modules/bits-ui/dist/bits/switch/components/switch-thumb.svelte
Switch_thumb[FILENAME] = "node_modules/bits-ui/dist/bits/switch/components/switch-thumb.svelte";
var root_299 = add_locations(from_html(`<span><!></span>`), Switch_thumb[FILENAME], [[31, 1]]);
function Switch_thumb($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Switch_thumb);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "ref",
      "id"
    ],
    "restProps"
  );
  const thumbState = SwitchThumbState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, thumbState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => ({ props: get(mergedProps), ...thumbState.snippetProps }));
        add_svelte_meta(() => snippet(node_1, () => $$props.child, () => get($0)), "render", Switch_thumb, 29, 1);
      }
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_299();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => thumbState.snippetProps), "render", Switch_thumb, 32, 2);
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Switch_thumb,
      28,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Switch_thumb = hmr(Switch_thumb, () => Switch_thumb[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Switch_thumb[HMR].source;
    set(Switch_thumb[HMR].source, module.default[HMR].original);
  });
}
var switch_thumb_default = Switch_thumb;

// node_modules/bits-ui/dist/bits/tabs/exports.js
var exports_exports35 = {};
__export(exports_exports35, {
  Content: () => tabs_content_default,
  List: () => tabs_list_default,
  Root: () => tabs_default,
  Trigger: () => tabs_trigger_default
});

// node_modules/bits-ui/dist/bits/tabs/tabs.svelte.js
var tabsAttrs = createBitsAttrs({
  component: "tabs",
  parts: ["root", "list", "trigger", "content"]
});
var TabsRootContext = new Context("Tabs.Root");
var TabsRootState = class _TabsRootState {
  static create(opts) {
    return TabsRootContext.set(new _TabsRootState(opts));
  }
  opts;
  attachment;
  rovingFocusGroup;
  #triggerIds = tag(state(proxy([])), "TabsRootState.triggerIds");
  get triggerIds() {
    return get(this.#triggerIds);
  }
  set triggerIds(value) {
    set(this.#triggerIds, value, true);
  }
  valueToTriggerId = new SvelteMap();
  valueToContentId = new SvelteMap();
  constructor(opts) {
    this.opts = opts;
    this.attachment = attachRef(opts.ref);
    this.rovingFocusGroup = new RovingFocusGroup({
      candidateAttr: tabsAttrs.trigger,
      rootNode: this.opts.ref,
      loop: this.opts.loop,
      orientation: this.opts.orientation
    });
  }
  registerTrigger(id, value) {
    this.triggerIds.push(id);
    this.valueToTriggerId.set(value, id);
    return () => {
      this.triggerIds = this.triggerIds.filter((triggerId) => strict_equals(triggerId, id, false));
      this.valueToTriggerId.delete(value);
    };
  }
  registerContent(id, value) {
    this.valueToContentId.set(value, id);
    return () => {
      this.valueToContentId.delete(value);
    };
  }
  setValue(v) {
    this.opts.value.current = v;
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "data-orientation": getDataOrientation(this.opts.orientation.current),
      [tabsAttrs.root]: "",
      ...this.attachment
    })),
    "TabsRootState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var TabsListState = class _TabsListState {
  static create(opts) {
    return new _TabsListState(opts, TabsRootContext.get());
  }
  opts;
  root;
  attachment;
  #isDisabled = tag(user_derived(() => this.root.opts.disabled.current), "TabsListState.#isDisabled");
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "tablist",
      "aria-orientation": getAriaOrientation(this.root.opts.orientation.current),
      "data-orientation": getDataOrientation(this.root.opts.orientation.current),
      [tabsAttrs.list]: "",
      "data-disabled": getDataDisabled(get(this.#isDisabled)),
      ...this.attachment
    })),
    "TabsListState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var TabsTriggerState = class _TabsTriggerState {
  static create(opts) {
    return new _TabsTriggerState(opts, TabsRootContext.get());
  }
  opts;
  root;
  attachment;
  #tabIndex = tag(state(0), "TabsTriggerState.#tabIndex");
  #isActive = tag(user_derived(() => strict_equals(this.root.opts.value.current, this.opts.value.current)), "TabsTriggerState.#isActive");
  #isDisabled = tag(user_derived(() => this.opts.disabled.current || this.root.opts.disabled.current), "TabsTriggerState.#isDisabled");
  #ariaControls = tag(user_derived(() => this.root.valueToContentId.get(this.opts.value.current)), "TabsTriggerState.#ariaControls");
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
    watch([() => this.opts.id.current, () => this.opts.value.current], ([id, value]) => {
      return this.root.registerTrigger(id, value);
    });
    user_effect(() => {
      this.root.triggerIds.length;
      if (get(this.#isActive) || !this.root.opts.value.current) {
        set(this.#tabIndex, 0);
      } else {
        set(this.#tabIndex, -1);
      }
    });
    this.onfocus = this.onfocus.bind(this);
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  #activate() {
    if (strict_equals(this.root.opts.value.current, this.opts.value.current)) return;
    this.root.setValue(this.opts.value.current);
  }
  onfocus(_) {
    if (strict_equals(this.root.opts.activationMode.current, "automatic", false) || get(this.#isDisabled)) return;
    this.#activate();
  }
  onclick(_) {
    if (get(this.#isDisabled)) return;
    this.#activate();
  }
  onkeydown(e) {
    if (get(this.#isDisabled)) return;
    if (strict_equals(e.key, kbd_constants_exports.SPACE) || strict_equals(e.key, kbd_constants_exports.ENTER)) {
      e.preventDefault();
      this.#activate();
      return;
    }
    this.root.rovingFocusGroup.handleKeydown(this.opts.ref.current, e);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "tab",
      "data-state": getTabDataState(get(this.#isActive)),
      "data-value": this.opts.value.current,
      "data-orientation": getDataOrientation(this.root.opts.orientation.current),
      "data-disabled": getDataDisabled(get(this.#isDisabled)),
      "aria-selected": getAriaSelected(get(this.#isActive)),
      "aria-controls": get(this.#ariaControls),
      [tabsAttrs.trigger]: "",
      disabled: getDisabled(get(this.#isDisabled)),
      tabindex: get(this.#tabIndex),
      //
      onclick: this.onclick,
      onfocus: this.onfocus,
      onkeydown: this.onkeydown,
      ...this.attachment
    })),
    "TabsTriggerState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var TabsContentState = class _TabsContentState {
  static create(opts) {
    return new _TabsContentState(opts, TabsRootContext.get());
  }
  opts;
  root;
  attachment;
  #isActive = tag(user_derived(() => strict_equals(this.root.opts.value.current, this.opts.value.current)), "TabsContentState.#isActive");
  #ariaLabelledBy = tag(user_derived(() => this.root.valueToTriggerId.get(this.opts.value.current)), "TabsContentState.#ariaLabelledBy");
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
    watch([() => this.opts.id.current, () => this.opts.value.current], ([id, value]) => {
      return this.root.registerContent(id, value);
    });
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "tabpanel",
      hidden: getHidden(!get(this.#isActive)),
      tabindex: 0,
      "data-value": this.opts.value.current,
      "data-state": getTabDataState(get(this.#isActive)),
      "aria-labelledby": get(this.#ariaLabelledBy),
      "data-orientation": getDataOrientation(this.root.opts.orientation.current),
      [tabsAttrs.content]: "",
      ...this.attachment
    })),
    "TabsContentState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
function getTabDataState(condition) {
  return condition ? "active" : "inactive";
}

// node_modules/bits-ui/dist/bits/tabs/components/tabs.svelte
Tabs[FILENAME] = "node_modules/bits-ui/dist/bits/tabs/components/tabs.svelte";
var root_2100 = add_locations(from_html(`<div><!></div>`), Tabs[FILENAME], [[49, 1]]);
function Tabs($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Tabs);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15, ""), onValueChange = prop($$props, "onValueChange", 3, noop3), orientation = prop($$props, "orientation", 3, "horizontal"), loop = prop($$props, "loop", 3, true), activationMode = prop($$props, "activationMode", 3, "automatic"), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "onValueChange",
      "orientation",
      "loop",
      "activationMode",
      "disabled",
      "children",
      "child"
    ],
    "restProps"
  );
  const rootState = TabsRootState.create({
    id: box.with(() => id()),
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    orientation: box.with(() => orientation()),
    loop: box.with(() => loop()),
    activationMode: box.with(() => activationMode()),
    disabled: box.with(() => disabled()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Tabs, 47, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2100();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Tabs, 50, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Tabs,
      46,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tabs = hmr(Tabs, () => Tabs[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tabs[HMR].source;
    set(Tabs[HMR].source, module.default[HMR].original);
  });
}
var tabs_default = Tabs;

// node_modules/bits-ui/dist/bits/tabs/components/tabs-content.svelte
Tabs_content[FILENAME] = "node_modules/bits-ui/dist/bits/tabs/components/tabs-content.svelte";
var root_2101 = add_locations(from_html(`<div><!></div>`), Tabs_content[FILENAME], [[33, 1]]);
function Tabs_content($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Tabs_content);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "value"
    ],
    "restProps"
  );
  const contentState = TabsContentState.create({
    value: box.with(() => $$props.value),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Tabs_content, 31, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2101();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Tabs_content, 34, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Tabs_content,
      30,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tabs_content = hmr(Tabs_content, () => Tabs_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tabs_content[HMR].source;
    set(Tabs_content[HMR].source, module.default[HMR].original);
  });
}
var tabs_content_default = Tabs_content;

// node_modules/bits-ui/dist/bits/tabs/components/tabs-list.svelte
Tabs_list[FILENAME] = "node_modules/bits-ui/dist/bits/tabs/components/tabs-list.svelte";
var root_2102 = add_locations(from_html(`<div><!></div>`), Tabs_list[FILENAME], [[31, 1]]);
function Tabs_list($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Tabs_list);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "id",
      "ref"
    ],
    "restProps"
  );
  const listState = TabsListState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, listState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Tabs_list, 29, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2102();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Tabs_list, 32, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Tabs_list,
      28,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tabs_list = hmr(Tabs_list, () => Tabs_list[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tabs_list[HMR].source;
    set(Tabs_list[HMR].source, module.default[HMR].original);
  });
}
var tabs_list_default = Tabs_list;

// node_modules/bits-ui/dist/bits/tabs/components/tabs-trigger.svelte
Tabs_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/tabs/components/tabs-trigger.svelte";
var root_2103 = add_locations(from_html(`<button><!></button>`), Tabs_trigger[FILENAME], [[36, 1]]);
function Tabs_trigger($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Tabs_trigger);
  let disabled = prop($$props, "disabled", 3, false), id = prop($$props, "id", 19, () => createId(uid)), type = prop($$props, "type", 3, "button"), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "disabled",
      "id",
      "type",
      "value",
      "ref"
    ],
    "restProps"
  );
  const triggerState = TabsTriggerState.create({
    id: box.with(() => id()),
    disabled: box.with(() => disabled() ?? false),
    value: box.with(() => $$props.value),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, triggerState.props, { type: type() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Tabs_trigger, 34, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2103();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Tabs_trigger, 37, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Tabs_trigger,
      33,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tabs_trigger = hmr(Tabs_trigger, () => Tabs_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tabs_trigger[HMR].source;
    set(Tabs_trigger[HMR].source, module.default[HMR].original);
  });
}
var tabs_trigger_default = Tabs_trigger;

// node_modules/bits-ui/dist/bits/time-field/exports.js
var exports_exports36 = {};
__export(exports_exports36, {
  Input: () => time_field_input_default,
  Label: () => time_field_label_default,
  Root: () => time_field_default,
  Segment: () => time_field_segment_default
});

// node_modules/bits-ui/dist/bits/time-field/time-field.svelte.js
var timeFieldAttrs = createBitsAttrs({ component: "time-field", parts: ["input", "label"] });
var TimeFieldRootContext = new Context("TimeField.Root");
var SEGMENT_CONFIGS2 = {
  hour: {
    min: (root18) => strict_equals(root18.hourCycle, 12) ? 1 : 0,
    max: (root18) => {
      if (strict_equals(root18.hourCycle, 24)) return 23;
      if ("dayPeriod" in root18.segmentValues && strict_equals(root18.segmentValues.dayPeriod, null, false)) return 12;
      return 23;
    },
    cycle: 1,
    canBeZero: true,
    padZero: true
  },
  minute: { min: 0, max: 59, cycle: 1, canBeZero: true, padZero: true },
  second: { min: 0, max: 59, cycle: 1, canBeZero: true, padZero: true }
};
var TimeFieldRootState = class _TimeFieldRootState {
  static create(opts, rangeRoot) {
    return TimeFieldRootContext.set(new _TimeFieldRootState(opts, rangeRoot));
  }
  value;
  placeholder;
  validate;
  minValue;
  maxValue;
  disabled;
  readonly;
  granularity;
  readonlySegments;
  hourCycleProp;
  locale;
  hideTimeZone;
  required;
  onInvalid;
  errorMessageId;
  isInvalidProp;
  descriptionId = useId();
  formatter;
  initialSegments;
  #segmentValues = tag(state(), "TimeFieldRootState.segmentValues");
  get segmentValues() {
    return get(this.#segmentValues);
  }
  set segmentValues(value) {
    set(this.#segmentValues, value, true);
  }
  announcer;
  #readonlySegmentsSet = tag(user_derived(() => new Set(this.readonlySegments.current)), "TimeFieldRootState.readonlySegmentsSet");
  get readonlySegmentsSet() {
    return get(this.#readonlySegmentsSet);
  }
  set readonlySegmentsSet(value) {
    set(this.#readonlySegmentsSet, value);
  }
  segmentStates = initTimeSegmentStates();
  #fieldNode = tag(state(null), "TimeFieldRootState.#fieldNode");
  #labelNode = tag(state(null), "TimeFieldRootState.#labelNode");
  #descriptionNode = tag(state(null), "TimeFieldRootState.descriptionNode");
  get descriptionNode() {
    return get(this.#descriptionNode);
  }
  set descriptionNode(value) {
    set(this.#descriptionNode, value, true);
  }
  #validationNode = tag(state(null), "TimeFieldRootState.validationNode");
  get validationNode() {
    return get(this.#validationNode);
  }
  set validationNode(value) {
    set(this.#validationNode, value, true);
  }
  states = initTimeSegmentStates();
  #dayPeriodNode = tag(state(null), "TimeFieldRootState.dayPeriodNode");
  get dayPeriodNode() {
    return get(this.#dayPeriodNode);
  }
  set dayPeriodNode(value) {
    set(this.#dayPeriodNode, value, true);
  }
  #name = tag(state(""), "TimeFieldRootState.name");
  get name() {
    return get(this.#name);
  }
  set name(value) {
    set(this.#name, value, true);
  }
  #maxValueTime = tag(
    user_derived(() => {
      if (!this.maxValue.current) return void 0;
      return convertTimeValueToTime(this.maxValue.current);
    }),
    "TimeFieldRootState.maxValueTime"
  );
  get maxValueTime() {
    return get(this.#maxValueTime);
  }
  set maxValueTime(value) {
    set(this.#maxValueTime, value);
  }
  #minValueTime = tag(
    user_derived(() => {
      if (!this.minValue.current) return void 0;
      return convertTimeValueToTime(this.minValue.current);
    }),
    "TimeFieldRootState.minValueTime"
  );
  get minValueTime() {
    return get(this.#minValueTime);
  }
  set minValueTime(value) {
    set(this.#minValueTime, value);
  }
  #valueTime = tag(
    user_derived(() => {
      if (!this.value.current) return void 0;
      return convertTimeValueToTime(this.value.current);
    }),
    "TimeFieldRootState.valueTime"
  );
  get valueTime() {
    return get(this.#valueTime);
  }
  set valueTime(value) {
    set(this.#valueTime, value);
  }
  #hourCycle = tag(
    user_derived(() => {
      if (this.hourCycleProp.current) return this.hourCycleProp.current;
      return getDefaultHourCycle(this.locale.current);
    }),
    "TimeFieldRootState.hourCycle"
  );
  get hourCycle() {
    return get(this.#hourCycle);
  }
  set hourCycle(value) {
    set(this.#hourCycle, value);
  }
  rangeRoot = void 0;
  domContext = new DOMContext(() => null);
  constructor(props, rangeRoot) {
    this.rangeRoot = rangeRoot;
    this.value = props.value;
    this.placeholder = rangeRoot ? rangeRoot.opts.placeholder : props.placeholder;
    this.validate = rangeRoot ? box(void 0) : props.validate;
    this.minValue = rangeRoot ? rangeRoot.opts.minValue : props.minValue;
    this.maxValue = rangeRoot ? rangeRoot.opts.maxValue : props.maxValue;
    this.disabled = rangeRoot ? rangeRoot.opts.disabled : props.disabled;
    this.readonly = rangeRoot ? rangeRoot.opts.readonly : props.readonly;
    this.granularity = rangeRoot ? rangeRoot.opts.granularity : props.granularity;
    this.readonlySegments = rangeRoot ? rangeRoot.opts.readonlySegments : props.readonlySegments;
    this.hourCycleProp = rangeRoot ? rangeRoot.opts.hourCycle : props.hourCycle;
    this.locale = rangeRoot ? rangeRoot.opts.locale : props.locale;
    this.hideTimeZone = rangeRoot ? rangeRoot.opts.hideTimeZone : props.hideTimeZone;
    this.required = rangeRoot ? rangeRoot.opts.required : props.required;
    this.onInvalid = rangeRoot ? rangeRoot.opts.onInvalid : props.onInvalid;
    this.errorMessageId = rangeRoot ? rangeRoot.opts.errorMessageId : props.errorMessageId;
    this.isInvalidProp = props.isInvalidProp;
    this.formatter = createTimeFormatter(this.locale.current);
    this.initialSegments = this.#initializeTimeSegmentValues();
    this.segmentValues = this.initialSegments;
    this.announcer = getAnnouncer(null);
    this.getFieldNode = this.getFieldNode.bind(this);
    this.updateSegment = this.updateSegment.bind(this);
    this.handleSegmentClick = this.handleSegmentClick.bind(this);
    this.getBaseSegmentAttrs = this.getBaseSegmentAttrs.bind(this);
    user_effect(() => {
      untrack(() => {
        this.initialSegments = this.#initializeTimeSegmentValues();
      });
    });
    onMount(() => {
      this.announcer = getAnnouncer(this.domContext.getDocument());
    });
    onDestroyEffect(() => {
      removeTimeDescriptionElement(this.descriptionId, this.domContext.getDocument());
    });
    user_effect(() => {
      if (strict_equals(this.formatter.getLocale(), this.locale.current)) return;
      this.formatter.setLocale(this.locale.current);
    });
    user_effect(() => {
      if (this.value.current) {
        const descriptionId = untrack(() => this.descriptionId);
        setTimeDescription({
          id: descriptionId,
          formatter: this.formatter,
          value: this.#toDateValue(this.value.current),
          doc: this.domContext.getDocument()
        });
      }
      const placeholder = untrack(() => this.placeholder.current);
      if (this.value.current && strict_equals(placeholder, this.value.current, false)) {
        untrack(() => {
          if (this.value.current) {
            this.placeholder.current = this.value.current;
          }
        });
      }
    });
    if (this.value.current) {
      this.syncSegmentValues(this.value.current);
    }
    user_effect(() => {
      this.locale.current;
      if (this.value.current) {
        this.syncSegmentValues(this.value.current);
      }
      this.#clearUpdating();
    });
    user_effect(() => {
      if (strict_equals(this.value.current, void 0)) {
        this.segmentValues = this.#initializeTimeSegmentValues();
      }
    });
    watch(() => this.validationStatus, () => {
      if (strict_equals(this.validationStatus, false, false)) {
        this.onInvalid.current?.(this.validationStatus.reason, this.validationStatus.message);
      }
    });
  }
  #initializeTimeSegmentValues() {
    const granularity = this.inferredGranularity;
    const segments = { hour: null, minute: null, second: null, dayPeriod: "AM" };
    if (strict_equals(granularity, "second")) {
      segments.second = null;
    }
    if (strict_equals(this.hourCycle, 24)) {
      segments.dayPeriod = null;
    }
    return segments;
  }
  #toDateValue(timeValue) {
    if ("calendar" in timeValue) {
      return timeValue;
    } else {
      return new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(2e3, 1, 1, timeValue.hour, timeValue.minute, timeValue.second, timeValue.millisecond);
    }
  }
  #clearUpdating() {
    this.states.hour.updating = null;
    this.states.minute.updating = null;
    this.states.second.updating = null;
    this.states.dayPeriod.updating = null;
  }
  setName(name) {
    this.name = name;
  }
  setFieldNode(node) {
    set(this.#fieldNode, node, true);
  }
  /**
   * Gets the correct field node for the time field regardless of whether it's being
   * used in a standalone context or within a `TimeRangeField` component.
   */
  getFieldNode() {
    if (!this.rangeRoot) {
      return get(this.#fieldNode);
    } else {
      return this.rangeRoot.fieldNode;
    }
  }
  setLabelNode(node) {
    set(this.#labelNode, node, true);
  }
  getLabelNode() {
    return get(this.#labelNode);
  }
  setValue(value) {
    this.value.current = value;
  }
  syncSegmentValues(value) {
    const timeValues = EDITABLE_TIME_SEGMENT_PARTS.map((part) => {
      if (strict_equals(part, "dayPeriod")) {
        if (this.states.dayPeriod.updating) {
          return [part, this.states.dayPeriod.updating];
        } else {
          return [
            part,
            this.formatter.dayPeriod(toDate(this.#toDateValue(value)))
          ];
        }
      } else if (strict_equals(part, "hour")) {
        if (this.states.hour.updating) {
          return [part, this.states.hour.updating];
        }
        if (strict_equals(value[part], void 0, false) && value[part] < 10) {
          return [part, `0${value[part]}`];
        }
        if (strict_equals(value[part], 0) && this.dayPeriodNode) {
          return [part, "12"];
        }
      } else if (strict_equals(part, "minute")) {
        if (this.states.minute.updating) {
          return [part, this.states.minute.updating];
        }
        if (strict_equals(value[part], void 0, false) && value[part] < 10) {
          return [part, `0${value[part]}`];
        }
      } else if (strict_equals(part, "second")) {
        if (this.states.second.updating) {
          return [part, this.states.second.updating];
        }
        if (strict_equals(value[part], void 0, false) && value[part] < 10) {
          return [part, `0${value[part]}`];
        }
      }
      return [part, `${value[part]}`];
    });
    this.segmentValues = Object.fromEntries(timeValues);
    this.#clearUpdating();
  }
  #validationStatus = tag(
    user_derived(() => {
      const value = this.value.current;
      if (!value) return false;
      const msg = this.validate.current?.(value);
      if (msg) {
        return { reason: "custom", message: msg };
      }
      if (!this.valueTime) return false;
      if (this.minValueTime && isTimeBefore(this.valueTime, this.minValueTime)) {
        return { reason: "min" };
      }
      if (this.maxValueTime && isTimeBefore(this.maxValueTime, this.valueTime)) {
        return { reason: "max" };
      }
      return false;
    }),
    "TimeFieldRootState.validationStatus"
  );
  get validationStatus() {
    return get(this.#validationStatus);
  }
  set validationStatus(value) {
    set(this.#validationStatus, value);
  }
  #isInvalid = tag(
    user_derived(() => {
      if (strict_equals(this.validationStatus, false)) return false;
      if (this.isInvalidProp.current) return true;
      return true;
    }),
    "TimeFieldRootState.isInvalid"
  );
  get isInvalid() {
    return get(this.#isInvalid);
  }
  set isInvalid(value) {
    set(this.#isInvalid, value);
  }
  #inferredGranularity = tag(
    user_derived(() => {
      return this.granularity.current ?? "minute";
    }),
    "TimeFieldRootState.inferredGranularity"
  );
  get inferredGranularity() {
    return get(this.#inferredGranularity);
  }
  set inferredGranularity(value) {
    set(this.#inferredGranularity, value);
  }
  #timeRef = tag(user_derived(() => this.value.current ?? this.placeholder.current), "TimeFieldRootState.timeRef");
  get timeRef() {
    return get(this.#timeRef);
  }
  set timeRef(value) {
    set(this.#timeRef, value);
  }
  #allSegmentContent = tag(
    user_derived(() => createTimeContent({
      segmentValues: this.segmentValues,
      formatter: this.formatter,
      locale: this.locale.current,
      granularity: this.inferredGranularity,
      timeRef: this.timeRef,
      hideTimeZone: this.hideTimeZone.current,
      hourCycle: this.hourCycle
    })),
    "TimeFieldRootState.allSegmentContent"
  );
  get allSegmentContent() {
    return get(this.#allSegmentContent);
  }
  set allSegmentContent(value) {
    set(this.#allSegmentContent, value);
  }
  #segmentContents = tag(user_derived(() => this.allSegmentContent.arr), "TimeFieldRootState.segmentContents");
  get segmentContents() {
    return get(this.#segmentContents);
  }
  set segmentContents(value) {
    set(this.#segmentContents, value);
  }
  sharedSegmentAttrs = {
    role: "spinbutton",
    contenteditable: "true",
    tabindex: 0,
    spellcheck: false,
    inputmode: "numeric",
    autocorrect: "off",
    enterkeyhint: "next",
    style: { caretColor: "transparent" }
  };
  #getLabelledBy(segmentId) {
    return `${segmentId} ${this.getLabelNode()?.id ?? ""}`;
  }
  updateSegment(part, cb) {
    const disabled = this.disabled.current;
    const readonly = this.readonly.current;
    const readonlySegmentsSet = this.readonlySegmentsSet;
    if (disabled || readonly || readonlySegmentsSet.has(part)) return;
    const prev2 = this.segmentValues;
    let newSegmentValues = prev2;
    if (strict_equals(part, "dayPeriod")) {
      const next3 = cb(prev2[part]);
      this.states.dayPeriod.updating = next3;
      const value = this.value.current;
      if (value && "hour" in value) {
        const trueHour = value.hour;
        if (strict_equals(next3, "AM")) {
          if (trueHour >= 12) {
            prev2.hour = `${trueHour - 12}`;
          }
        } else if (strict_equals(next3, "PM")) {
          if (trueHour < 12) {
            prev2.hour = `${trueHour + 12}`;
          }
        }
      }
      newSegmentValues = { ...prev2, [part]: next3 };
    } else if (strict_equals(part, "hour")) {
      const next3 = cb(prev2[part]);
      this.states.hour.updating = next3;
      if (strict_equals(next3, null, false) && strict_equals(prev2.dayPeriod, null, false)) {
        const dayPeriod = this.formatter.dayPeriod(toDate(this.#toDateValue(this.timeRef.set({ hour: Number.parseInt(next3) }))), this.hourCycle);
        if (strict_equals(dayPeriod, "AM") || strict_equals(dayPeriod, "PM")) {
          prev2.dayPeriod = dayPeriod;
        }
      }
      newSegmentValues = { ...prev2, [part]: next3 };
    } else if (strict_equals(part, "minute")) {
      const next3 = cb(prev2[part]);
      this.states.minute.updating = next3;
      newSegmentValues = { ...prev2, [part]: next3 };
    } else if (strict_equals(part, "second")) {
      const next3 = cb(prev2[part]);
      this.states.second.updating = next3;
      newSegmentValues = { ...prev2, [part]: next3 };
    }
    this.segmentValues = newSegmentValues;
    if (areAllTimeSegmentsFilled(newSegmentValues, get(this.#fieldNode))) {
      this.setValue(getTimeValueFromSegments({
        segmentObj: newSegmentValues,
        fieldNode: get(this.#fieldNode),
        timeRef: this.timeRef
      }));
    } else {
    }
  }
  handleSegmentClick(e) {
    if (this.disabled.current) {
      e.preventDefault();
    }
  }
  getBaseSegmentAttrs(part, segmentId) {
    const inReadonlySegments = this.readonlySegmentsSet.has(part);
    const defaultAttrs = {
      "aria-invalid": getAriaInvalid(this.isInvalid),
      "aria-disabled": getAriaDisabled(this.disabled.current),
      "aria-readonly": getAriaReadonly(this.readonly.current || inReadonlySegments),
      "data-invalid": getDataInvalid(this.isInvalid),
      "data-disabled": getDataDisabled(this.disabled.current),
      "data-readonly": getDataReadonly(this.readonly.current || inReadonlySegments),
      "data-segment": `${part}`
    };
    if (strict_equals(part, "literal")) return defaultAttrs;
    const descriptionId = this.descriptionNode?.id;
    const hasDescription = isFirstTimeSegment(segmentId, get(this.#fieldNode)) && descriptionId;
    const errorMsgId = this.errorMessageId?.current;
    const describedBy = hasDescription ? `${descriptionId} ${this.isInvalid && errorMsgId ? errorMsgId : ""}` : void 0;
    const contenteditable = !(this.readonly.current || inReadonlySegments || this.disabled.current);
    return {
      ...defaultAttrs,
      "aria-labelledby": this.#getLabelledBy(segmentId),
      contenteditable: contenteditable ? "true" : void 0,
      "aria-describedby": describedBy,
      tabindex: this.disabled.current ? void 0 : 0
    };
  }
};
var TimeFieldInputState = class _TimeFieldInputState {
  static create(opts) {
    return new _TimeFieldInputState(opts, TimeFieldRootContext.get());
  }
  opts;
  root;
  attachment;
  domContext;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref, (v) => this.root.setFieldNode(v));
    this.domContext = new DOMContext(opts.ref);
    this.root.setName(this.opts.name.current);
    user_effect(() => {
      this.root.setName(this.opts.name.current);
    });
  }
  #ariaDescribedBy = tag(
    user_derived(() => {
      if (!isBrowser) return void 0;
      const doesDescriptionExist = this.domContext.getElementById(this.root.descriptionId);
      if (!doesDescriptionExist) return void 0;
      return this.root.descriptionId;
    }),
    "TimeFieldInputState.#ariaDescribedBy"
  );
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "group",
      "aria-labelledby": this.root.getLabelNode()?.id ?? void 0,
      "aria-describedby": get(this.#ariaDescribedBy),
      "aria-disabled": getAriaDisabled(this.root.disabled.current),
      "data-invalid": this.root.isInvalid ? "" : void 0,
      "data-disabled": getDataDisabled(this.root.disabled.current),
      [timeFieldAttrs.input]: "",
      ...this.attachment
    })),
    "TimeFieldInputState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var TimeFieldHiddenInputState = class _TimeFieldHiddenInputState {
  static create() {
    return new _TimeFieldHiddenInputState(TimeFieldRootContext.get());
  }
  root;
  #shouldRender = tag(user_derived(() => strict_equals(this.root.name, "", false)), "TimeFieldHiddenInputState.shouldRender");
  get shouldRender() {
    return get(this.#shouldRender);
  }
  set shouldRender(value) {
    set(this.#shouldRender, value);
  }
  #isoValue = tag(user_derived(() => this.root.value.current ? getISOTimeValue(this.root.value.current) : void 0), "TimeFieldHiddenInputState.isoValue");
  get isoValue() {
    return get(this.#isoValue);
  }
  set isoValue(value) {
    set(this.#isoValue, value);
  }
  constructor(root18) {
    this.root = root18;
  }
  #props = tag(
    user_derived(() => ({
      name: this.root.name,
      value: this.isoValue,
      required: this.root.required.current
    })),
    "TimeFieldHiddenInputState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var TimeFieldLabelState = class _TimeFieldLabelState {
  static create(opts) {
    return new _TimeFieldLabelState(opts, TimeFieldRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref, (v) => this.root.setLabelNode(v));
    this.onclick = this.onclick.bind(this);
  }
  onclick(_) {
    if (this.root.disabled.current) return;
    const firstSegment = getFirstTimeSegment(this.root.getFieldNode());
    if (!firstSegment) return;
    firstSegment.focus();
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "data-invalid": getDataInvalid(this.root.isInvalid),
      "data-disabled": getDataDisabled(this.root.disabled.current),
      [timeFieldAttrs.label]: "",
      onclick: this.onclick,
      ...this.attachment
    })),
    "TimeFieldLabelState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var BaseTimeSegmentState = class {
  opts;
  root;
  announcer;
  part;
  config;
  attachment;
  constructor(opts, root18, part, config) {
    this.opts = opts;
    this.root = root18;
    this.part = part;
    this.config = config;
    this.announcer = root18.announcer;
    this.attachment = attachRef(opts.ref);
    this.onkeydown = this.onkeydown.bind(this);
    this.onfocusout = this.onfocusout.bind(this);
  }
  #getMax() {
    return strict_equals(typeof this.config.max, "function") ? this.config.max(this.root) : this.config.max;
  }
  #getMin() {
    return strict_equals(typeof this.config.min, "function") ? this.config.min(this.root) : this.config.min;
  }
  #formatValue(value, forDisplay = true) {
    const str = String(value);
    if (forDisplay && this.config.padZero && strict_equals(str.length, 1)) {
      return `0${value}`;
    }
    return str;
  }
  onkeydown(e) {
    const placeholder = this.root.value.current ?? this.root.placeholder.current;
    if (e.ctrlKey || e.metaKey || this.root.disabled.current) return;
    if (strict_equals(e.key, kbd_constants_exports.TAB, false)) e.preventDefault();
    if (!isAcceptableSegmentKey(e.key)) return;
    if (isArrowUp2(e.key)) {
      this.#handleArrowUp(placeholder);
      return;
    }
    if (isArrowDown2(e.key)) {
      this.#handleArrowDown(placeholder);
      return;
    }
    if (isNumberString(e.key)) {
      this.#handleNumberKey(e);
      return;
    }
    if (isBackspace2(e.key)) {
      this.#handleBackspace(e);
      return;
    }
    if (isSegmentNavigationKey(e.key)) {
      handleTimeSegmentNavigation(e, this.root.getFieldNode());
    }
  }
  #handleArrowUp(placeholder) {
    const stateKey = this.part;
    if (stateKey in this.root.states) {
      this.root.states[stateKey].hasLeftFocus = false;
    }
    this.root.updateSegment(this.part, (prev2) => {
      if (strict_equals(prev2, null)) {
        const next4 = placeholder[this.part];
        this.announcer.announce(String(next4));
        return this.#formatValue(next4);
      }
      const current = placeholder.set({ [this.part]: Number.parseInt(prev2) });
      const next3 = current.cycle(this.part, this.config.cycle)[this.part];
      this.announcer.announce(String(next3));
      return this.#formatValue(next3);
    });
  }
  #handleArrowDown(placeholder) {
    const stateKey = this.part;
    if (stateKey in this.root.states) {
      this.root.states[stateKey].hasLeftFocus = false;
    }
    this.root.updateSegment(this.part, (prev2) => {
      if (strict_equals(prev2, null)) {
        const next4 = placeholder[this.part];
        this.announcer.announce(String(next4));
        return this.#formatValue(next4);
      }
      const current = placeholder.set({ [this.part]: Number.parseInt(prev2) });
      const next3 = current.cycle(this.part, -this.config.cycle)[this.part];
      this.announcer.announce(String(next3));
      return this.#formatValue(next3);
    });
  }
  #handleNumberKey(e) {
    const num = Number.parseInt(e.key);
    let moveToNext = false;
    const max = this.#getMax();
    const maxStart = Math.floor(max / 10);
    const numIsZero = strict_equals(num, 0);
    const stateKey = this.part;
    this.root.updateSegment(this.part, (prev2) => {
      if (stateKey in this.root.states && this.root.states[stateKey].hasLeftFocus) {
        prev2 = null;
        this.root.states[stateKey].hasLeftFocus = false;
      }
      if (strict_equals(prev2, null)) {
        if (numIsZero) {
          if (stateKey in this.root.states) {
            this.root.states[stateKey].lastKeyZero = true;
          }
          this.announcer.announce("0");
          return "0";
        }
        if (stateKey in this.root.states && (this.root.states[stateKey].lastKeyZero || num > maxStart)) {
          moveToNext = true;
        }
        if (stateKey in this.root.states) {
          this.root.states[stateKey].lastKeyZero = false;
        }
        if (moveToNext && strict_equals(String(num).length, 1)) {
          this.announcer.announce(num);
          return `0${num}`;
        }
        return `${num}`;
      }
      if (stateKey in this.root.states && this.root.states[stateKey].lastKeyZero) {
        if (strict_equals(num, 0, false)) {
          moveToNext = true;
          this.root.states[stateKey].lastKeyZero = false;
          return `0${num}`;
        }
        if (strict_equals(this.part, "hour") && strict_equals(num, 0) && strict_equals(this.root.hourCycle, 24)) {
          moveToNext = true;
          this.root.states[stateKey].lastKeyZero = false;
          return `00`;
        }
        if ((strict_equals(this.part, "minute") || strict_equals(this.part, "second")) && strict_equals(num, 0)) {
          moveToNext = true;
          this.root.states[stateKey].lastKeyZero = false;
          return "00";
        }
        return prev2;
      }
      const total = Number.parseInt(prev2 + num.toString());
      if (total > max) {
        moveToNext = true;
        return `0${num}`;
      }
      moveToNext = true;
      return `${total}`;
    });
    if (moveToNext) {
      moveToNextTimeSegment(e, this.root.getFieldNode());
    }
  }
  #handleBackspace(e) {
    const stateKey = this.part;
    if (stateKey in this.root.states) {
      this.root.states[stateKey].hasLeftFocus = false;
    }
    let moveToPrev = false;
    this.root.updateSegment(this.part, (prev2) => {
      if (strict_equals(prev2, null)) {
        moveToPrev = true;
        this.announcer.announce(null);
        return null;
      }
      if (strict_equals(prev2.length, 2) && prev2.startsWith("0")) {
        this.announcer.announce(null);
        return null;
      }
      const str = prev2.toString();
      if (strict_equals(str.length, 1)) {
        this.announcer.announce(null);
        return null;
      }
      const next3 = Number.parseInt(str.slice(0, -1));
      this.announcer.announce(String(next3));
      return `${next3}`;
    });
    if (moveToPrev) {
      moveToPrevTimeSegment(e, this.root.getFieldNode());
    }
  }
  onfocusout(_) {
    const stateKey = this.part;
    if (stateKey in this.root.states) {
      this.root.states[stateKey].hasLeftFocus = true;
    }
    if (this.config.padZero) {
      this.root.updateSegment(this.part, (prev2) => {
        if (prev2 && strict_equals(prev2.length, 1)) {
          return `0${prev2}`;
        }
        return prev2;
      });
    }
  }
  getSegmentProps() {
    const segmentValues = this.root.segmentValues;
    const placeholder = this.root.placeholder.current;
    const isEmpty = strict_equals(segmentValues[this.part], null);
    let value = placeholder;
    if (segmentValues[this.part]) {
      value = placeholder.set({ [this.part]: Number.parseInt(segmentValues[this.part]) });
    }
    const valueNow = value[this.part];
    const valueMin = this.#getMin();
    const valueMax = this.#getMax();
    let valueText = isEmpty ? "Empty" : `${valueNow}`;
    if (strict_equals(this.part, "hour") && "dayPeriod" in segmentValues && segmentValues.dayPeriod) {
      valueText = isEmpty ? "Empty" : `${valueNow} ${segmentValues.dayPeriod}`;
    }
    return {
      "aria-label": `${this.part}, `,
      "aria-valuemin": valueMin,
      "aria-valuemax": valueMax,
      "aria-valuenow": valueNow,
      "aria-valuetext": valueText
    };
  }
  #props = tag(
    user_derived(() => {
      return {
        ...this.root.sharedSegmentAttrs,
        id: this.opts.id.current,
        ...this.getSegmentProps(),
        onkeydown: this.onkeydown,
        onfocusout: this.onfocusout,
        onclick: this.root.handleSegmentClick,
        ...this.root.getBaseSegmentAttrs(this.part, this.opts.id.current),
        ...this.attachment
      };
    }),
    "BaseTimeSegmentState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var TimeFieldHourSegmentState = class extends BaseTimeSegmentState {
  constructor(opts, root18) {
    super(opts, root18, "hour", SEGMENT_CONFIGS2.hour);
  }
  onkeydown(e) {
    if (isNumberString(e.key)) {
      const oldUpdateSegment = this.root.updateSegment.bind(this.root);
      this.root.updateSegment = (part, cb) => {
        const result = oldUpdateSegment(part, cb);
        if (strict_equals(part, "hour") && "hour" in this.root.segmentValues) {
          const hourValue = this.root.segmentValues.hour;
          if (strict_equals(hourValue, "0") && this.root.dayPeriodNode && strict_equals(this.root.hourCycle, 24, false)) {
            this.root.segmentValues.hour = "12";
          }
        }
        return result;
      };
    }
    super.onkeydown(e);
    this.root.updateSegment = this.root.updateSegment.bind(this.root);
  }
};
var TimeFieldMinuteSegmentState = class extends BaseTimeSegmentState {
  constructor(opts, root18) {
    super(opts, root18, "minute", SEGMENT_CONFIGS2.minute);
  }
};
var TimeFieldSecondSegmentState = class extends BaseTimeSegmentState {
  constructor(opts, root18) {
    super(opts, root18, "second", SEGMENT_CONFIGS2.second);
  }
};
var TimeFieldDayPeriodSegmentState = class {
  opts;
  root;
  attachment;
  #announcer;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.#announcer = this.root.announcer;
    this.attachment = attachRef(opts.ref, (v) => this.root.dayPeriodNode = v);
    this.onkeydown = this.onkeydown.bind(this);
  }
  onkeydown(e) {
    if (e.ctrlKey || e.metaKey || this.root.disabled.current) return;
    if (strict_equals(e.key, kbd_constants_exports.TAB, false)) e.preventDefault();
    if (!isAcceptableDayPeriodKey2(e.key)) return;
    if (isArrowUp2(e.key) || isArrowDown2(e.key)) {
      this.root.updateSegment("dayPeriod", (prev2) => {
        if (strict_equals(prev2, "AM")) {
          const next4 = "PM";
          this.#announcer.announce(next4);
          return next4;
        }
        const next3 = "AM";
        this.#announcer.announce(next3);
        return next3;
      });
      return;
    }
    if (isBackspace2(e.key)) {
      this.root.states.dayPeriod.hasLeftFocus = false;
      this.root.updateSegment("dayPeriod", () => {
        const next3 = "AM";
        this.#announcer.announce(next3);
        return next3;
      });
    }
    if (strict_equals(e.key, kbd_constants_exports.A) || strict_equals(e.key, kbd_constants_exports.P) || strict_equals(e.key, kbd_constants_exports.a) || strict_equals(e.key, kbd_constants_exports.p)) {
      this.root.updateSegment("dayPeriod", () => {
        const next3 = strict_equals(e.key, kbd_constants_exports.A) || strict_equals(e.key, kbd_constants_exports.a) ? "AM" : "PM";
        this.#announcer.announce(next3);
        return next3;
      });
    }
    if (isSegmentNavigationKey(e.key)) {
      handleTimeSegmentNavigation(e, this.root.getFieldNode());
    }
  }
  #props = tag(
    user_derived(() => {
      const segmentValues = this.root.segmentValues;
      if (!("dayPeriod" in segmentValues)) return;
      const valueMin = 0;
      const valueMax = 12;
      const valueNow = strict_equals(segmentValues.dayPeriod, "AM") ? 0 : 12;
      const valueText = strict_equals(segmentValues.dayPeriod, "AM") ? "AM" : "PM";
      return {
        ...this.root.sharedSegmentAttrs,
        id: this.opts.id.current,
        inputmode: "text",
        "aria-label": "AM/PM",
        "aria-valuemin": valueMin,
        "aria-valuemax": valueMax,
        "aria-valuenow": valueNow,
        "aria-valuetext": valueText,
        onkeydown: this.onkeydown,
        onclick: this.root.handleSegmentClick,
        ...this.root.getBaseSegmentAttrs("dayPeriod", this.opts.id.current),
        ...this.attachment
      };
    }),
    "TimeFieldDayPeriodSegmentState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var TimeFieldLiteralSegmentState = class {
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "aria-hidden": getAriaHidden(true),
      ...this.root.getBaseSegmentAttrs("literal", this.opts.id.current),
      ...this.attachment
    })),
    "TimeFieldLiteralSegmentState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var TimeFieldTimeZoneSegmentState = class {
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(opts.ref);
    this.onkeydown = this.onkeydown.bind(this);
  }
  onkeydown(e) {
    if (strict_equals(e.key, kbd_constants_exports.TAB, false)) e.preventDefault();
    if (this.root.disabled.current) return;
    if (isSegmentNavigationKey(e.key)) {
      handleTimeSegmentNavigation(e, this.root.getFieldNode());
    }
  }
  #props = tag(
    user_derived(() => ({
      role: "textbox",
      id: this.opts.id.current,
      "aria-label": "timezone, ",
      style: { caretColor: "transparent" },
      onkeydown: this.onkeydown,
      tabindex: 0,
      ...this.root.getBaseSegmentAttrs("timeZoneName", this.opts.id.current),
      "data-readonly": getDataReadonly(true),
      ...this.attachment
    })),
    "TimeFieldTimeZoneSegmentState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var DateFieldSegmentState2 = class {
  static create(part, opts) {
    const root18 = TimeFieldRootContext.get();
    switch (part) {
      case "hour":
        return new TimeFieldHourSegmentState(opts, root18);
      case "minute":
        return new TimeFieldMinuteSegmentState(opts, root18);
      case "second":
        return new TimeFieldSecondSegmentState(opts, root18);
      case "dayPeriod":
        return new TimeFieldDayPeriodSegmentState(opts, root18);
      case "literal":
        return new TimeFieldLiteralSegmentState(opts, root18);
      case "timeZoneName":
        return new TimeFieldTimeZoneSegmentState(opts, root18);
      default:
        throw new Error(`Invalid part: ${part}`);
    }
  }
};
function isAcceptableDayPeriodKey2(key2) {
  return isAcceptableSegmentKey(key2) || strict_equals(key2, kbd_constants_exports.A) || strict_equals(key2, kbd_constants_exports.P) || strict_equals(key2, kbd_constants_exports.a) || strict_equals(key2, kbd_constants_exports.p);
}
function isArrowUp2(key2) {
  return strict_equals(key2, kbd_constants_exports.ARROW_UP);
}
function isArrowDown2(key2) {
  return strict_equals(key2, kbd_constants_exports.ARROW_DOWN);
}
function isBackspace2(key2) {
  return strict_equals(key2, kbd_constants_exports.BACKSPACE);
}

// node_modules/bits-ui/dist/bits/time-field/components/time-field.svelte
Time_field[FILENAME] = "node_modules/bits-ui/dist/bits/time-field/components/time-field.svelte";
function Time_field($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Time_field);
  let disabled = prop($$props, "disabled", 3, false), hideTimeZone = prop($$props, "hideTimeZone", 3, false), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop3), onValueChange = prop($$props, "onValueChange", 3, noop3), validate = prop($$props, "validate", 3, noop3), onInvalid = prop($$props, "onInvalid", 3, noop3), placeholder = prop($$props, "placeholder", 15), value = prop($$props, "value", 15), readonly = prop($$props, "readonly", 3, false), readonlySegments = prop($$props, "readonlySegments", 19, () => []), required = prop($$props, "required", 3, false);
  function handleDefaultPlaceholder() {
    if (strict_equals(placeholder(), void 0, false)) return;
    const defaultPlaceholder = getDefaultTime({ granularity: $$props.granularity, defaultValue: value() });
    placeholder(defaultPlaceholder);
  }
  handleDefaultPlaceholder();
  watch.pre(() => placeholder(), () => {
    handleDefaultPlaceholder();
  });
  TimeFieldRootState.create({
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    placeholder: box.with(() => placeholder(), (v) => {
      placeholder(v);
      onPlaceholderChange()(v);
    }),
    disabled: box.with(() => disabled()),
    granularity: box.with(() => $$props.granularity),
    hideTimeZone: box.with(() => hideTimeZone()),
    hourCycle: box.with(() => $$props.hourCycle),
    locale: resolveLocaleProp(() => $$props.locale),
    maxValue: box.with(() => $$props.maxValue),
    minValue: box.with(() => $$props.minValue),
    validate: box.with(() => validate()),
    readonly: box.with(() => readonly()),
    readonlySegments: box.with(() => readonlySegments()),
    required: box.with(() => required()),
    onInvalid: box.with(() => onInvalid()),
    errorMessageId: box.with(() => $$props.errorMessageId),
    isInvalidProp: box.with(() => void 0)
  });
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop), "render", Time_field, 95, 0);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Time_field = hmr(Time_field, () => Time_field[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Time_field[HMR].source;
    set(Time_field[HMR].source, module.default[HMR].original);
  });
}
var time_field_default = Time_field;

// node_modules/bits-ui/dist/bits/time-field/components/time-field-hidden-input.svelte
Time_field_hidden_input[FILENAME] = "node_modules/bits-ui/dist/bits/time-field/components/time-field-hidden-input.svelte";
function Time_field_hidden_input($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Time_field_hidden_input);
  const hiddenInputState = TimeFieldHiddenInputState.create();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => hidden_input_default(node_1, spread_props(() => hiddenInputState.props)), "component", Time_field_hidden_input, 9, 1, { componentTag: "HiddenInput" });
      append($$anchor2, fragment_1);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (hiddenInputState.shouldRender) $$render(consequent);
      }),
      "if",
      Time_field_hidden_input,
      8,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Time_field_hidden_input = hmr(Time_field_hidden_input, () => Time_field_hidden_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Time_field_hidden_input[HMR].source;
    set(Time_field_hidden_input[HMR].source, module.default[HMR].original);
  });
}
var time_field_hidden_input_default = Time_field_hidden_input;

// node_modules/bits-ui/dist/bits/time-field/components/time-field-input.svelte
Time_field_input[FILENAME] = "node_modules/bits-ui/dist/bits/time-field/components/time-field-input.svelte";
var root_2104 = add_locations(from_html(`<div><!></div>`), Time_field_input[FILENAME], [[34, 1]]);
var root16 = add_locations(from_html(`<!> <!>`, 1), Time_field_input[FILENAME], []);
function Time_field_input($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Time_field_input);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), name = prop($$props, "name", 3, ""), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "name",
      "children",
      "child"
    ],
    "restProps"
  );
  const inputState = TimeFieldInputState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    name: box.with(() => name())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, inputState.props)), "mergedProps");
  var fragment = root16();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => snippet(node_1, () => $$props.child, () => ({
          props: get(mergedProps),
          segments: inputState.root.segmentContents
        })),
        "render",
        Time_field_input,
        32,
        1
      );
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2104();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => ({ segments: inputState.root.segmentContents })), "render", Time_field_input, 35, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Time_field_input,
      31,
      0
    );
  }
  var node_3 = sibling(node, 2);
  add_svelte_meta(() => time_field_hidden_input_default(node_3, {}), "component", Time_field_input, 39, 0, { componentTag: "DateFieldHiddenInput" });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Time_field_input = hmr(Time_field_input, () => Time_field_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Time_field_input[HMR].source;
    set(Time_field_input[HMR].source, module.default[HMR].original);
  });
}
var time_field_input_default = Time_field_input;

// node_modules/bits-ui/dist/bits/time-field/components/time-field-label.svelte
Time_field_label[FILENAME] = "node_modules/bits-ui/dist/bits/time-field/components/time-field-label.svelte";
var root_2105 = add_locations(from_html(`<div><!></div>`), Time_field_label[FILENAME], [[31, 1]]);
function Time_field_label($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Time_field_label);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const labelState = TimeFieldLabelState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, labelState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Time_field_label, 29, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2105();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Time_field_label, 32, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Time_field_label,
      28,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Time_field_label = hmr(Time_field_label, () => Time_field_label[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Time_field_label[HMR].source;
    set(Time_field_label[HMR].source, module.default[HMR].original);
  });
}
var time_field_label_default = Time_field_label;

// node_modules/bits-ui/dist/bits/time-field/components/time-field-segment.svelte
Time_field_segment[FILENAME] = "node_modules/bits-ui/dist/bits/time-field/components/time-field-segment.svelte";
var root_2106 = add_locations(from_html(`<span><!></span>`), Time_field_segment[FILENAME], [[34, 1]]);
function Time_field_segment($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Time_field_segment);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child",
      "part"
    ],
    "restProps"
  );
  const segmentState = DateFieldSegmentState2.create($$props.part, {
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, segmentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Time_field_segment, 32, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_2106();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Time_field_segment, 35, 2);
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Time_field_segment,
      31,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Time_field_segment = hmr(Time_field_segment, () => Time_field_segment[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Time_field_segment[HMR].source;
    set(Time_field_segment[HMR].source, module.default[HMR].original);
  });
}
var time_field_segment_default = Time_field_segment;

// node_modules/bits-ui/dist/bits/time-range-field/exports.js
var exports_exports37 = {};
__export(exports_exports37, {
  Input: () => time_range_field_input_default,
  Label: () => time_range_field_label_default,
  Root: () => time_range_field_default,
  Segment: () => time_field_segment_default
});

// node_modules/bits-ui/dist/bits/time-range-field/time-range-field.svelte.js
var timeRangeFieldAttrs = createBitsAttrs({ component: "time-range-field", parts: ["root", "label"] });
var TimeRangeFieldRootContext = new Context("TimeRangeField.Root");
var TimeRangeFieldRootState = class _TimeRangeFieldRootState {
  static create(opts) {
    return TimeRangeFieldRootContext.set(new _TimeRangeFieldRootState(opts));
  }
  opts;
  attachment;
  startFieldState = void 0;
  endFieldState = void 0;
  descriptionId = useId();
  formatter;
  #fieldNode = tag(state(null), "TimeRangeFieldRootState.fieldNode");
  get fieldNode() {
    return get(this.#fieldNode);
  }
  set fieldNode(value) {
    set(this.#fieldNode, value, true);
  }
  #labelNode = tag(state(null), "TimeRangeFieldRootState.labelNode");
  get labelNode() {
    return get(this.#labelNode);
  }
  set labelNode(value) {
    set(this.#labelNode, value, true);
  }
  #descriptionNode = tag(state(null), "TimeRangeFieldRootState.descriptionNode");
  get descriptionNode() {
    return get(this.#descriptionNode);
  }
  set descriptionNode(value) {
    set(this.#descriptionNode, value, true);
  }
  #startValueComplete = tag(user_derived(() => strict_equals(this.opts.startValue.current, void 0, false)), "TimeRangeFieldRootState.startValueComplete");
  get startValueComplete() {
    return get(this.#startValueComplete);
  }
  set startValueComplete(value) {
    set(this.#startValueComplete, value);
  }
  #endValueComplete = tag(user_derived(() => strict_equals(this.opts.endValue.current, void 0, false)), "TimeRangeFieldRootState.endValueComplete");
  get endValueComplete() {
    return get(this.#endValueComplete);
  }
  set endValueComplete(value) {
    set(this.#endValueComplete, value);
  }
  #rangeComplete = tag(user_derived(() => this.startValueComplete && this.endValueComplete), "TimeRangeFieldRootState.rangeComplete");
  get rangeComplete() {
    return get(this.#rangeComplete);
  }
  set rangeComplete(value) {
    set(this.#rangeComplete, value);
  }
  #startValueTime = tag(
    user_derived(() => {
      if (!this.opts.startValue.current) return void 0;
      return convertTimeValueToTime(this.opts.startValue.current);
    }),
    "TimeRangeFieldRootState.startValueTime"
  );
  get startValueTime() {
    return get(this.#startValueTime);
  }
  set startValueTime(value) {
    set(this.#startValueTime, value);
  }
  #endValueTime = tag(
    user_derived(() => {
      if (!this.opts.endValue.current) return void 0;
      return convertTimeValueToTime(this.opts.endValue.current);
    }),
    "TimeRangeFieldRootState.endValueTime"
  );
  get endValueTime() {
    return get(this.#endValueTime);
  }
  set endValueTime(value) {
    set(this.#endValueTime, value);
  }
  #minValueTime = tag(
    user_derived(() => {
      if (!this.opts.minValue.current) return void 0;
      return convertTimeValueToTime(this.opts.minValue.current);
    }),
    "TimeRangeFieldRootState.minValueTime"
  );
  get minValueTime() {
    return get(this.#minValueTime);
  }
  set minValueTime(value) {
    set(this.#minValueTime, value);
  }
  #maxValueTime = tag(
    user_derived(() => {
      if (!this.opts.maxValue.current) return void 0;
      return convertTimeValueToTime(this.opts.maxValue.current);
    }),
    "TimeRangeFieldRootState.maxValueTime"
  );
  get maxValueTime() {
    return get(this.#maxValueTime);
  }
  set maxValueTime(value) {
    set(this.#maxValueTime, value);
  }
  domContext;
  constructor(opts) {
    this.opts = opts;
    this.formatter = createTimeFormatter(this.opts.locale.current);
    this.domContext = new DOMContext(this.opts.ref);
    this.attachment = attachRef(this.opts.ref, (v) => this.fieldNode = v);
    onDestroyEffect(() => {
      removeDescriptionElement(this.descriptionId, this.domContext.getDocument());
    });
    user_effect(() => {
      if (strict_equals(this.formatter.getLocale(), this.opts.locale.current)) return;
      this.formatter.setLocale(this.opts.locale.current);
    });
    watch(() => this.opts.value.current, (value) => {
      if (value.start && value.end) {
        this.opts.startValue.current = value.start;
        this.opts.endValue.current = value.end;
      } else if (value.start) {
        this.opts.startValue.current = value.start;
        this.opts.endValue.current = void 0;
      } else if (strict_equals(value.start, void 0) && strict_equals(value.end, void 0)) {
        this.opts.startValue.current = void 0;
        this.opts.endValue.current = void 0;
      }
    });
    watch(() => this.opts.value.current, (value) => {
      const startValue = value.start;
      if (startValue && strict_equals(this.opts.placeholder.current, startValue, false)) {
        this.opts.placeholder.current = startValue;
      }
    });
    watch(
      [
        () => this.opts.startValue.current,
        () => this.opts.endValue.current
      ],
      ([startValue, endValue]) => {
        if (this.opts.value.current && strict_equals(this.opts.value.current.start, startValue) && strict_equals(this.opts.value.current.end, endValue)) {
          return;
        }
        if (startValue && endValue) {
          this.#updateValue((prev2) => {
            if (strict_equals(prev2.start, startValue) && strict_equals(prev2.end, endValue)) {
              return prev2;
            }
            return { start: startValue, end: endValue };
          });
        } else if (this.opts.value.current && this.opts.value.current.start && this.opts.value.current.end) {
          this.opts.value.current.start = void 0;
          this.opts.value.current.end = void 0;
        }
      }
    );
  }
  #validationStatus = tag(
    user_derived(() => {
      const value = this.opts.value.current;
      if (strict_equals(value, void 0)) return false;
      if (strict_equals(value.start, void 0) || strict_equals(value.end, void 0)) return false;
      const msg = this.opts.validate.current?.({ start: value.start, end: value.end });
      if (msg) {
        return { reason: "custom", message: msg };
      }
      if (this.minValueTime && this.startValueTime && isTimeBefore(this.startValueTime, this.minValueTime)) {
        return { reason: "min" };
      }
      if (this.maxValueTime && this.endValueTime && isTimeBefore(this.maxValueTime, this.endValueTime)) {
        return { reason: "max" };
      }
      return false;
    }),
    "TimeRangeFieldRootState.validationStatus"
  );
  get validationStatus() {
    return get(this.#validationStatus);
  }
  set validationStatus(value) {
    set(this.#validationStatus, value);
  }
  #isInvalid = tag(
    user_derived(() => {
      if (strict_equals(this.validationStatus, false)) return false;
      return true;
    }),
    "TimeRangeFieldRootState.isInvalid"
  );
  get isInvalid() {
    return get(this.#isInvalid);
  }
  set isInvalid(value) {
    set(this.#isInvalid, value);
  }
  #updateValue(cb) {
    const value = this.opts.value.current;
    const newValue = cb(value);
    this.opts.value.current = newValue;
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "group",
      [timeRangeFieldAttrs.root]: "",
      "data-invalid": getDataInvalid(this.isInvalid),
      ...this.attachment
    })),
    "TimeRangeFieldRootState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var TimeRangeFieldLabelState = class _TimeRangeFieldLabelState {
  static create(opts) {
    return new _TimeRangeFieldLabelState(opts, TimeRangeFieldRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.labelNode = v);
  }
  #onclick = () => {
    if (this.root.opts.disabled.current) return;
    const firstSegment = getFirstSegment(this.root.fieldNode);
    if (!firstSegment) return;
    firstSegment.focus();
  };
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "data-invalid": getDataInvalid(this.root.isInvalid),
      "data-disabled": getDataDisabled(this.root.opts.disabled.current),
      [timeRangeFieldAttrs.label]: "",
      onclick: this.#onclick,
      ...this.attachment
    })),
    "TimeRangeFieldLabelState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var TimeRangeFieldInputState = class {
  static create(opts, type) {
    const root18 = TimeRangeFieldRootContext.get();
    const fieldState = TimeFieldRootState.create(
      {
        value: strict_equals(type, "start") ? root18.opts.startValue : root18.opts.endValue,
        disabled: root18.opts.disabled,
        readonly: root18.opts.readonly,
        readonlySegments: root18.opts.readonlySegments,
        validate: box.with(() => void 0),
        minValue: root18.opts.minValue,
        maxValue: root18.opts.maxValue,
        hourCycle: root18.opts.hourCycle,
        locale: root18.opts.locale,
        hideTimeZone: root18.opts.hideTimeZone,
        required: root18.opts.required,
        granularity: root18.opts.granularity,
        placeholder: root18.opts.placeholder,
        onInvalid: root18.opts.onInvalid,
        errorMessageId: root18.opts.errorMessageId,
        isInvalidProp: box.with(() => root18.isInvalid)
      },
      root18
    );
    return new TimeFieldInputState({ name: opts.name, id: opts.id, ref: opts.ref }, fieldState);
  }
};

// node_modules/bits-ui/dist/bits/time-range-field/components/time-range-field.svelte
Time_range_field[FILENAME] = "node_modules/bits-ui/dist/bits/time-range-field/components/time-range-field.svelte";
var root_2107 = add_locations(from_html(`<div><!></div>`), Time_range_field[FILENAME], [[142, 1]]);
function Time_range_field($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Time_range_field);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop3), placeholder = prop($$props, "placeholder", 15), onPlaceholderChange = prop($$props, "onPlaceholderChange", 3, noop3), disabled = prop($$props, "disabled", 3, false), readonly = prop($$props, "readonly", 3, false), required = prop($$props, "required", 3, false), hideTimeZone = prop($$props, "hideTimeZone", 3, false), validate = prop($$props, "validate", 3, noop3), onInvalid = prop($$props, "onInvalid", 3, noop3), readonlySegments = prop($$props, "readonlySegments", 19, () => []), onStartValueChange = prop($$props, "onStartValueChange", 3, noop3), onEndValueChange = prop($$props, "onEndValueChange", 3, noop3), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "onValueChange",
      "placeholder",
      "onPlaceholderChange",
      "disabled",
      "readonly",
      "required",
      "hourCycle",
      "granularity",
      "locale",
      "hideTimeZone",
      "validate",
      "onInvalid",
      "maxValue",
      "minValue",
      "readonlySegments",
      "children",
      "child",
      "onStartValueChange",
      "onEndValueChange",
      "errorMessageId"
    ],
    "restProps"
  );
  let startValue = tag(state(proxy(value()?.start)), "startValue");
  let endValue = tag(state(proxy(value()?.end)), "endValue");
  function handleDefaultPlaceholder() {
    if (strict_equals(placeholder(), void 0, false)) return;
    const defaultPlaceholder = getDefaultTime({
      granularity: $$props.granularity,
      defaultValue: value()?.start
    });
    placeholder(defaultPlaceholder);
  }
  handleDefaultPlaceholder();
  watch.pre(() => placeholder(), () => {
    handleDefaultPlaceholder();
  });
  function handleDefaultValue() {
    if (strict_equals(value(), void 0, false)) return;
    const defaultValue = { start: void 0, end: void 0 };
    value(defaultValue);
  }
  handleDefaultValue();
  watch.pre(() => value(), () => {
    handleDefaultValue();
  });
  const rootState = TimeRangeFieldRootState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    disabled: box.with(() => disabled()),
    readonly: box.with(() => readonly()),
    required: box.with(() => required()),
    hourCycle: box.with(() => $$props.hourCycle),
    granularity: box.with(() => $$props.granularity),
    locale: resolveLocaleProp(() => $$props.locale),
    hideTimeZone: box.with(() => hideTimeZone()),
    validate: box.with(() => validate()),
    maxValue: box.with(() => $$props.maxValue),
    minValue: box.with(() => $$props.minValue),
    placeholder: box.with(() => placeholder(), (v) => {
      placeholder(v);
      onPlaceholderChange()(v);
    }),
    readonlySegments: box.with(() => readonlySegments()),
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    startValue: box.with(() => get(startValue), (v) => {
      set(startValue, v, true);
      onStartValueChange()(v);
    }),
    endValue: box.with(() => get(endValue), (v) => {
      set(endValue, v, true);
      onEndValueChange()(v);
    }),
    onInvalid: box.with(() => onInvalid()),
    errorMessageId: box.with(() => $$props.errorMessageId)
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Time_range_field, 140, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2107();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Time_range_field, 143, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Time_range_field,
      139,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Time_range_field = hmr(Time_range_field, () => Time_range_field[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Time_range_field[HMR].source;
    set(Time_range_field[HMR].source, module.default[HMR].original);
  });
}
var time_range_field_default = Time_range_field;

// node_modules/bits-ui/dist/bits/time-range-field/components/time-range-field-input.svelte
Time_range_field_input[FILENAME] = "node_modules/bits-ui/dist/bits/time-range-field/components/time-range-field-input.svelte";
var root_2108 = add_locations(from_html(`<div><!></div>`), Time_range_field_input[FILENAME], [[38, 1]]);
var root17 = add_locations(from_html(`<!> <!>`, 1), Time_range_field_input[FILENAME], []);
function Time_range_field_input($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Time_range_field_input);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), name = prop($$props, "name", 3, ""), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "name",
      "child",
      "children",
      "type"
    ],
    "restProps"
  );
  const inputState = TimeRangeFieldInputState.create(
    {
      id: box.with(() => id()),
      ref: box.with(() => ref(), (v) => ref(v)),
      name: box.with(() => name())
    },
    $$props.type
  );
  const mergedProps = tag(user_derived(() => mergeProps(restProps, inputState.props, { role: "presentation" })), "mergedProps");
  var fragment = root17();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(
        () => snippet(node_1, () => $$props.child, () => ({
          props: get(mergedProps),
          segments: inputState.root.segmentContents
        })),
        "render",
        Time_range_field_input,
        36,
        1
      );
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2108();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => ({ segments: inputState.root.segmentContents })), "render", Time_range_field_input, 39, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Time_range_field_input,
      35,
      0
    );
  }
  var node_3 = sibling(node, 2);
  add_svelte_meta(() => time_field_hidden_input_default(node_3, {}), "component", Time_range_field_input, 43, 0, { componentTag: "TimeFieldHiddenInput" });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Time_range_field_input = hmr(Time_range_field_input, () => Time_range_field_input[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Time_range_field_input[HMR].source;
    set(Time_range_field_input[HMR].source, module.default[HMR].original);
  });
}
var time_range_field_input_default = Time_range_field_input;

// node_modules/bits-ui/dist/bits/time-range-field/components/time-range-field-label.svelte
Time_range_field_label[FILENAME] = "node_modules/bits-ui/dist/bits/time-range-field/components/time-range-field-label.svelte";
var root_2109 = add_locations(from_html(`<span><!></span>`), Time_range_field_label[FILENAME], [[31, 1]]);
function Time_range_field_label($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Time_range_field_label);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "children",
      "child"
    ],
    "restProps"
  );
  const labelState = TimeRangeFieldLabelState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, labelState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Time_range_field_label, 29, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var span = root_2109();
      attribute_effect(span, () => ({ ...get(mergedProps) }));
      var node_2 = child(span);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Time_range_field_label, 32, 2);
      reset(span);
      append($$anchor2, span);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Time_range_field_label,
      28,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Time_range_field_label = hmr(Time_range_field_label, () => Time_range_field_label[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Time_range_field_label[HMR].source;
    set(Time_range_field_label[HMR].source, module.default[HMR].original);
  });
}
var time_range_field_label_default = Time_range_field_label;

// node_modules/bits-ui/dist/bits/toggle/exports.js
var exports_exports38 = {};
__export(exports_exports38, {
  Root: () => toggle_default
});

// node_modules/bits-ui/dist/bits/toggle/toggle.svelte.js
var toggleAttrs = createBitsAttrs({ component: "toggle", parts: ["root"] });
var ToggleRootState = class _ToggleRootState {
  static create(opts) {
    return new _ToggleRootState(opts);
  }
  opts;
  attachment;
  constructor(opts) {
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.onclick = this.onclick.bind(this);
  }
  #togglePressed() {
    if (!this.opts.disabled.current) {
      this.opts.pressed.current = !this.opts.pressed.current;
    }
  }
  onclick(_) {
    if (this.opts.disabled.current) return;
    this.#togglePressed();
  }
  #snippetProps = tag(user_derived(() => ({ pressed: this.opts.pressed.current })), "ToggleRootState.snippetProps");
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
  #props = tag(
    user_derived(() => ({
      [toggleAttrs.root]: "",
      id: this.opts.id.current,
      "data-disabled": getDataDisabled(this.opts.disabled.current),
      "aria-pressed": getAriaPressed(this.opts.pressed.current),
      "data-state": getToggleDataState(this.opts.pressed.current),
      disabled: getDisabled(this.opts.disabled.current),
      onclick: this.onclick,
      ...this.attachment
    })),
    "ToggleRootState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
function getToggleDataState(condition) {
  return condition ? "on" : "off";
}

// node_modules/bits-ui/dist/bits/toggle/components/toggle.svelte
Toggle[FILENAME] = "node_modules/bits-ui/dist/bits/toggle/components/toggle.svelte";
var root_2110 = add_locations(from_html(`<button><!></button>`), Toggle[FILENAME], [[44, 1]]);
function Toggle($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Toggle);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), pressed = prop($$props, "pressed", 15, false), onPressedChange = prop($$props, "onPressedChange", 3, noop3), disabled = prop($$props, "disabled", 3, false), type = prop($$props, "type", 3, "button"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "pressed",
      "onPressedChange",
      "disabled",
      "type",
      "children",
      "child"
    ],
    "restProps"
  );
  const toggleState = ToggleRootState.create({
    pressed: box.with(() => pressed(), (v) => {
      pressed(v);
      onPressedChange()(v);
    }),
    disabled: box.with(() => disabled() ?? false),
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, toggleState.props, { type: type() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => ({ props: get(mergedProps), ...toggleState.snippetProps }));
        add_svelte_meta(() => snippet(node_1, () => $$props.child, () => get($0)), "render", Toggle, 42, 1);
      }
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2110();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => toggleState.snippetProps), "render", Toggle, 45, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Toggle,
      41,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Toggle = hmr(Toggle, () => Toggle[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Toggle[HMR].source;
    set(Toggle[HMR].source, module.default[HMR].original);
  });
}
var toggle_default = Toggle;

// node_modules/bits-ui/dist/bits/toggle-group/exports.js
var exports_exports39 = {};
__export(exports_exports39, {
  Item: () => toggle_group_item_default,
  Root: () => toggle_group_default
});

// node_modules/bits-ui/dist/bits/toggle-group/toggle-group.svelte.js
var toggleGroupAttrs = createBitsAttrs({ component: "toggle-group", parts: ["root", "item"] });
var ToggleGroupRootContext = new Context("ToggleGroup.Root");
var ToggleGroupBaseState = class {
  opts;
  rovingFocusGroup;
  attachment;
  constructor(opts) {
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.rovingFocusGroup = new RovingFocusGroup({
      candidateAttr: toggleGroupAttrs.item,
      rootNode: opts.ref,
      loop: opts.loop,
      orientation: opts.orientation
    });
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      [toggleGroupAttrs.root]: "",
      role: "group",
      "data-orientation": getDataOrientation(this.opts.orientation.current),
      "data-disabled": getDataDisabled(this.opts.disabled.current),
      ...this.attachment
    })),
    "ToggleGroupBaseState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var ToggleGroupSingleState = class extends ToggleGroupBaseState {
  opts;
  isMulti = false;
  #anyPressed = tag(user_derived(() => strict_equals(this.opts.value.current, "", false)), "ToggleGroupSingleState.anyPressed");
  get anyPressed() {
    return get(this.#anyPressed);
  }
  set anyPressed(value) {
    set(this.#anyPressed, value);
  }
  constructor(opts) {
    super(opts);
    this.opts = opts;
  }
  includesItem(item) {
    return strict_equals(this.opts.value.current, item);
  }
  toggleItem(item, id) {
    if (this.includesItem(item)) {
      this.opts.value.current = "";
    } else {
      this.opts.value.current = item;
      this.rovingFocusGroup.setCurrentTabStopId(id);
    }
  }
};
var ToggleGroupMultipleState = class extends ToggleGroupBaseState {
  opts;
  isMulti = true;
  #anyPressed = tag(user_derived(() => this.opts.value.current.length > 0), "ToggleGroupMultipleState.anyPressed");
  get anyPressed() {
    return get(this.#anyPressed);
  }
  set anyPressed(value) {
    set(this.#anyPressed, value);
  }
  constructor(opts) {
    super(opts);
    this.opts = opts;
  }
  includesItem(item) {
    return this.opts.value.current.includes(item);
  }
  toggleItem(item, id) {
    if (this.includesItem(item)) {
      this.opts.value.current = this.opts.value.current.filter((v) => strict_equals(v, item, false));
    } else {
      this.opts.value.current = [...this.opts.value.current, item];
      this.rovingFocusGroup.setCurrentTabStopId(id);
    }
  }
};
var ToggleGroupRootState = class {
  static create(opts) {
    const { type, ...rest } = opts;
    const rootState = strict_equals(type, "single") ? new ToggleGroupSingleState(rest) : new ToggleGroupMultipleState(rest);
    return ToggleGroupRootContext.set(rootState);
  }
};
var ToggleGroupItemState = class _ToggleGroupItemState {
  static create(opts) {
    return new _ToggleGroupItemState(opts, ToggleGroupRootContext.get());
  }
  opts;
  root;
  attachment;
  #isDisabled = tag(user_derived(() => this.opts.disabled.current || this.root.opts.disabled.current), "ToggleGroupItemState.#isDisabled");
  #isPressed = tag(user_derived(() => this.root.includesItem(this.opts.value.current)), "ToggleGroupItemState.isPressed");
  get isPressed() {
    return get(this.#isPressed);
  }
  set isPressed(value) {
    set(this.#isPressed, value);
  }
  #ariaChecked = tag(
    user_derived(() => {
      return this.root.isMulti ? void 0 : getAriaChecked(this.isPressed, false);
    }),
    "ToggleGroupItemState.#ariaChecked"
  );
  #ariaPressed = tag(
    user_derived(() => {
      return this.root.isMulti ? getAriaPressed(this.isPressed) : void 0;
    }),
    "ToggleGroupItemState.#ariaPressed"
  );
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    user_effect(() => {
      if (!this.root.opts.rovingFocus.current) {
        set(this.#tabIndex, 0);
      } else {
        set(this.#tabIndex, this.root.rovingFocusGroup.getTabIndex(this.opts.ref.current), true);
      }
    });
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  #toggleItem() {
    if (get(this.#isDisabled)) return;
    this.root.toggleItem(this.opts.value.current, this.opts.id.current);
  }
  onclick(_) {
    if (get(this.#isDisabled)) return;
    this.root.toggleItem(this.opts.value.current, this.opts.id.current);
  }
  onkeydown(e) {
    if (get(this.#isDisabled)) return;
    if (strict_equals(e.key, kbd_constants_exports.ENTER) || strict_equals(e.key, kbd_constants_exports.SPACE)) {
      e.preventDefault();
      this.#toggleItem();
      return;
    }
    if (!this.root.opts.rovingFocus.current) return;
    this.root.rovingFocusGroup.handleKeydown(this.opts.ref.current, e);
  }
  #tabIndex = tag(state(0), "ToggleGroupItemState.#tabIndex");
  #snippetProps = tag(user_derived(() => ({ pressed: this.isPressed })), "ToggleGroupItemState.snippetProps");
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: this.root.isMulti ? void 0 : "radio",
      tabindex: get(this.#tabIndex),
      "data-orientation": getDataOrientation(this.root.opts.orientation.current),
      "data-disabled": getDataDisabled(get(this.#isDisabled)),
      "data-state": getToggleItemDataState(this.isPressed),
      "data-value": this.opts.value.current,
      "aria-pressed": get(this.#ariaPressed),
      "aria-checked": get(this.#ariaChecked),
      disabled: getDisabled(get(this.#isDisabled)),
      [toggleGroupAttrs.item]: "",
      onclick: this.onclick,
      onkeydown: this.onkeydown,
      ...this.attachment
    })),
    "ToggleGroupItemState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
function getToggleItemDataState(condition) {
  return condition ? "on" : "off";
}

// node_modules/bits-ui/dist/bits/toggle-group/components/toggle-group.svelte
Toggle_group[FILENAME] = "node_modules/bits-ui/dist/bits/toggle-group/components/toggle-group.svelte";
var root_2111 = add_locations(from_html(`<div><!></div>`), Toggle_group[FILENAME], [[69, 1]]);
function Toggle_group($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Toggle_group);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop3), disabled = prop($$props, "disabled", 3, false), loop = prop($$props, "loop", 3, true), orientation = prop($$props, "orientation", 3, "horizontal"), rovingFocus = prop($$props, "rovingFocus", 3, true), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "onValueChange",
      "type",
      "disabled",
      "loop",
      "orientation",
      "rovingFocus",
      "child",
      "children"
    ],
    "restProps"
  );
  function handleDefaultValue() {
    if (strict_equals(value(), void 0, false)) return;
    value(strict_equals($$props.type, "single") ? "" : []);
  }
  handleDefaultValue();
  watch.pre(() => value(), () => {
    handleDefaultValue();
  });
  const rootState = ToggleGroupRootState.create({
    id: box.with(() => id()),
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    disabled: box.with(() => disabled()),
    loop: box.with(() => loop()),
    orientation: box.with(() => orientation()),
    rovingFocus: box.with(() => rovingFocus()),
    type: $$props.type,
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Toggle_group, 67, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2111();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Toggle_group, 70, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Toggle_group,
      66,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Toggle_group = hmr(Toggle_group, () => Toggle_group[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Toggle_group[HMR].source;
    set(Toggle_group[HMR].source, module.default[HMR].original);
  });
}
var toggle_group_default = Toggle_group;

// node_modules/bits-ui/dist/bits/toggle-group/components/toggle-group-item.svelte
Toggle_group_item[FILENAME] = "node_modules/bits-ui/dist/bits/toggle-group/components/toggle-group-item.svelte";
var root_2112 = add_locations(from_html(`<button><!></button>`), Toggle_group_item[FILENAME], [[36, 1]]);
function Toggle_group_item($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Toggle_group_item);
  let ref = prop($$props, "ref", 15, null), disabled = prop($$props, "disabled", 3, false), id = prop($$props, "id", 19, () => createId(uid)), type = prop($$props, "type", 3, "button"), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "ref",
      "value",
      "disabled",
      "id",
      "type"
    ],
    "restProps"
  );
  const itemState = ToggleGroupItemState.create({
    id: box.with(() => id()),
    value: box.with(() => $$props.value),
    disabled: box.with(() => disabled() ?? false),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, itemState.props, { type: type() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        let $0 = user_derived(() => ({ props: get(mergedProps), ...itemState.snippetProps }));
        add_svelte_meta(() => snippet(node_1, () => $$props.child, () => get($0)), "render", Toggle_group_item, 34, 1);
      }
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2112();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => itemState.snippetProps), "render", Toggle_group_item, 37, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Toggle_group_item,
      33,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Toggle_group_item = hmr(Toggle_group_item, () => Toggle_group_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Toggle_group_item[HMR].source;
    set(Toggle_group_item[HMR].source, module.default[HMR].original);
  });
}
var toggle_group_item_default = Toggle_group_item;

// node_modules/bits-ui/dist/bits/toolbar/exports.js
var exports_exports40 = {};
__export(exports_exports40, {
  Button: () => toolbar_button_default,
  Group: () => toolbar_group_default,
  GroupItem: () => toolbar_group_item_default,
  Link: () => toolbar_link_default,
  Root: () => toolbar_default
});

// node_modules/bits-ui/dist/bits/toolbar/toolbar.svelte.js
var toolbarAttrs = createBitsAttrs({
  component: "toolbar",
  parts: ["root", "item", "group", "group-item", "link", "button"]
});
var ToolbarRootContext = new Context("Toolbar.Root");
var ToolbarGroupContext = new Context("Toolbar.Group");
var ToolbarRootState = class _ToolbarRootState {
  static create(opts) {
    return ToolbarRootContext.set(new _ToolbarRootState(opts));
  }
  opts;
  rovingFocusGroup;
  attachment;
  constructor(opts) {
    this.opts = opts;
    this.attachment = attachRef(this.opts.ref);
    this.rovingFocusGroup = new RovingFocusGroup({
      orientation: this.opts.orientation,
      loop: this.opts.loop,
      rootNode: this.opts.ref,
      candidateAttr: toolbarAttrs.item
    });
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: "toolbar",
      "data-orientation": this.opts.orientation.current,
      [toolbarAttrs.root]: "",
      ...this.attachment
    })),
    "ToolbarRootState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var ToolbarGroupBaseState = class {
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      [toolbarAttrs.group]: "",
      role: "group",
      "data-orientation": getDataOrientation(this.root.opts.orientation.current),
      "data-disabled": getDataDisabled(this.opts.disabled.current),
      ...this.attachment
    })),
    "ToolbarGroupBaseState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var ToolbarGroupSingleState = class extends ToolbarGroupBaseState {
  opts;
  root;
  isMulti = false;
  #anyPressed = tag(user_derived(() => strict_equals(this.opts.value.current, "", false)), "ToolbarGroupSingleState.anyPressed");
  get anyPressed() {
    return get(this.#anyPressed);
  }
  set anyPressed(value) {
    set(this.#anyPressed, value);
  }
  constructor(opts, root18) {
    super(opts, root18);
    this.opts = opts;
    this.root = root18;
  }
  includesItem(item) {
    return strict_equals(this.opts.value.current, item);
  }
  toggleItem(item) {
    if (this.includesItem(item)) {
      this.opts.value.current = "";
    } else {
      this.opts.value.current = item;
    }
  }
};
var ToolbarGroupMultipleState = class extends ToolbarGroupBaseState {
  opts;
  root;
  isMulti = true;
  #anyPressed = tag(user_derived(() => this.opts.value.current.length > 0), "ToolbarGroupMultipleState.anyPressed");
  get anyPressed() {
    return get(this.#anyPressed);
  }
  set anyPressed(value) {
    set(this.#anyPressed, value);
  }
  constructor(opts, root18) {
    super(opts, root18);
    this.opts = opts;
    this.root = root18;
  }
  includesItem(item) {
    return this.opts.value.current.includes(item);
  }
  toggleItem(item) {
    if (this.includesItem(item)) {
      this.opts.value.current = this.opts.value.current.filter((v) => strict_equals(v, item, false));
    } else {
      this.opts.value.current = [...this.opts.value.current, item];
    }
  }
};
var ToolbarGroupState = class {
  static create(opts) {
    const { type, ...rest } = opts;
    const rootState = ToolbarRootContext.get();
    const groupState = strict_equals(type, "single") ? new ToolbarGroupSingleState(rest, rootState) : new ToolbarGroupMultipleState(rest, rootState);
    return ToolbarGroupContext.set(groupState);
  }
};
var ToolbarGroupItemState = class _ToolbarGroupItemState {
  static create(opts) {
    const group = ToolbarGroupContext.get();
    return new _ToolbarGroupItemState(opts, group, group.root);
  }
  opts;
  group;
  root;
  attachment;
  #isDisabled = tag(user_derived(() => this.opts.disabled.current || this.group.opts.disabled.current), "ToolbarGroupItemState.#isDisabled");
  constructor(opts, group, root18) {
    this.opts = opts;
    this.group = group;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    user_effect(() => {
      set(this.#tabIndex, this.root.rovingFocusGroup.getTabIndex(this.opts.ref.current), true);
    });
    this.onclick = this.onclick.bind(this);
    this.onkeydown = this.onkeydown.bind(this);
  }
  #toggleItem() {
    if (get(this.#isDisabled)) return;
    this.group.toggleItem(this.opts.value.current);
  }
  onclick(_) {
    if (get(this.#isDisabled)) return;
    this.#toggleItem();
  }
  onkeydown(e) {
    if (get(this.#isDisabled)) return;
    if (strict_equals(e.key, kbd_constants_exports.ENTER) || strict_equals(e.key, kbd_constants_exports.SPACE)) {
      e.preventDefault();
      this.#toggleItem();
      return;
    }
    this.root.rovingFocusGroup.handleKeydown(this.opts.ref.current, e);
  }
  #isPressed = tag(user_derived(() => this.group.includesItem(this.opts.value.current)), "ToolbarGroupItemState.isPressed");
  get isPressed() {
    return get(this.#isPressed);
  }
  set isPressed(value) {
    set(this.#isPressed, value);
  }
  #ariaChecked = tag(
    user_derived(() => {
      return this.group.isMulti ? void 0 : getAriaChecked(this.isPressed, false);
    }),
    "ToolbarGroupItemState.#ariaChecked"
  );
  #ariaPressed = tag(
    user_derived(() => {
      return this.group.isMulti ? getAriaPressed(this.isPressed) : void 0;
    }),
    "ToolbarGroupItemState.#ariaPressed"
  );
  #tabIndex = tag(state(0), "ToolbarGroupItemState.#tabIndex");
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      role: this.group.isMulti ? void 0 : "radio",
      tabindex: get(this.#tabIndex),
      "data-orientation": getDataOrientation(this.root.opts.orientation.current),
      "data-disabled": getDataDisabled(get(this.#isDisabled)),
      "data-state": getToggleItemDataState2(this.isPressed),
      "data-value": this.opts.value.current,
      "aria-pressed": get(this.#ariaPressed),
      "aria-checked": get(this.#ariaChecked),
      [toolbarAttrs.item]: "",
      [toolbarAttrs["group-item"]]: "",
      disabled: getDisabled(get(this.#isDisabled)),
      //
      onclick: this.onclick,
      onkeydown: this.onkeydown,
      ...this.attachment
    })),
    "ToolbarGroupItemState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var ToolbarLinkState = class _ToolbarLinkState {
  static create(opts) {
    return new _ToolbarLinkState(opts, ToolbarRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    user_effect(() => {
      set(this.#tabIndex, this.root.rovingFocusGroup.getTabIndex(this.opts.ref.current), true);
    });
    this.onkeydown = this.onkeydown.bind(this);
  }
  onkeydown(e) {
    this.root.rovingFocusGroup.handleKeydown(this.opts.ref.current, e);
  }
  #role = tag(
    user_derived(() => {
      if (!this.opts.ref.current) return void 0;
      const tagName = this.opts.ref.current.tagName;
      if (strict_equals(tagName, "A", false)) return "link";
      return void 0;
    }),
    "ToolbarLinkState.#role"
  );
  #tabIndex = tag(state(0), "ToolbarLinkState.#tabIndex");
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      [toolbarAttrs.link]: "",
      [toolbarAttrs.item]: "",
      role: get(this.#role),
      tabindex: get(this.#tabIndex),
      "data-orientation": getDataOrientation(this.root.opts.orientation.current),
      //
      onkeydown: this.onkeydown,
      ...this.attachment
    })),
    "ToolbarLinkState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var ToolbarButtonState = class _ToolbarButtonState {
  static create(opts) {
    return new _ToolbarButtonState(opts, ToolbarRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref);
    user_effect(() => {
      set(this.#tabIndex, this.root.rovingFocusGroup.getTabIndex(this.opts.ref.current), true);
    });
    this.onkeydown = this.onkeydown.bind(this);
  }
  onkeydown(e) {
    this.root.rovingFocusGroup.handleKeydown(this.opts.ref.current, e);
  }
  #tabIndex = tag(state(0), "ToolbarButtonState.#tabIndex");
  #role = tag(
    user_derived(() => {
      if (!this.opts.ref.current) return void 0;
      const tagName = this.opts.ref.current.tagName;
      if (strict_equals(tagName, "BUTTON", false)) return "button";
      return void 0;
    }),
    "ToolbarButtonState.#role"
  );
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      [toolbarAttrs.item]: "",
      [toolbarAttrs.button]: "",
      role: get(this.#role),
      tabindex: get(this.#tabIndex),
      "data-disabled": getDataDisabled(this.opts.disabled.current),
      "data-orientation": getDataOrientation(this.root.opts.orientation.current),
      disabled: getDisabled(this.opts.disabled.current),
      //
      onkeydown: this.onkeydown,
      ...this.attachment
    })),
    "ToolbarButtonState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
function getToggleItemDataState2(condition) {
  return condition ? "on" : "off";
}

// node_modules/bits-ui/dist/bits/toolbar/components/toolbar.svelte
Toolbar[FILENAME] = "node_modules/bits-ui/dist/bits/toolbar/components/toolbar.svelte";
var root_2113 = add_locations(from_html(`<div><!></div>`), Toolbar[FILENAME], [[35, 1]]);
function Toolbar($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Toolbar);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), orientation = prop($$props, "orientation", 3, "horizontal"), loop = prop($$props, "loop", 3, true), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "ref",
      "id",
      "orientation",
      "loop",
      "child",
      "children"
    ],
    "restProps"
  );
  const rootState = ToolbarRootState.create({
    id: box.with(() => id()),
    orientation: box.with(() => orientation()),
    loop: box.with(() => loop()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, rootState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Toolbar, 33, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2113();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Toolbar, 36, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Toolbar,
      32,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Toolbar = hmr(Toolbar, () => Toolbar[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Toolbar[HMR].source;
    set(Toolbar[HMR].source, module.default[HMR].original);
  });
}
var toolbar_default = Toolbar;

// node_modules/bits-ui/dist/bits/toolbar/components/toolbar-button.svelte
Toolbar_button[FILENAME] = "node_modules/bits-ui/dist/bits/toolbar/components/toolbar-button.svelte";
var root_2114 = add_locations(from_html(`<button><!></button>`), Toolbar_button[FILENAME], [[34, 1]]);
function Toolbar_button($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Toolbar_button);
  let disabled = prop($$props, "disabled", 3, false), type = prop($$props, "type", 3, "button"), id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "disabled",
      "type",
      "id",
      "ref"
    ],
    "restProps"
  );
  const buttonState = ToolbarButtonState.create({
    id: box.with(() => id()),
    disabled: box.with(() => disabled() ?? false),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, buttonState.props, { type: type() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Toolbar_button, 32, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2114();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Toolbar_button, 35, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Toolbar_button,
      31,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Toolbar_button = hmr(Toolbar_button, () => Toolbar_button[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Toolbar_button[HMR].source;
    set(Toolbar_button[HMR].source, module.default[HMR].original);
  });
}
var toolbar_button_default = Toolbar_button;

// node_modules/bits-ui/dist/bits/toolbar/components/toolbar-link.svelte
Toolbar_link[FILENAME] = "node_modules/bits-ui/dist/bits/toolbar/components/toolbar-link.svelte";
var root_2115 = add_locations(from_html(`<a><!></a>`), Toolbar_link[FILENAME], [[32, 1]]);
function Toolbar_link($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Toolbar_link);
  let ref = prop($$props, "ref", 15, null), id = prop($$props, "id", 19, () => createId(uid)), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "href",
      "child",
      "ref",
      "id"
    ],
    "restProps"
  );
  const linkState = ToolbarLinkState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, linkState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Toolbar_link, 30, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var a2 = root_2115();
      attribute_effect(a2, () => ({ href: $$props.href, ...get(mergedProps) }));
      var node_2 = child(a2);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Toolbar_link, 33, 2);
      reset(a2);
      append($$anchor2, a2);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Toolbar_link,
      29,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Toolbar_link = hmr(Toolbar_link, () => Toolbar_link[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Toolbar_link[HMR].source;
    set(Toolbar_link[HMR].source, module.default[HMR].original);
  });
}
var toolbar_link_default = Toolbar_link;

// node_modules/bits-ui/dist/bits/toolbar/components/toolbar-group.svelte
Toolbar_group[FILENAME] = "node_modules/bits-ui/dist/bits/toolbar/components/toolbar-group.svelte";
var root_2116 = add_locations(from_html(`<div><!></div>`), Toolbar_group[FILENAME], [[63, 1]]);
function Toolbar_group($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Toolbar_group);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), value = prop($$props, "value", 15), onValueChange = prop($$props, "onValueChange", 3, noop3), disabled = prop($$props, "disabled", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "ref",
      "value",
      "onValueChange",
      "type",
      "disabled",
      "child",
      "children"
    ],
    "restProps"
  );
  function handleDefaultValue() {
    if (strict_equals(value(), void 0, false)) return;
    value(strict_equals($$props.type, "single") ? "" : []);
  }
  handleDefaultValue();
  watch.pre(() => value(), () => {
    handleDefaultValue();
  });
  const groupState = ToolbarGroupState.create({
    id: box.with(() => id()),
    disabled: box.with(() => disabled()),
    type: $$props.type,
    value: box.with(() => value(), (v) => {
      value(v);
      onValueChange()(v);
    }),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, groupState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Toolbar_group, 61, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var div = root_2116();
      attribute_effect(div, () => ({ ...get(mergedProps) }));
      var node_2 = child(div);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop), "render", Toolbar_group, 64, 2);
      reset(div);
      append($$anchor2, div);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Toolbar_group,
      60,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Toolbar_group = hmr(Toolbar_group, () => Toolbar_group[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Toolbar_group[HMR].source;
    set(Toolbar_group[HMR].source, module.default[HMR].original);
  });
}
var toolbar_group_default = Toolbar_group;

// node_modules/bits-ui/dist/bits/toolbar/components/toolbar-group-item.svelte
Toolbar_group_item[FILENAME] = "node_modules/bits-ui/dist/bits/toolbar/components/toolbar-group-item.svelte";
var root_2117 = add_locations(from_html(`<button><!></button>`), Toolbar_group_item[FILENAME], [[36, 1]]);
function Toolbar_group_item($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Toolbar_group_item);
  let disabled = prop($$props, "disabled", 3, false), type = prop($$props, "type", 3, "button"), id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "child",
      "children",
      "value",
      "disabled",
      "type",
      "id",
      "ref"
    ],
    "restProps"
  );
  const groupItemState = ToolbarGroupItemState.create({
    id: box.with(() => id()),
    value: box.with(() => $$props.value),
    disabled: box.with(() => disabled() ?? false),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, groupItemState.props, { type: type() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      add_svelte_meta(() => snippet(node_1, () => $$props.child, () => ({ props: get(mergedProps), pressed: groupItemState.isPressed })), "render", Toolbar_group_item, 34, 1);
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var button = root_2117();
      attribute_effect(button, () => ({ ...get(mergedProps) }));
      var node_2 = child(button);
      add_svelte_meta(() => snippet(node_2, () => $$props.children ?? noop, () => ({ pressed: groupItemState.isPressed })), "render", Toolbar_group_item, 37, 2);
      reset(button);
      append($$anchor2, button);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if ($$props.child) $$render(consequent);
        else $$render(alternate, false);
      }),
      "if",
      Toolbar_group_item,
      33,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Toolbar_group_item = hmr(Toolbar_group_item, () => Toolbar_group_item[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Toolbar_group_item[HMR].source;
    set(Toolbar_group_item[HMR].source, module.default[HMR].original);
  });
}
var toolbar_group_item_default = Toolbar_group_item;

// node_modules/bits-ui/dist/bits/tooltip/exports.js
var exports_exports41 = {};
__export(exports_exports41, {
  Arrow: () => tooltip_arrow_default,
  Content: () => tooltip_content_default,
  ContentStatic: () => tooltip_content_static_default,
  Portal: () => portal_default,
  Provider: () => tooltip_provider_default,
  Root: () => tooltip_default,
  Trigger: () => tooltip_trigger_default
});

// node_modules/bits-ui/dist/internal/timeout-fn.js
var defaultOpts = {
  immediate: true
};
var TimeoutFn = class {
  #opts;
  #interval;
  #cb;
  #timer = null;
  constructor(cb, interval, opts = {}) {
    this.#cb = cb;
    this.#interval = interval;
    this.#opts = { ...defaultOpts, ...opts };
    this.stop = this.stop.bind(this);
    this.start = this.start.bind(this);
    if (this.#opts.immediate && true_default) {
      this.start();
    }
    onDestroyEffect(this.stop);
  }
  #clear() {
    if (this.#timer !== null) {
      window.clearTimeout(this.#timer);
      this.#timer = null;
    }
  }
  stop() {
    this.#clear();
  }
  start(...args) {
    this.#clear();
    this.#timer = window.setTimeout(() => {
      this.#timer = null;
      this.#cb(...args);
    }, this.#interval);
  }
};

// node_modules/bits-ui/dist/bits/tooltip/tooltip.svelte.js
var tooltipAttrs = createBitsAttrs({ component: "tooltip", parts: ["content", "trigger"] });
var TooltipProviderContext = new Context("Tooltip.Provider");
var TooltipRootContext = new Context("Tooltip.Root");
var TooltipProviderState = class _TooltipProviderState {
  static create(opts) {
    return TooltipProviderContext.set(new _TooltipProviderState(opts));
  }
  opts;
  #isOpenDelayed = tag(state(true), "TooltipProviderState.isOpenDelayed");
  get isOpenDelayed() {
    return get(this.#isOpenDelayed);
  }
  set isOpenDelayed(value) {
    set(this.#isOpenDelayed, value, true);
  }
  isPointerInTransit = box(false);
  #timerFn;
  #openTooltip = tag(state(null), "TooltipProviderState.#openTooltip");
  constructor(opts) {
    this.opts = opts;
    this.#timerFn = new TimeoutFn(
      () => {
        this.isOpenDelayed = true;
      },
      this.opts.skipDelayDuration.current,
      { immediate: false }
    );
  }
  #startTimer = () => {
    const skipDuration = this.opts.skipDelayDuration.current;
    if (strict_equals(skipDuration, 0)) {
      return;
    } else {
      this.#timerFn.start();
    }
  };
  #clearTimer = () => {
    this.#timerFn.stop();
  };
  onOpen = (tooltip) => {
    if (get(this.#openTooltip) && strict_equals(get(this.#openTooltip), tooltip, false)) {
      get(this.#openTooltip).handleClose();
    }
    this.#clearTimer();
    this.isOpenDelayed = false;
    set(this.#openTooltip, tooltip, true);
  };
  onClose = (tooltip) => {
    if (strict_equals(get(this.#openTooltip), tooltip)) {
      set(this.#openTooltip, null);
    }
    this.#startTimer();
  };
  isTooltipOpen = (tooltip) => {
    return strict_equals(get(this.#openTooltip), tooltip);
  };
};
var TooltipRootState = class _TooltipRootState {
  static create(opts) {
    return TooltipRootContext.set(new _TooltipRootState(opts, TooltipProviderContext.get()));
  }
  opts;
  provider;
  #delayDuration = tag(user_derived(() => this.opts.delayDuration.current ?? this.provider.opts.delayDuration.current), "TooltipRootState.delayDuration");
  get delayDuration() {
    return get(this.#delayDuration);
  }
  set delayDuration(value) {
    set(this.#delayDuration, value);
  }
  #disableHoverableContent = tag(user_derived(() => this.opts.disableHoverableContent.current ?? this.provider.opts.disableHoverableContent.current), "TooltipRootState.disableHoverableContent");
  get disableHoverableContent() {
    return get(this.#disableHoverableContent);
  }
  set disableHoverableContent(value) {
    set(this.#disableHoverableContent, value);
  }
  #disableCloseOnTriggerClick = tag(user_derived(() => this.opts.disableCloseOnTriggerClick.current ?? this.provider.opts.disableCloseOnTriggerClick.current), "TooltipRootState.disableCloseOnTriggerClick");
  get disableCloseOnTriggerClick() {
    return get(this.#disableCloseOnTriggerClick);
  }
  set disableCloseOnTriggerClick(value) {
    set(this.#disableCloseOnTriggerClick, value);
  }
  #disabled = tag(user_derived(() => this.opts.disabled.current ?? this.provider.opts.disabled.current), "TooltipRootState.disabled");
  get disabled() {
    return get(this.#disabled);
  }
  set disabled(value) {
    set(this.#disabled, value);
  }
  #ignoreNonKeyboardFocus = tag(user_derived(() => this.opts.ignoreNonKeyboardFocus.current ?? this.provider.opts.ignoreNonKeyboardFocus.current), "TooltipRootState.ignoreNonKeyboardFocus");
  get ignoreNonKeyboardFocus() {
    return get(this.#ignoreNonKeyboardFocus);
  }
  set ignoreNonKeyboardFocus(value) {
    set(this.#ignoreNonKeyboardFocus, value);
  }
  #contentNode = tag(state(null), "TooltipRootState.contentNode");
  get contentNode() {
    return get(this.#contentNode);
  }
  set contentNode(value) {
    set(this.#contentNode, value, true);
  }
  #triggerNode = tag(state(null), "TooltipRootState.triggerNode");
  get triggerNode() {
    return get(this.#triggerNode);
  }
  set triggerNode(value) {
    set(this.#triggerNode, value, true);
  }
  #wasOpenDelayed = tag(state(false), "TooltipRootState.#wasOpenDelayed");
  #timerFn;
  #stateAttr = tag(
    user_derived(() => {
      if (!this.opts.open.current) return "closed";
      return get(this.#wasOpenDelayed) ? "delayed-open" : "instant-open";
    }),
    "TooltipRootState.stateAttr"
  );
  get stateAttr() {
    return get(this.#stateAttr);
  }
  set stateAttr(value) {
    set(this.#stateAttr, value);
  }
  constructor(opts, provider) {
    this.opts = opts;
    this.provider = provider;
    this.#timerFn = new TimeoutFn(
      () => {
        set(this.#wasOpenDelayed, true);
        this.opts.open.current = true;
      },
      this.delayDuration ?? 0,
      { immediate: false }
    );
    new OpenChangeComplete({
      open: this.opts.open,
      ref: box.with(() => this.contentNode),
      onComplete: () => {
        this.opts.onOpenChangeComplete.current(this.opts.open.current);
      }
    });
    watch(() => this.delayDuration, () => {
      if (strict_equals(this.delayDuration, void 0)) return;
      this.#timerFn = new TimeoutFn(
        () => {
          set(this.#wasOpenDelayed, true);
          this.opts.open.current = true;
        },
        this.delayDuration,
        { immediate: false }
      );
    });
    watch(() => this.opts.open.current, (isOpen) => {
      if (isOpen) {
        this.provider.onOpen(this);
      } else {
        this.provider.onClose(this);
      }
    });
  }
  handleOpen = () => {
    this.#timerFn.stop();
    set(this.#wasOpenDelayed, false);
    this.opts.open.current = true;
  };
  handleClose = () => {
    this.#timerFn.stop();
    this.opts.open.current = false;
  };
  #handleDelayedOpen = () => {
    this.#timerFn.stop();
    const shouldSkipDelay = !this.provider.isOpenDelayed;
    const delayDuration = this.delayDuration ?? 0;
    if (shouldSkipDelay || strict_equals(delayDuration, 0)) {
      set(this.#wasOpenDelayed, delayDuration > 0 && shouldSkipDelay, true);
      this.opts.open.current = true;
    } else {
      this.#timerFn.start();
    }
  };
  onTriggerEnter = () => {
    this.#handleDelayedOpen();
  };
  onTriggerLeave = () => {
    if (this.disableHoverableContent) {
      this.handleClose();
    } else {
      this.#timerFn.stop();
    }
  };
};
var TooltipTriggerState = class _TooltipTriggerState {
  static create(opts) {
    return new _TooltipTriggerState(opts, TooltipRootContext.get());
  }
  opts;
  root;
  attachment;
  #isPointerDown = box(false);
  #hasPointerMoveOpened = tag(state(false), "TooltipTriggerState.#hasPointerMoveOpened");
  #isDisabled = tag(user_derived(() => this.opts.disabled.current || this.root.disabled), "TooltipTriggerState.#isDisabled");
  domContext;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.domContext = new DOMContext(opts.ref);
    this.attachment = attachRef(this.opts.ref, (v) => this.root.triggerNode = v);
  }
  handlePointerUp = () => {
    this.#isPointerDown.current = false;
  };
  #onpointerup = () => {
    if (get(this.#isDisabled)) return;
    this.#isPointerDown.current = false;
  };
  #onpointerdown = () => {
    if (get(this.#isDisabled)) return;
    this.#isPointerDown.current = true;
    this.domContext.getDocument().addEventListener(
      "pointerup",
      () => {
        this.handlePointerUp();
      },
      { once: true }
    );
  };
  #onpointermove = (e) => {
    if (get(this.#isDisabled)) return;
    if (strict_equals(e.pointerType, "touch")) return;
    if (get(this.#hasPointerMoveOpened)) return;
    if (this.root.provider.isPointerInTransit.current) return;
    this.root.onTriggerEnter();
    set(this.#hasPointerMoveOpened, true);
  };
  #onpointerleave = () => {
    if (get(this.#isDisabled)) return;
    this.root.onTriggerLeave();
    set(this.#hasPointerMoveOpened, false);
  };
  #onfocus = (e) => {
    if (this.#isPointerDown.current || get(this.#isDisabled)) return;
    if (this.root.ignoreNonKeyboardFocus && !isFocusVisible(e.currentTarget)) return;
    this.root.handleOpen();
  };
  #onblur = () => {
    if (get(this.#isDisabled)) return;
    this.root.handleClose();
  };
  #onclick = () => {
    if (this.root.disableCloseOnTriggerClick || get(this.#isDisabled)) return;
    this.root.handleClose();
  };
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "aria-describedby": this.root.opts.open.current ? this.root.contentNode?.id : void 0,
      "data-state": this.root.stateAttr,
      "data-disabled": getDataDisabled(get(this.#isDisabled)),
      "data-delay-duration": `${this.root.delayDuration}`,
      [tooltipAttrs.trigger]: "",
      tabindex: get(this.#isDisabled) ? void 0 : 0,
      disabled: this.opts.disabled.current,
      onpointerup: this.#onpointerup,
      onpointerdown: this.#onpointerdown,
      onpointermove: this.#onpointermove,
      onpointerleave: this.#onpointerleave,
      onfocus: this.#onfocus,
      onblur: this.#onblur,
      onclick: this.#onclick,
      ...this.attachment
    })),
    "TooltipTriggerState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
};
var TooltipContentState = class _TooltipContentState {
  static create(opts) {
    return new _TooltipContentState(opts, TooltipRootContext.get());
  }
  opts;
  root;
  attachment;
  constructor(opts, root18) {
    this.opts = opts;
    this.root = root18;
    this.attachment = attachRef(this.opts.ref, (v) => this.root.contentNode = v);
    new GraceArea({
      triggerNode: () => this.root.triggerNode,
      contentNode: () => this.root.contentNode,
      enabled: () => this.root.opts.open.current && !this.root.disableHoverableContent,
      onPointerExit: () => {
        if (this.root.provider.isTooltipOpen(this.root)) {
          this.root.handleClose();
        }
      },
      setIsPointerInTransit: (value) => {
        this.root.provider.isPointerInTransit.current = value;
      },
      transitTimeout: this.root.provider.opts.skipDelayDuration.current
    });
    onMountEffect(() => on(window, "scroll", (e) => {
      const target = e.target;
      if (!target) return;
      if (target.contains(this.root.triggerNode)) {
        this.root.handleClose();
      }
    }));
  }
  onInteractOutside = (e) => {
    if (isElement2(e.target) && this.root.triggerNode?.contains(e.target) && this.root.disableCloseOnTriggerClick) {
      e.preventDefault();
      return;
    }
    this.opts.onInteractOutside.current(e);
    if (e.defaultPrevented) return;
    this.root.handleClose();
  };
  onEscapeKeydown = (e) => {
    this.opts.onEscapeKeydown.current?.(e);
    if (e.defaultPrevented) return;
    this.root.handleClose();
  };
  onOpenAutoFocus = (e) => {
    e.preventDefault();
  };
  onCloseAutoFocus = (e) => {
    e.preventDefault();
  };
  #snippetProps = tag(user_derived(() => ({ open: this.root.opts.open.current })), "TooltipContentState.snippetProps");
  get snippetProps() {
    return get(this.#snippetProps);
  }
  set snippetProps(value) {
    set(this.#snippetProps, value);
  }
  #props = tag(
    user_derived(() => ({
      id: this.opts.id.current,
      "data-state": this.root.stateAttr,
      "data-disabled": getDataDisabled(this.root.disabled),
      style: { pointerEvents: "auto", outline: "none" },
      [tooltipAttrs.content]: "",
      ...this.attachment
    })),
    "TooltipContentState.props"
  );
  get props() {
    return get(this.#props);
  }
  set props(value) {
    set(this.#props, value);
  }
  popperProps = {
    onInteractOutside: this.onInteractOutside,
    onEscapeKeydown: this.onEscapeKeydown,
    onOpenAutoFocus: this.onOpenAutoFocus,
    onCloseAutoFocus: this.onCloseAutoFocus
  };
};

// node_modules/bits-ui/dist/bits/tooltip/components/tooltip.svelte
Tooltip[FILENAME] = "node_modules/bits-ui/dist/bits/tooltip/components/tooltip.svelte";
function Tooltip($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Tooltip);
  let open = prop($$props, "open", 15, false), onOpenChange = prop($$props, "onOpenChange", 3, noop3), onOpenChangeComplete = prop($$props, "onOpenChangeComplete", 3, noop3);
  TooltipRootState.create({
    open: box.with(() => open(), (v) => {
      open(v);
      onOpenChange()(v);
    }),
    delayDuration: box.with(() => $$props.delayDuration),
    disableCloseOnTriggerClick: box.with(() => $$props.disableCloseOnTriggerClick),
    disableHoverableContent: box.with(() => $$props.disableHoverableContent),
    ignoreNonKeyboardFocus: box.with(() => $$props.ignoreNonKeyboardFocus),
    disabled: box.with(() => $$props.disabled),
    onOpenChangeComplete: box.with(() => onOpenChangeComplete())
  });
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => floating_layer_default(node, {
      tooltip: true,
      children: wrap_snippet(Tooltip, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        add_svelte_meta(() => snippet(node_1, () => $$props.children ?? noop), "render", Tooltip, 38, 1);
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }),
    "component",
    Tooltip,
    37,
    0,
    { componentTag: "FloatingLayer" }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tooltip = hmr(Tooltip, () => Tooltip[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tooltip[HMR].source;
    set(Tooltip[HMR].source, module.default[HMR].original);
  });
}
var tooltip_default = Tooltip;

// node_modules/bits-ui/dist/bits/tooltip/components/tooltip-content.svelte
Tooltip_content[FILENAME] = "node_modules/bits-ui/dist/bits/tooltip/components/tooltip-content.svelte";
var root_421 = add_locations(from_html(`<div><div><!></div></div>`), Tooltip_content[FILENAME], [[76, 4, [[77, 5]]]]);
var root_915 = add_locations(from_html(`<div><div><!></div></div>`), Tooltip_content[FILENAME], [[104, 4, [[105, 5]]]]);
function Tooltip_content($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Tooltip_content);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), side = prop($$props, "side", 3, "top"), sideOffset = prop($$props, "sideOffset", 3, 0), align = prop($$props, "align", 3, "center"), avoidCollisions = prop($$props, "avoidCollisions", 3, true), arrowPadding = prop($$props, "arrowPadding", 3, 0), sticky = prop($$props, "sticky", 3, "partial"), hideWhenDetached = prop($$props, "hideWhenDetached", 3, false), collisionPadding = prop($$props, "collisionPadding", 3, 0), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "side",
      "sideOffset",
      "align",
      "avoidCollisions",
      "arrowPadding",
      "sticky",
      "hideWhenDetached",
      "collisionPadding",
      "onInteractOutside",
      "onEscapeKeydown",
      "forceMount"
    ],
    "restProps"
  );
  const contentState = TooltipContentState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onInteractOutside: box.with(() => onInteractOutside()),
    onEscapeKeydown: box.with(() => onEscapeKeydown())
  });
  const floatingProps = tag(
    user_derived(() => ({
      side: side(),
      sideOffset: sideOffset(),
      align: align(),
      avoidCollisions: avoidCollisions(),
      arrowPadding: arrowPadding(),
      sticky: sticky(),
      hideWhenDetached: hideWhenDetached(),
      collisionPadding: collisionPadding()
    })),
    "floatingProps"
  );
  const mergedProps = tag(user_derived(() => mergeProps(restProps, get(floatingProps), contentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Tooltip_content, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0?.().props;
          props();
          let wrapperProps = () => $$arg0?.().wrapperProps;
          wrapperProps();
          var fragment_2 = comment();
          const mergedProps2 = tag(user_derived(() => mergeProps(props(), { style: getFloatingContentCSSVars("tooltip") })), "mergedProps");
          get(mergedProps2);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              {
                let $0 = user_derived(() => ({
                  props: get(mergedProps2),
                  wrapperProps: wrapperProps(),
                  ...contentState.snippetProps
                }));
                add_svelte_meta(() => snippet(node_3, () => $$props.child, () => get($0)), "render", Tooltip_content, 74, 4);
              }
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_421();
              attribute_effect(div, () => ({ ...wrapperProps() }));
              var div_1 = child(div);
              attribute_effect(div_1, () => ({ ...get(mergedProps2) }));
              var node_4 = child(div_1);
              add_svelte_meta(() => snippet(node_4, () => $$props.children ?? noop), "render", Tooltip_content, 78, 6);
              reset(div_1);
              reset(div);
              append($$anchor4, div);
            };
            add_svelte_meta(
              () => if_block(node_2, ($$render) => {
                if ($$props.child) $$render(consequent);
                else $$render(alternate, false);
              }),
              "if",
              Tooltip_content,
              73,
              3
            );
          }
          append($$anchor3, fragment_2);
        });
        add_svelte_meta(
          () => popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), () => contentState.popperProps, {
            get enabled() {
              return contentState.root.opts.open.current;
            },
            get id() {
              return id();
            },
            trapFocus: false,
            loop: false,
            preventScroll: false,
            forceMount: true,
            get ref() {
              return contentState.opts.ref;
            },
            tooltip: true,
            popper,
            $$slots: { popper: true }
          })),
          "component",
          Tooltip_content,
          57,
          1,
          { componentTag: "PopperLayerForceMount" }
        );
      }
      append($$anchor2, fragment_1);
    };
    var alternate_2 = ($$anchor2) => {
      var fragment_4 = comment();
      var node_5 = first_child(fragment_4);
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_5 = comment();
          var node_6 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Tooltip_content, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0?.().props;
              props();
              let wrapperProps = () => $$arg0?.().wrapperProps;
              wrapperProps();
              var fragment_6 = comment();
              const mergedProps2 = tag(user_derived(() => mergeProps(props(), { style: getFloatingContentCSSVars("tooltip") })), "mergedProps");
              get(mergedProps2);
              var node_7 = first_child(fragment_6);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_8 = first_child(fragment_7);
                  {
                    let $0 = user_derived(() => ({
                      props: get(mergedProps2),
                      wrapperProps: wrapperProps(),
                      ...contentState.snippetProps
                    }));
                    add_svelte_meta(() => snippet(node_8, () => $$props.child, () => get($0)), "render", Tooltip_content, 102, 4);
                  }
                  append($$anchor5, fragment_7);
                };
                var alternate_1 = ($$anchor5) => {
                  var div_2 = root_915();
                  attribute_effect(div_2, () => ({ ...wrapperProps() }));
                  var div_3 = child(div_2);
                  attribute_effect(div_3, () => ({ ...get(mergedProps2) }));
                  var node_9 = child(div_3);
                  add_svelte_meta(() => snippet(node_9, () => $$props.children ?? noop), "render", Tooltip_content, 106, 6);
                  reset(div_3);
                  reset(div_2);
                  append($$anchor5, div_2);
                };
                add_svelte_meta(
                  () => if_block(node_7, ($$render) => {
                    if ($$props.child) $$render(consequent_2);
                    else $$render(alternate_1, false);
                  }),
                  "if",
                  Tooltip_content,
                  101,
                  3
                );
              }
              append($$anchor4, fragment_6);
            });
            add_svelte_meta(
              () => popper_layer_default(node_6, spread_props(() => get(mergedProps), () => contentState.popperProps, {
                get open() {
                  return contentState.root.opts.open.current;
                },
                get id() {
                  return id();
                },
                trapFocus: false,
                loop: false,
                preventScroll: false,
                forceMount: false,
                get ref() {
                  return contentState.opts.ref;
                },
                tooltip: true,
                popper,
                $$slots: { popper: true }
              })),
              "component",
              Tooltip_content,
              85,
              1,
              { componentTag: "PopperLayer" }
            );
          }
          append($$anchor3, fragment_5);
        };
        add_svelte_meta(
          () => if_block(
            node_5,
            ($$render) => {
              if (!forceMount()) $$render(consequent_3);
            },
            true
          ),
          "if",
          Tooltip_content,
          84,
          0
        );
      }
      append($$anchor2, fragment_4);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (forceMount()) $$render(consequent_1);
        else $$render(alternate_2, false);
      }),
      "if",
      Tooltip_content,
      56,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tooltip_content = hmr(Tooltip_content, () => Tooltip_content[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tooltip_content[HMR].source;
    set(Tooltip_content[HMR].source, module.default[HMR].original);
  });
}
var tooltip_content_default = Tooltip_content;

// node_modules/bits-ui/dist/bits/tooltip/components/tooltip-content-static.svelte
Tooltip_content_static[FILENAME] = "node_modules/bits-ui/dist/bits/tooltip/components/tooltip-content-static.svelte";
var root_422 = add_locations(from_html(`<div><!></div>`), Tooltip_content_static[FILENAME], [[58, 4]]);
var root_916 = add_locations(from_html(`<div><!></div>`), Tooltip_content_static[FILENAME], [[85, 4]]);
function Tooltip_content_static($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Tooltip_content_static);
  let id = prop($$props, "id", 19, () => createId(uid)), ref = prop($$props, "ref", 15, null), onInteractOutside = prop($$props, "onInteractOutside", 3, noop3), onEscapeKeydown = prop($$props, "onEscapeKeydown", 3, noop3), forceMount = prop($$props, "forceMount", 3, false), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "ref",
      "onInteractOutside",
      "onEscapeKeydown",
      "forceMount"
    ],
    "restProps"
  );
  const contentState = TooltipContentState.create({
    id: box.with(() => id()),
    ref: box.with(() => ref(), (v) => ref(v)),
    onInteractOutside: box.with(() => onInteractOutside()),
    onEscapeKeydown: box.with(() => onEscapeKeydown())
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, contentState.props)), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      {
        const popper = wrap_snippet(Tooltip_content_static, function($$anchor3, $$arg0) {
          validate_snippet_args(...arguments);
          let props = () => $$arg0?.().props;
          props();
          var fragment_2 = comment();
          const mergedProps2 = tag(user_derived(() => mergeProps(props(), { style: getFloatingContentCSSVars("tooltip") })), "mergedProps");
          get(mergedProps2);
          var node_2 = first_child(fragment_2);
          {
            var consequent = ($$anchor4) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              {
                let $0 = user_derived(() => ({ props: get(mergedProps2), ...contentState.snippetProps }));
                add_svelte_meta(() => snippet(node_3, () => $$props.child, () => get($0)), "render", Tooltip_content_static, 56, 4);
              }
              append($$anchor4, fragment_3);
            };
            var alternate = ($$anchor4) => {
              var div = root_422();
              attribute_effect(div, () => ({ ...get(mergedProps2) }));
              var node_4 = child(div);
              add_svelte_meta(() => snippet(node_4, () => $$props.children ?? noop), "render", Tooltip_content_static, 59, 5);
              reset(div);
              append($$anchor4, div);
            };
            add_svelte_meta(
              () => if_block(node_2, ($$render) => {
                if ($$props.child) $$render(consequent);
                else $$render(alternate, false);
              }),
              "if",
              Tooltip_content_static,
              55,
              3
            );
          }
          append($$anchor3, fragment_2);
        });
        add_svelte_meta(
          () => popper_layer_force_mount_default(node_1, spread_props(() => get(mergedProps), () => contentState.popperProps, {
            isStatic: true,
            get enabled() {
              return contentState.root.opts.open.current;
            },
            get id() {
              return id();
            },
            trapFocus: false,
            loop: false,
            preventScroll: false,
            forceMount: true,
            get ref() {
              return contentState.opts.ref;
            },
            tooltip: true,
            popper,
            $$slots: { popper: true }
          })),
          "component",
          Tooltip_content_static,
          38,
          1,
          { componentTag: "PopperLayerForceMount" }
        );
      }
      append($$anchor2, fragment_1);
    };
    var alternate_2 = ($$anchor2) => {
      var fragment_4 = comment();
      var node_5 = first_child(fragment_4);
      {
        var consequent_3 = ($$anchor3) => {
          var fragment_5 = comment();
          var node_6 = first_child(fragment_5);
          {
            const popper = wrap_snippet(Tooltip_content_static, function($$anchor4, $$arg0) {
              validate_snippet_args(...arguments);
              let props = () => $$arg0?.().props;
              props();
              var fragment_6 = comment();
              const mergedProps2 = tag(user_derived(() => mergeProps(props(), { style: getFloatingContentCSSVars("tooltip") })), "mergedProps");
              get(mergedProps2);
              var node_7 = first_child(fragment_6);
              {
                var consequent_2 = ($$anchor5) => {
                  var fragment_7 = comment();
                  var node_8 = first_child(fragment_7);
                  {
                    let $0 = user_derived(() => ({ props: get(mergedProps2), ...contentState.snippetProps }));
                    add_svelte_meta(() => snippet(node_8, () => $$props.child, () => get($0)), "render", Tooltip_content_static, 83, 4);
                  }
                  append($$anchor5, fragment_7);
                };
                var alternate_1 = ($$anchor5) => {
                  var div_1 = root_916();
                  attribute_effect(div_1, () => ({ ...get(mergedProps2) }));
                  var node_9 = child(div_1);
                  add_svelte_meta(() => snippet(node_9, () => $$props.children ?? noop), "render", Tooltip_content_static, 86, 5);
                  reset(div_1);
                  append($$anchor5, div_1);
                };
                add_svelte_meta(
                  () => if_block(node_7, ($$render) => {
                    if ($$props.child) $$render(consequent_2);
                    else $$render(alternate_1, false);
                  }),
                  "if",
                  Tooltip_content_static,
                  82,
                  3
                );
              }
              append($$anchor4, fragment_6);
            });
            add_svelte_meta(
              () => popper_layer_default(node_6, spread_props(() => get(mergedProps), () => contentState.popperProps, {
                tooltip: true,
                isStatic: true,
                get open() {
                  return contentState.root.opts.open.current;
                },
                get id() {
                  return id();
                },
                trapFocus: false,
                loop: false,
                preventScroll: false,
                forceMount: false,
                get ref() {
                  return contentState.opts.ref;
                },
                popper,
                $$slots: { popper: true }
              })),
              "component",
              Tooltip_content_static,
              65,
              1,
              { componentTag: "PopperLayer" }
            );
          }
          append($$anchor3, fragment_5);
        };
        add_svelte_meta(
          () => if_block(
            node_5,
            ($$render) => {
              if (!forceMount()) $$render(consequent_3);
            },
            true
          ),
          "if",
          Tooltip_content_static,
          64,
          0
        );
      }
      append($$anchor2, fragment_4);
    };
    add_svelte_meta(
      () => if_block(node, ($$render) => {
        if (forceMount()) $$render(consequent_1);
        else $$render(alternate_2, false);
      }),
      "if",
      Tooltip_content_static,
      37,
      0
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tooltip_content_static = hmr(Tooltip_content_static, () => Tooltip_content_static[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tooltip_content_static[HMR].source;
    set(Tooltip_content_static[HMR].source, module.default[HMR].original);
  });
}
var tooltip_content_static_default = Tooltip_content_static;

// node_modules/bits-ui/dist/bits/tooltip/components/tooltip-trigger.svelte
Tooltip_trigger[FILENAME] = "node_modules/bits-ui/dist/bits/tooltip/components/tooltip-trigger.svelte";
var root_323 = add_locations(from_html(`<button><!></button>`), Tooltip_trigger[FILENAME], [[36, 2]]);
function Tooltip_trigger($$anchor, $$props) {
  const uid = props_id();
  check_target(new.target);
  push($$props, true, Tooltip_trigger);
  let id = prop($$props, "id", 19, () => createId(uid)), disabled = prop($$props, "disabled", 3, false), type = prop($$props, "type", 3, "button"), ref = prop($$props, "ref", 15, null), restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "children",
      "child",
      "id",
      "disabled",
      "type",
      "ref"
    ],
    "restProps"
  );
  const triggerState = TooltipTriggerState.create({
    id: box.with(() => id()),
    disabled: box.with(() => disabled() ?? false),
    ref: box.with(() => ref(), (v) => ref(v))
  });
  const mergedProps = tag(user_derived(() => mergeProps(restProps, triggerState.props, { type: type() })), "mergedProps");
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(
    () => floating_layer_anchor_default(node, {
      get id() {
        return id();
      },
      get ref() {
        return triggerState.opts.ref;
      },
      tooltip: true,
      children: wrap_snippet(Tooltip_trigger, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node_1 = first_child(fragment_1);
        {
          var consequent = ($$anchor3) => {
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            add_svelte_meta(() => snippet(node_2, () => $$props.child, () => ({ props: get(mergedProps) })), "render", Tooltip_trigger, 34, 2);
            append($$anchor3, fragment_2);
          };
          var alternate = ($$anchor3) => {
            var button = root_323();
            attribute_effect(button, () => ({ ...get(mergedProps) }));
            var node_3 = child(button);
            add_svelte_meta(() => snippet(node_3, () => $$props.children ?? noop), "render", Tooltip_trigger, 37, 3);
            reset(button);
            append($$anchor3, button);
          };
          add_svelte_meta(
            () => if_block(node_1, ($$render) => {
              if ($$props.child) $$render(consequent);
              else $$render(alternate, false);
            }),
            "if",
            Tooltip_trigger,
            33,
            1
          );
        }
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }),
    "component",
    Tooltip_trigger,
    32,
    0,
    { componentTag: "FloatingLayerAnchor" }
  );
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tooltip_trigger = hmr(Tooltip_trigger, () => Tooltip_trigger[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tooltip_trigger[HMR].source;
    set(Tooltip_trigger[HMR].source, module.default[HMR].original);
  });
}
var tooltip_trigger_default = Tooltip_trigger;

// node_modules/bits-ui/dist/bits/tooltip/components/tooltip-arrow.svelte
Tooltip_arrow[FILENAME] = "node_modules/bits-ui/dist/bits/tooltip/components/tooltip-arrow.svelte";
function Tooltip_arrow($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Tooltip_arrow);
  var $$ownership_validator = create_ownership_validator($$props);
  let ref = prop($$props, "ref", 15, null), restProps = rest_props($$props, ["$$slots", "$$events", "$$legacy", "ref"], "restProps");
  var fragment = comment();
  var node = first_child(fragment);
  {
    $$ownership_validator.binding("ref", floating_layer_arrow_default, ref);
    add_svelte_meta(
      () => floating_layer_arrow_default(node, spread_props(() => restProps, {
        get ref() {
          return ref();
        },
        set ref($$value) {
          ref($$value);
        }
      })),
      "component",
      Tooltip_arrow,
      8,
      0,
      { componentTag: "FloatingLayerArrow" }
    );
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tooltip_arrow = hmr(Tooltip_arrow, () => Tooltip_arrow[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tooltip_arrow[HMR].source;
    set(Tooltip_arrow[HMR].source, module.default[HMR].original);
  });
}
var tooltip_arrow_default = Tooltip_arrow;

// node_modules/bits-ui/dist/bits/tooltip/components/tooltip-provider.svelte
Tooltip_provider[FILENAME] = "node_modules/bits-ui/dist/bits/tooltip/components/tooltip-provider.svelte";
function Tooltip_provider($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Tooltip_provider);
  let delayDuration = prop($$props, "delayDuration", 3, 700), disableCloseOnTriggerClick = prop($$props, "disableCloseOnTriggerClick", 3, false), disableHoverableContent = prop($$props, "disableHoverableContent", 3, false), disabled = prop($$props, "disabled", 3, false), ignoreNonKeyboardFocus = prop($$props, "ignoreNonKeyboardFocus", 3, false), skipDelayDuration = prop($$props, "skipDelayDuration", 3, 300);
  TooltipProviderState.create({
    delayDuration: box.with(() => delayDuration()),
    disableCloseOnTriggerClick: box.with(() => disableCloseOnTriggerClick()),
    disableHoverableContent: box.with(() => disableHoverableContent()),
    disabled: box.with(() => disabled()),
    ignoreNonKeyboardFocus: box.with(() => ignoreNonKeyboardFocus()),
    skipDelayDuration: box.with(() => skipDelayDuration())
  });
  var fragment = comment();
  var node = first_child(fragment);
  add_svelte_meta(() => snippet(node, () => $$props.children ?? noop), "render", Tooltip_provider, 26, 0);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  Tooltip_provider = hmr(Tooltip_provider, () => Tooltip_provider[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Tooltip_provider[HMR].source;
    set(Tooltip_provider[HMR].source, module.default[HMR].original);
  });
}
var tooltip_provider_default = Tooltip_provider;

// node_modules/bits-ui/dist/bits/utilities/is-using-keyboard/is-using-keyboard.svelte.js
var isUsingKeyboard = tag(state(false), "isUsingKeyboard");
var IsUsingKeyboard = class _IsUsingKeyboard {
  static _refs = 0;
  // Reference counting to avoid multiple listeners.
  static _cleanup;
  constructor() {
    user_effect(() => {
      if (strict_equals(_IsUsingKeyboard._refs, 0)) {
        _IsUsingKeyboard._cleanup = effect_root(() => {
          const callbacksToDispose = [];
          const handlePointer = (_) => {
            set(isUsingKeyboard, false);
          };
          const handleKeydown = (_) => {
            set(isUsingKeyboard, true);
          };
          callbacksToDispose.push(on(document, "pointerdown", handlePointer, { capture: true }), on(document, "pointermove", handlePointer, { capture: true }), on(document, "keydown", handleKeydown, { capture: true }));
          return executeCallbacks(...callbacksToDispose);
        });
      }
      _IsUsingKeyboard._refs++;
      return () => {
        _IsUsingKeyboard._refs--;
        if (strict_equals(_IsUsingKeyboard._refs, 0)) {
          set(isUsingKeyboard, false);
          _IsUsingKeyboard._cleanup?.();
        }
      };
    });
  }
  get current() {
    return get(isUsingKeyboard);
  }
  set current(value) {
    set(isUsingKeyboard, value, true);
  }
};
export {
  exports_exports as Accordion,
  exports_exports2 as AlertDialog,
  exports_exports3 as AspectRatio,
  exports_exports4 as Avatar,
  bits_config_default as BitsConfig,
  exports_exports5 as Button,
  exports_exports6 as Calendar,
  exports_exports7 as Checkbox,
  exports_exports8 as Collapsible,
  exports_exports9 as Combobox,
  exports_exports10 as Command,
  exports_exports11 as ContextMenu,
  exports_exports12 as DateField,
  exports_exports13 as DatePicker,
  exports_exports14 as DateRangeField,
  exports_exports15 as DateRangePicker,
  exports_exports16 as Dialog,
  exports_exports17 as DropdownMenu,
  IsUsingKeyboard,
  exports_exports18 as Label,
  exports_exports19 as LinkPreview,
  exports_exports20 as Menubar,
  exports_exports21 as Meter,
  exports_exports22 as NavigationMenu,
  exports_exports23 as Pagination,
  exports_exports24 as PinInput,
  exports_exports25 as Popover,
  portal_default as Portal,
  exports_exports26 as Progress,
  REGEXP_ONLY_CHARS,
  REGEXP_ONLY_DIGITS,
  REGEXP_ONLY_DIGITS_AND_CHARS,
  exports_exports27 as RadioGroup,
  exports_exports28 as RangeCalendar,
  exports_exports30 as ScrollArea,
  exports_exports31 as Select,
  exports_exports32 as Separator,
  exports_exports33 as Slider,
  exports_exports34 as Switch,
  exports_exports35 as Tabs,
  exports_exports36 as TimeField,
  exports_exports37 as TimeRangeField,
  exports_exports38 as Toggle,
  exports_exports39 as ToggleGroup,
  exports_exports40 as Toolbar,
  exports_exports41 as Tooltip,
  computeCommandScore,
  getBitsConfig,
  mergeProps,
  exports_exports29 as unstable_RatingGroup,
  useId
};
//# sourceMappingURL=bits-ui.js.map

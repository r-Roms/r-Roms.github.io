import { attachRef, box, } from "svelte-toolbelt";
import { Context } from "runed";
import { kbd } from "../../internal/kbd.js";
import { createBitsAttrs, getAriaExpanded, getDataOpenClosed } from "../../internal/attrs.js";
import { isElement } from "../../internal/is.js";
import { OpenChangeComplete } from "../../internal/open-change-complete.js";
const popoverAttrs = createBitsAttrs({
    component: "popover",
    parts: ["root", "trigger", "content", "close"],
});
const PopoverRootContext = new Context("Popover.Root");
export class PopoverRootState {
    static create(opts) {
        return PopoverRootContext.set(new PopoverRootState(opts));
    }
    opts;
    contentNode = $state(null);
    triggerNode = $state(null);
    constructor(opts) {
        this.opts = opts;
        new OpenChangeComplete({
            ref: box.with(() => this.contentNode),
            open: this.opts.open,
            onComplete: () => {
                this.opts.onOpenChangeComplete.current(this.opts.open.current);
            },
        });
    }
    toggleOpen() {
        this.opts.open.current = !this.opts.open.current;
    }
    handleClose() {
        if (!this.opts.open.current)
            return;
        this.opts.open.current = false;
    }
}
export class PopoverTriggerState {
    static create(opts) {
        return new PopoverTriggerState(opts, PopoverRootContext.get());
    }
    opts;
    root;
    attachment;
    constructor(opts, root) {
        this.opts = opts;
        this.root = root;
        this.attachment = attachRef(this.opts.ref, (v) => (this.root.triggerNode = v));
        this.onclick = this.onclick.bind(this);
        this.onkeydown = this.onkeydown.bind(this);
    }
    onclick(e) {
        if (this.opts.disabled.current)
            return;
        if (e.button !== 0)
            return;
        this.root.toggleOpen();
    }
    onkeydown(e) {
        if (this.opts.disabled.current)
            return;
        if (!(e.key === kbd.ENTER || e.key === kbd.SPACE))
            return;
        e.preventDefault();
        this.root.toggleOpen();
    }
    #getAriaControls() {
        if (this.root.opts.open.current && this.root.contentNode?.id) {
            return this.root.contentNode?.id;
        }
        return undefined;
    }
    props = $derived.by(() => ({
        id: this.opts.id.current,
        "aria-haspopup": "dialog",
        "aria-expanded": getAriaExpanded(this.root.opts.open.current),
        "data-state": getDataOpenClosed(this.root.opts.open.current),
        "aria-controls": this.#getAriaControls(),
        [popoverAttrs.trigger]: "",
        disabled: this.opts.disabled.current,
        //
        onkeydown: this.onkeydown,
        onclick: this.onclick,
        ...this.attachment,
    }));
}
export class PopoverContentState {
    static create(opts) {
        return new PopoverContentState(opts, PopoverRootContext.get());
    }
    opts;
    root;
    attachment;
    constructor(opts, root) {
        this.opts = opts;
        this.root = root;
        this.attachment = attachRef(this.opts.ref, (v) => (this.root.contentNode = v));
    }
    onInteractOutside = (e) => {
        this.opts.onInteractOutside.current(e);
        if (e.defaultPrevented)
            return;
        if (!isElement(e.target))
            return;
        const closestTrigger = e.target.closest(popoverAttrs.selector("trigger"));
        if (closestTrigger === this.root.triggerNode)
            return;
        this.root.handleClose();
    };
    onEscapeKeydown = (e) => {
        this.opts.onEscapeKeydown.current(e);
        if (e.defaultPrevented)
            return;
        this.root.handleClose();
    };
    onCloseAutoFocus = (e) => {
        this.opts.onCloseAutoFocus.current?.(e);
        if (e.defaultPrevented)
            return;
        e.preventDefault();
        this.root.triggerNode?.focus();
    };
    snippetProps = $derived.by(() => ({ open: this.root.opts.open.current }));
    props = $derived.by(() => ({
        id: this.opts.id.current,
        tabindex: -1,
        "data-state": getDataOpenClosed(this.root.opts.open.current),
        [popoverAttrs.content]: "",
        style: {
            pointerEvents: "auto",
        },
        ...this.attachment,
    }));
    popperProps = {
        onInteractOutside: this.onInteractOutside,
        onEscapeKeydown: this.onEscapeKeydown,
        onCloseAutoFocus: this.onCloseAutoFocus,
    };
}
export class PopoverCloseState {
    static create(opts) {
        return new PopoverCloseState(opts, PopoverRootContext.get());
    }
    opts;
    root;
    attachment;
    constructor(opts, root) {
        this.opts = opts;
        this.root = root;
        this.attachment = attachRef(this.opts.ref);
        this.onclick = this.onclick.bind(this);
        this.onkeydown = this.onkeydown.bind(this);
    }
    onclick(_) {
        this.root.handleClose();
    }
    onkeydown(e) {
        if (!(e.key === kbd.ENTER || e.key === kbd.SPACE))
            return;
        e.preventDefault();
        this.root.handleClose();
    }
    props = $derived.by(() => ({
        id: this.opts.id.current,
        onclick: this.onclick,
        onkeydown: this.onkeydown,
        type: "button",
        [popoverAttrs.close]: "",
        ...this.attachment,
    }));
}
